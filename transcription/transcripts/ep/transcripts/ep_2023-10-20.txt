
[00:00:00.000 --> 00:00:06.160]   Wir wollen uns heute weiter mit dem Thema Klassen und Objekte beschäftigen.
[00:00:06.160 --> 00:00:11.680]   Wenn die Lautstärke nicht genug ist oder dann schreiben Sie bitte in den Chat und
[00:00:11.680 --> 00:00:14.040]   dann versuchen wir das so richtig zu machen.
[00:00:14.040 --> 00:00:24.240]   Okay, wir wollen, dass das Thema Klassen selber entwickeln, als Sie zum ersten Mal ansehen.
[00:00:24.240 --> 00:00:28.960]   Das Thema wird uns einige Vorlesungen und sogar noch einige weitere Wochen beschäftigen.
[00:00:28.960 --> 00:00:36.960]   Aber wir werden heute versuchen, die Grundlagen der Klassen und des Glaskonstrukts zu diskutieren.
[00:00:36.960 --> 00:00:42.160]   Aber ich dachte, ich zeige Ihnen auch kurz das Ergebnis der letzten Poll, wo Sie mit diesen
[00:00:42.160 --> 00:00:49.680]   Array-Parametern arbeiten mussten und erfreulicherweise haben, dass diesjahr 60 Prozent der Studierenden,
[00:00:49.680 --> 00:00:54.240]   die daran teilnahm, es waren wen, die diesmal letztes Jahr die Antwort richtig gemacht.
[00:00:54.240 --> 00:00:58.040]   Also die anderen 40 Prozent, bitte gucken Sie sich es genauer an.
[00:00:58.040 --> 00:01:02.400]   Im Allgemeinen schätzen wir hier den Romanfond.
[00:01:02.400 --> 00:01:07.480]   Ich bin nicht ein Experte in allen anderen Fonds, mein japanisches leider auch nicht mehr so gut.
[00:01:07.480 --> 00:01:12.160]   Also von daher, wenn Sie was schreiben, bitte, so dass ich es verstehen kann, hilft es mir.
[00:01:12.160 --> 00:01:14.760]   Okay, warum brauchen wir jetzt Klassen?
[00:01:14.760 --> 00:01:16.440]   Was ist die Grundidee dahinter?
[00:01:16.440 --> 00:01:19.880]   Stellen Sie sich vor, Sie haben das Problem, das hatten wir schon mal angefangen,
[00:01:19.880 --> 00:01:25.640]   dass Sie da für einen Verein die Körpergröße für die Mitglieder von verschiedenen Personen bearbeiten wollen.
[00:01:25.640 --> 00:01:33.200]   Und jetzt, nachdem Sie das gemacht haben, kommt die Zusatzaufgabe, dass Sie zum Beispiel zusätzlich
[00:01:33.200 --> 00:01:35.840]   das Gewicht für jede Person einlesen sollten.
[00:01:35.840 --> 00:01:42.040]   Also für die sechs Mitglieder Ihrer Gruppe würden Sie erst die Größe in Zentimetern
[00:01:42.040 --> 00:01:45.440]   und dann das Gewicht in Kilogramm angeben.
[00:01:45.440 --> 00:01:50.440]   Das ist also eine Aufgabe, die Sie hätten und das könnten Sie eigentlich mit dem,
[00:01:50.440 --> 00:01:53.640]   was Sie bisher gelernt haben, eigentlich ganz gut machen.
[00:01:53.640 --> 00:01:57.440]   Weil Sie wollen nach den Daten analysieren oder irgendwas anderes machen, sehen,
[00:01:57.440 --> 00:02:01.040]   wer größer als der Durchschnitt ist und so weiter.
[00:02:01.040 --> 00:02:07.440]   Also würden Sie die Daten einlesen, das würden wir so machen, dass wir eben halt den einen Scanner uns besorgen.
[00:02:07.440 --> 00:02:13.640]   Den nennen wir mal Input und dann lesen wir die Anzahl der Input, die wir verarbeiten wollen.
[00:02:13.640 --> 00:02:20.240]   Und dann für jede Person lesen wir einmal die Höhe und einmal das Gewicht,
[00:02:20.240 --> 00:02:26.640]   indem wir halt hier die Speichermann im Erreher und hier lesen wir also die Höhe,
[00:02:26.640 --> 00:02:32.040]   die Speichermann im Errehen und dann lesen wir das Gewicht in Kilogramm und speichern es am anderen Erreher.
[00:02:32.040 --> 00:02:40.440]   Also wir haben jetzt zwei Erreys, in denen wir die Größe und das Gewicht jeder Person abspeichern.
[00:02:40.440 --> 00:02:47.840]   Und was für eine Dimension, also für die Größe, vor einer Woche oder vor anderthalb Wochen noch eine gute Idee war,
[00:02:47.840 --> 00:02:52.440]   jetzt mit zwei verschiedenen Dimensionen ist das eine sehr schlechte Lösung.
[00:02:52.440 --> 00:02:57.640]   Aber wenn Sie das so machen, dann haben Sie verschiedene Probleme, die Sie bearbeiten müssen.
[00:02:57.640 --> 00:03:02.640]   Zum Beispiel haben Sie das Problem, dass Sie jetzt sehr sich anstrengen müssten,
[00:03:02.640 --> 00:03:06.440]   wenn Sie die Personen, deren Daten Sie jetzt eingelesen haben,
[00:03:06.440 --> 00:03:10.240]   die wollen Sie einmal nach der Größe sortieren und einmal nach dem Gewicht.
[00:03:10.240 --> 00:03:14.440]   Und da ist es sehr schwer aufzupassen oder nicht die Übersicht zu verlieren.
[00:03:14.440 --> 00:03:22.040]   Es ist sehr schwer dafür zu sorgen, dass die Personen dann noch in der richtigen Reihenfolge in beiden Erreys auftreten.
[00:03:22.040 --> 00:03:25.440]   Also das ist irgendwie einfach etwas sehr, sehr schwierig wäre zu machen,
[00:03:25.440 --> 00:03:30.040]   wenn Sie eben halt zwei Erreys hätten, die Sie selber managen müssten.
[00:03:30.040 --> 00:03:34.240]   Und ich meine, das ist nur ein einfaches Beispiel mit zwei Dimensionen.
[00:03:34.240 --> 00:03:39.040]   Jetzt stellen Sie sich vor, zusätzlich wollen Sie für die Personen die Adresse,
[00:03:39.040 --> 00:03:42.640]   das Semester und alles andere dazu speichern.
[00:03:42.640 --> 00:03:44.440]   Da wird das sehr, sehr schwierig.
[00:03:44.440 --> 00:03:49.440]   Und das ein ähnliches Problem hat, wenn Sie zum Beispiel mit denen eine Datei haben,
[00:03:49.440 --> 00:03:54.640]   in der Sie Informationen über Orte in der Schweiz oder irgendwo speichern.
[00:03:54.640 --> 00:03:59.440]   Und der erste Wert gibt dann wieder die Anzahl der Orte an, so wie die Anzahl der Personen.
[00:03:59.440 --> 00:04:03.040]   Und dann kämen für die Orte, die Sie interessieren,
[00:04:03.040 --> 00:04:08.040]   die Koordinaten in diesen Schweizer Landeskoordinaten, die Sie vielleicht auch mal irgendwo kennengelernt haben.
[00:04:08.040 --> 00:04:14.840]   Und das ist ein Punkt, der uns sagt, wo in der X-Y-Ebene wir diesen Ort finden würden.
[00:04:14.840 --> 00:04:17.040]   So, und jetzt sollten Sie ein Programm schreiben,
[00:04:17.040 --> 00:04:20.840]   das eben nebenan, es gäbe ein Tiefdruckgebiet, so was soll es ja geben,
[00:04:20.840 --> 00:04:24.640]   hat ein Zentrum mit gewissen Koordinaten.
[00:04:24.640 --> 00:04:29.840]   Und dann sollten Sie rausfinden, welche Orte sind innerhalb eines gewissen Radiuses,
[00:04:29.840 --> 00:04:32.240]   um diesen Ort herum entfernt.
[00:04:32.240 --> 00:04:37.440]   Auch da hätten wir das Problem, dass Sie eben halt die X-Koordinaten und die Y-Koordinaten,
[00:04:37.440 --> 00:04:41.640]   die in zwei unterschiedlichen Erreyspeichern wieder mal,
[00:04:41.640 --> 00:04:46.240]   haben es schwer, da den Bezug zu verbehalten und auch schwer dann rauszufinden,
[00:04:46.240 --> 00:04:48.840]   wer gehört mit wem zusammen.
[00:04:48.840 --> 00:04:54.240]   Also, muss ich Ihnen angucken, im ersten Fall hatten wir Daten,
[00:04:54.240 --> 00:04:58.440]   die eine Gruppe von Personen beschrieben,
[00:04:58.440 --> 00:05:02.440]   also die uns Informationen über irgendwelche Personen geben.
[00:05:02.440 --> 00:05:07.640]   Und wenn wir solche Daten speichern, dann sollten wir die vielleicht als Personenobjekte speichern,
[00:05:07.640 --> 00:05:12.840]   also nicht als ein Objekt, das Informationen über die Personen hat.
[00:05:12.840 --> 00:05:15.640]   Und im zweiten Fall, da hatten wir eine Menge von Punkten,
[00:05:15.640 --> 00:05:19.440]   also topografische Punkte oder andere Punkte,
[00:05:19.440 --> 00:05:22.240]   könnte es brauchen, dreidimensionaler Raum sein,
[00:05:22.240 --> 00:05:25.440]   wenn wir die Höheninformation mit dazunehmen wollen.
[00:05:25.440 --> 00:05:28.440]   Und solche Informationen sollten vielleicht als Punktobjekte
[00:05:28.440 --> 00:05:34.440]   oder wenn wir verschiedene Punkte analysieren wollen als Topo-Point-Objekte,
[00:05:34.440 --> 00:05:38.440]   da brauchen wir auch Punkte in einem Raum, den wir übermodellieren.
[00:05:38.440 --> 00:05:44.040]   Also, da hätten wir praktisch diese Informationen für einen Punkt zusammen in einem Objekt.
[00:05:44.040 --> 00:05:48.040]   Oder wir hätten die Informationen für eine Person in einem Objekt.
[00:05:48.040 --> 00:05:55.040]   Also, die Idee wäre, dass jedes Objekt eben halt diese Information für einen Punkt
[00:05:55.040 --> 00:06:00.640]   oder für eine Person oder was immer uns interessiert eben zusammenbündeln würde.
[00:06:00.640 --> 00:06:04.640]   Also, so ein Personenobjekt würde dann eben das Gewicht der Personen,
[00:06:04.640 --> 00:06:08.640]   die Größe der Personen, wenn das jetzt hier relevant ist, speichern.
[00:06:08.640 --> 00:06:10.640]   Und das hätte viele Vorteile für uns.
[00:06:10.640 --> 00:06:14.040]   Weil jetzt könnten wir uns überlegen, wie wir Personen vergleichen.
[00:06:14.040 --> 00:06:17.640]   Wir könnten sie einmal vergleichen nach der Größe,
[00:06:17.640 --> 00:06:21.640]   könnten wir sagen, jetzt suche die Größe oder die Keinseperson,
[00:06:21.640 --> 00:06:24.640]   oder wir könnten sie vergleichen nach Gewicht.
[00:06:24.640 --> 00:06:27.040]   Wenn ich da irgendeinen Team zusammenstelle,
[00:06:27.040 --> 00:06:30.640]   dann gibt es da Regeln, wie schwer das sein darf oder nicht.
[00:06:30.640 --> 00:06:34.040]   Oder ich könnte, wenn ich das wollte, die Größe,
[00:06:34.040 --> 00:06:37.040]   die ich ursprünglich in Zentimetern erfahren bekommen habe,
[00:06:37.040 --> 00:06:41.040]   in eine andere Messeinheit zwischen Zoll, diese Inch ist da,
[00:06:41.040 --> 00:06:43.040]   könnten wir die umrechnen.
[00:06:43.040 --> 00:06:48.040]   Oder irgendeine andere, oder von Zentimeter in Millimeter, oder was auch immer.
[00:06:48.040 --> 00:06:50.040]   Das alles könnten wir machen.
[00:06:50.040 --> 00:06:52.040]   Und das wäre so vielleicht machbar,
[00:06:52.040 --> 00:06:55.040]   dass der Rest der Welt davon gar nicht so viel mitbekommen muss,
[00:06:55.040 --> 00:06:58.840]   sondern nur die Teile des Systems, die damit arbeiten,
[00:06:58.840 --> 00:07:00.840]   die wären davon betroffen.
[00:07:00.840 --> 00:07:03.840]   Wenn ich jetzt diese Topografie-Pointe hätte,
[00:07:03.840 --> 00:07:07.840]   da hätte ich dann eben für jeden Ort die XY-Koordinaten
[00:07:07.840 --> 00:07:09.840]   in diesen Schweizer Landeskoordinaten.
[00:07:09.840 --> 00:07:11.840]   Und dann könnte ich, wenn ich wollte,
[00:07:11.840 --> 00:07:13.840]   vielleicht zur sich die Höhe speichern,
[00:07:13.840 --> 00:07:15.840]   oder ich könnte die Vegetation speichern,
[00:07:15.840 --> 00:07:18.840]   oder ich könnte andere Informationen speichern,
[00:07:18.840 --> 00:07:20.840]   in welcher politischen Gemeinde
[00:07:20.840 --> 00:07:22.840]   sich der Ort befindet, oder sowas.
[00:07:22.840 --> 00:07:24.840]   Und natürlich, wir könnten auch Berechnungen jetzt machen.
[00:07:24.840 --> 00:07:28.840]   Wir könnten mit dem Abstand zu einem anderen Ort berechnen.
[00:07:28.840 --> 00:07:30.840]   Für dieses einfache Beispiel,
[00:07:30.840 --> 00:07:32.840]   dass sie mit dem Tieflochgebiet hatte,
[00:07:32.840 --> 00:07:34.840]   wir das für die Möglichkeit, das zu machen.
[00:07:34.840 --> 00:07:36.840]   Oder einfach auch um Reiseplanung zu machen.
[00:07:36.840 --> 00:07:38.840]   Und das Gute, wenn wir das so machten,
[00:07:38.840 --> 00:07:40.840]   dann könnten wir vielleicht dafür sorgen,
[00:07:40.840 --> 00:07:42.840]   dass jeder dieser Punkte weiß,
[00:07:42.840 --> 00:07:46.840]   wie er auf einer Landkarte gezeichnet werden sollte.
[00:07:46.840 --> 00:07:49.840]   Also, wenn ich der Gäbs dann irgendeine Operation sagen würde, hier,
[00:07:49.840 --> 00:07:52.840]   zeichne Punkt, bitte zeichnen.
[00:07:52.840 --> 00:07:55.840]   Und dann wüsste der, wie der in irgendeiner Landkarte
[00:07:55.840 --> 00:07:57.840]   gezeichnet werden müsste.
[00:07:57.840 --> 00:07:59.840]   Was für Schafur, oder was für Farbe,
[00:07:59.840 --> 00:08:02.840]   oder was auch immer da genommen werden müsste.
[00:08:02.840 --> 00:08:05.840]   Also, wenn wir diesen Ansatz wählen,
[00:08:05.840 --> 00:08:08.840]   dass wir diese Informationen für jede Person,
[00:08:08.840 --> 00:08:11.840]   oder jeden Punkt, in einer zusammen abspeichern,
[00:08:11.840 --> 00:08:13.840]   dann können wir damit arbeiten.
[00:08:13.840 --> 00:08:15.840]   Und die Programme, die damit arbeiten,
[00:08:15.840 --> 00:08:17.840]   die könnten einfacher und kürzer werden.
[00:08:17.840 --> 00:08:19.840]   Warum? Die müssten jetzt sich nicht immer überlegen,
[00:08:19.840 --> 00:08:21.840]   halt, das ist dieser Array.
[00:08:21.840 --> 00:08:24.840]   Und in diesem Array ist es diese Position.
[00:08:24.840 --> 00:08:26.840]   Und wenn ich jetzt das hier ändere,
[00:08:26.840 --> 00:08:28.840]   muss ich auch im anderen Array was machen.
[00:08:28.840 --> 00:08:30.840]   Und ich kann einfach mit diesem Personenobjekt,
[00:08:30.840 --> 00:08:32.840]   oder mit diesem Punktobjekt arbeiten.
[00:08:32.840 --> 00:08:35.840]   Natürlich, der Unterschied zwischen Personen und Punkten
[00:08:35.840 --> 00:08:37.840]   ist auch gegeben.
[00:08:37.840 --> 00:08:39.840]   Das heißt, wir werden dann sehen,
[00:08:39.840 --> 00:08:41.840]   dass wir vielleicht die eine Art von Objekten
[00:08:41.840 --> 00:08:43.840]   anders konstruieren müssen.
[00:08:43.840 --> 00:08:46.840]   Die Topografiepunkte werden sich wahrscheinlich nicht sehr ändern.
[00:08:46.840 --> 00:08:49.840]   Die anderen Punkte haben vielleicht andere.
[00:08:49.840 --> 00:08:52.840]   Die Personenpunkte, da sind vielleicht Änderungen möglich.
[00:08:52.840 --> 00:08:54.840]   Aber das ist ein separates Problem,
[00:08:54.840 --> 00:08:56.840]   das eigentlich mehr die Anwender interessiert.
[00:08:56.840 --> 00:08:59.840]   Uns von der Informatikprogrammieseite interessiert
[00:08:59.840 --> 00:09:02.840]   mehr, was diese beiden Probleme zusammen haben.
[00:09:02.840 --> 00:09:05.840]   Nämlich, dass sie eben halt die Information
[00:09:05.840 --> 00:09:08.840]   für eine Person, einen Gegenstand,
[00:09:08.840 --> 00:09:10.840]   einen Ort, ein Konzept,
[00:09:10.840 --> 00:09:13.840]   irgendetwas zusammenspeichern.
[00:09:13.840 --> 00:09:16.840]   Und dafür gibt es eben halt den Java,
[00:09:16.840 --> 00:09:18.840]   diesen Class-Konstrukt.
[00:09:18.840 --> 00:09:20.840]   Den haben wir schon einmal kennengelernt,
[00:09:20.840 --> 00:09:23.840]   um diesen namenlosen Service implementieren zu können.
[00:09:23.840 --> 00:09:26.840]   Wo wir dann eben halt diese Methode Main hatten.
[00:09:26.840 --> 00:09:29.840]   Und die Methode Main hat für uns die Arbeit erledigt.
[00:09:29.840 --> 00:09:31.840]   Das war dann das Programm.
[00:09:31.840 --> 00:09:33.840]   Aber jetzt wollen wir weitergehen
[00:09:33.840 --> 00:09:35.840]   und wollen eben auch sehen,
[00:09:35.840 --> 00:09:37.840]   dass wir damit was anderes machen können.
[00:09:37.840 --> 00:09:39.840]   Wir können nämlich mit diesem Class-Konstrukt
[00:09:39.840 --> 00:09:41.840]   eine neue Art oder einen neuen Typ, sagen wir genauer,
[00:09:41.840 --> 00:09:44.840]   die die Klassengebiete der Projekte beschreiben.
[00:09:44.840 --> 00:09:47.840]   Und bisher haben wir nur Objekte genommen,
[00:09:47.840 --> 00:09:50.840]   die bereits von anderen vorbeschrieben worden waren.
[00:09:50.840 --> 00:09:52.840]   Diese eben die Klassengendungen Scanner.
[00:09:52.840 --> 00:09:55.840]   Aber die mussten ja auch mal irgendwann erstellt werden.
[00:09:55.840 --> 00:09:57.840]   Anfang waren die ja auch was Neues.
[00:09:57.840 --> 00:10:00.840]   Und eben damals hatten wir dieses Rendum-Objekt,
[00:10:00.840 --> 00:10:02.840]   das eben Zuverzahlen generierte
[00:10:02.840 --> 00:10:04.840]   oder der Scanner der Werte abliefert.
[00:10:04.840 --> 00:10:07.840]   Diese Klassengendungen waren eben uns gegeben.
[00:10:07.840 --> 00:10:10.840]   Und jetzt wollen wir eben da selber weiter machen
[00:10:10.840 --> 00:10:13.840]   und selber Klassen überlegen, die sowas machen können.
[00:10:13.840 --> 00:10:16.840]   Und was wir jetzt benutzen mit diesem Ausdruck-Objekt,
[00:10:16.840 --> 00:10:18.840]   um ein Gebilde zu bezeichnen,
[00:10:18.840 --> 00:10:21.840]   das einen Zustand hat, also einen State,
[00:10:21.840 --> 00:10:23.840]   und das auch Verhalten hat.
[00:10:23.840 --> 00:10:26.840]   Und dieser Class-Konstrukt wird uns erlauben,
[00:10:26.840 --> 00:10:30.840]   das den Zustand mit dem Verhalten zu verbinden.
[00:10:30.840 --> 00:10:32.840]   Also das Verhalten auszudrücken,
[00:10:32.840 --> 00:10:34.840]   vielleicht den Abhängigkeit vom Zustand
[00:10:34.840 --> 00:10:38.840]   oder den Zustand auszudrücken,
[00:10:38.840 --> 00:10:40.840]   das ist abhängig davon,
[00:10:40.840 --> 00:10:43.840]   was für verschiedene Operationen da gemacht worden waren.
[00:10:43.840 --> 00:10:46.840]   Und dann konnte eben dieses Objekt Services zur Verfügung stellen.
[00:10:46.840 --> 00:10:48.840]   Bei dem Scanner hatten wir gesehen,
[00:10:48.840 --> 00:10:50.840]   der hatte Next-Int zur Verfügung gestellt.
[00:10:50.840 --> 00:10:54.840]   Der Zuverzahlen-Generator hatte auch ein Next-Int zur Verfügung gestellt.
[00:10:54.840 --> 00:10:56.840]   Das war eine gute Wahl, ja.
[00:10:56.840 --> 00:11:02.840]   Okay, also wir wollen also hier Zustand
[00:11:02.840 --> 00:11:05.840]   und Verhalten miteinander verbinden.
[00:11:05.840 --> 00:11:07.840]   Und dann gibt es dann eben diese Objekte,
[00:11:07.840 --> 00:11:09.840]   geben dann uns eben Services.
[00:11:09.840 --> 00:11:14.840]   Und da im Fall von Rendem und Scanner war halt zuvergeweise,
[00:11:14.840 --> 00:11:16.840]   oder war bewusst der Name so gewählt,
[00:11:16.840 --> 00:11:18.840]   dass der Name der gleiche ist.
[00:11:18.840 --> 00:11:20.840]   Aber das muss nicht sein,
[00:11:20.840 --> 00:11:22.840]   das ist uns völlig frei überlassen,
[00:11:22.840 --> 00:11:24.840]   was wir da machen wollen.
[00:11:24.840 --> 00:11:26.840]   Also und das ist so die Grundlage
[00:11:26.840 --> 00:11:31.840]   oder eine der Hauptideen des objektorientierten Programmierens.
[00:11:31.840 --> 00:11:33.840]   Das ist ein Programmmodell,
[00:11:33.840 --> 00:11:38.840]   das sich so ein Programm als eine Menge von Objekten organisiert.
[00:11:38.840 --> 00:11:40.840]   Also eine Menge natürlich von Objekten,
[00:11:40.840 --> 00:11:42.840]   die nicht so zusammengewirfelt sind,
[00:11:42.840 --> 00:11:44.840]   sondern eine Menge von Objekten,
[00:11:44.840 --> 00:11:46.840]   die eben miteinander was bewirken,
[00:11:46.840 --> 00:11:48.840]   also die auf einander Einwirkenden sagen wir, ja.
[00:11:48.840 --> 00:11:51.840]   Da kann das ein Objekt, was wir über andere Objekte tun
[00:11:51.840 --> 00:11:53.840]   und Informationen austauschen.
[00:11:53.840 --> 00:11:55.840]   Also ein Objekt ruft Methoden auf.
[00:11:55.840 --> 00:11:57.840]   Methoden haben wir gesagt in Services,
[00:11:57.840 --> 00:11:59.840]   die ein anderes Objekt zur Verfügung stellt.
[00:11:59.840 --> 00:12:03.840]   Und dann liefern diese Methoden oder diese Operationen,
[00:12:03.840 --> 00:12:05.840]   die liefern irgendwelche Werte zurück,
[00:12:05.840 --> 00:12:07.840]   die dann je nachdem, was wir machen,
[00:12:07.840 --> 00:12:10.840]   entweder in einem neuen Objekt gespeichert werden
[00:12:10.840 --> 00:12:12.840]   oder ein Objekt verändern.
[00:12:12.840 --> 00:12:14.840]   Und das ist das Modell,
[00:12:14.840 --> 00:12:17.840]   das wir hier im Laufe der Foliesung verwenden,
[00:12:17.840 --> 00:12:20.840]   das wird auch von vielen anderen Leuten verwendet
[00:12:20.840 --> 00:12:24.840]   und ist daher eine hoffentlich gute Investition in die Zukunft.
[00:12:24.840 --> 00:12:26.840]   Also jetzt haben wir die Idee,
[00:12:26.840 --> 00:12:28.840]   dass wir so ein Objekt erstellen wollen,
[00:12:28.840 --> 00:12:31.840]   die Zustand und Verhalten verbinden.
[00:12:31.840 --> 00:12:33.840]   Und dafür brauchen wir die Klasse.
[00:12:33.840 --> 00:12:36.840]   Die Klasse ist der Weg, wie wir beschreiben,
[00:12:36.840 --> 00:12:38.840]   wie diese Objekte aussehen.
[00:12:38.840 --> 00:12:40.840]   Sie können sich so eine Klasse vorstellen,
[00:12:40.840 --> 00:12:42.840]   also eine Mustervorlage oder eine Schablone.
[00:12:42.840 --> 00:12:45.840]   Die sagt hier, ein Objekt wollen wir haben
[00:12:45.840 --> 00:12:48.840]   und das soll diesen möglichen Zustände haben
[00:12:48.840 --> 00:12:51.840]   oder das soll diese möglichen Operationen haben.
[00:12:51.840 --> 00:12:53.840]   Und wenn wir dann ein Objekt erstellen,
[00:12:53.840 --> 00:12:56.840]   dann wird ein Objekt gemäß der Vorlage erschaffen.
[00:12:56.840 --> 00:12:58.840]   Also ein Objekt wird erstellt,
[00:12:58.840 --> 00:13:10.840]   dass dann die entsprechenden Zustände zulässt.
[00:13:10.840 --> 00:13:12.840]   Die Frage über den namenlosen Service
[00:13:12.840 --> 00:13:14.840]   ist, dass der Service nochmal,
[00:13:14.840 --> 00:13:16.840]   das haben wir letzte Folie an sich behandelt,
[00:13:16.840 --> 00:13:18.840]   dass wir, wenn wir eine Klasse haben,
[00:13:18.840 --> 00:13:20.840]   wo wir die Main-Methode benutzen,
[00:13:20.840 --> 00:13:22.840]   um auszudrücken, was wir machen wollen,
[00:13:22.840 --> 00:13:24.840]   dass es sich dem Service keinen Namen geben ist.
[00:13:24.840 --> 00:13:26.840]   Es ist der Name des Programms.
[00:13:26.840 --> 00:13:28.840]   Und das Programm macht dann was.
[00:13:28.840 --> 00:13:30.840]   Und deswegen ist das namenlos.
[00:13:30.840 --> 00:13:33.840]   Aber eben, wir wollen natürlich darauf hinarbeiten,
[00:13:33.840 --> 00:13:36.840]   dass wir irgendwann verschiedene Services anbieten können.
[00:13:36.840 --> 00:13:39.840]   Und wenn wir hier verschiedene Services anbieten können,
[00:13:39.840 --> 00:13:41.840]   dann müssen wir einen Weg finden,
[00:13:41.840 --> 00:13:44.840]   zwischen diesen Services unterscheiden zu können.
[00:13:44.840 --> 00:13:46.840]   Und daher diese ...
[00:13:46.840 --> 00:13:50.840]   Also, die Klassen beschreiben die Form
[00:13:50.840 --> 00:13:52.840]   oder die Funktionalität von Objekten.
[00:13:52.840 --> 00:13:55.840]   Das heißt, die sagen, was für Zustände die haben können,
[00:13:55.840 --> 00:13:58.840]   die sagen, was für Operationen möglich sind,
[00:13:58.840 --> 00:14:01.840]   die sagen auch vielleicht, was für Fehler auftreten können und so weiter.
[00:14:01.840 --> 00:14:03.840]   Und jetzt habe ich also die Klasse, die das beschreibt.
[00:14:03.840 --> 00:14:06.840]   Und dann sprechen wir von den einzelnen Objekten,
[00:14:06.840 --> 00:14:10.840]   entweder von Objektexemplaren oder einfach Exemplaren.
[00:14:10.840 --> 00:14:13.840]   Im Englischen heißt das Instances.
[00:14:13.840 --> 00:14:17.840]   Aber das deutsche Wort Instanz heißt was ganz anderes.
[00:14:17.840 --> 00:14:19.840]   Deswegen sollten Sie das Wort eigentlich nicht verwenden,
[00:14:19.840 --> 00:14:21.840]   weil das eigentlich irreführend ist.
[00:14:21.840 --> 00:14:23.840]   Wenn wir von einzelnen Objekten sprechen,
[00:14:23.840 --> 00:14:26.840]   sprechen wir von Exemplaren oder Objektexemplaren
[00:14:26.840 --> 00:14:28.840]   und was genau machen wollen.
[00:14:28.840 --> 00:14:32.840]   Das ist einfach unterm Erstellen der Objekte.
[00:14:32.840 --> 00:14:36.840]   Und alle Objekte, die jetzt aufgrund einer Klasse gebildet wurden,
[00:14:36.840 --> 00:14:38.840]   die bilden einen Typ.
[00:14:38.840 --> 00:14:40.840]   Die haben bestimmte Eigenschaften zusammen,
[00:14:40.840 --> 00:14:42.840]   nämlich die Eigenschaft,
[00:14:42.840 --> 00:14:44.840]   dass sie die gleichen Zustände haben können
[00:14:44.840 --> 00:14:47.840]   und dass die gleichen Services angeboten werden
[00:14:47.840 --> 00:14:52.840]   oder dass die gleichen Operationen mit diesen Objekten gemacht werden können.
[00:14:52.840 --> 00:14:56.840]   Das ist der Ansatz, den wir hier verwenden.
[00:14:56.840 --> 00:15:00.840]   Man kann auch Objekteorientiert programmieren ohne Klassen machen.
[00:15:00.840 --> 00:15:04.840]   Es gibt ein paar Programmiersprachen, die machen das ohne Klassen.
[00:15:04.840 --> 00:15:07.840]   Aber sehr viele Programmiersprachen, die heute im Einsatz sind
[00:15:07.840 --> 00:15:11.840]   oder im verbreiteten Einsatz sind, die sind klassenbasiert.
[00:15:11.840 --> 00:15:15.840]   Und was Sie hier für über Java hören, gilt ähnlich, ähnlich,
[00:15:15.840 --> 00:15:18.840]   nicht identisch für C++ oder C#.
[00:15:18.840 --> 00:15:21.840]   Aber wir wollen eigentlich weniger die Details
[00:15:21.840 --> 00:15:24.840]   oder die Unterschiede zwischen den Programmiersprachen uns angucken.
[00:15:24.840 --> 00:15:26.840]   Das gibt es dann später mal.
[00:15:26.840 --> 00:15:28.840]   Wir wollen jetzt einfach nur sehen,
[00:15:28.840 --> 00:15:31.840]   wie wir damit eben unsere Programme etwas besser strukturieren können.
[00:15:31.840 --> 00:15:34.840]   Und darum nehmen wir als erstes Beispiel eine ganz triviale Aufgabe.
[00:15:34.840 --> 00:15:38.840]   Nämlich wir wollen eine ganz einfache Klasse programmieren,
[00:15:38.840 --> 00:15:41.840]   die wir Point nennen, die dazu da sein soll,
[00:15:41.840 --> 00:15:47.840]   XY-Koordinaten in einer zweidimensionalen Ebene festzuhalten.
[00:15:47.840 --> 00:15:54.840]   Also die XY-Koordinaten in der üblichen Ebene mit einem Nullpunkt da,
[00:15:54.840 --> 00:15:58.840]   werden wir als Basis nehmen.
[00:15:58.840 --> 00:16:01.840]   Und jeder Punkt, der jetzt hier ist,
[00:16:01.840 --> 00:16:07.840]   der kann durch irgendein Punkt-Objekt dann später repräsentiert werden.
[00:16:07.840 --> 00:16:10.840]   Das hat dann X und Y-Koordinaten.
[00:16:10.840 --> 00:16:16.840]   Und diese Koordinaten, die nennen wir die Attribute dieses Punktes.
[00:16:16.840 --> 00:16:18.840]   Das sind alles Attribute.
[00:16:18.840 --> 00:16:24.840]   Dieses Attribut ist dann eben halt die X- und Y-Koordinate,
[00:16:24.840 --> 00:16:27.840]   oder was, die wir da eben haben wollen.
[00:16:27.840 --> 00:16:30.840]   Und dann wird es irgendwelche Operationen geben,
[00:16:30.840 --> 00:16:32.840]   die wir mit diesem Punkt machen können.
[00:16:32.840 --> 00:16:34.840]   Wir können zum Beispiel damit überlegen,
[00:16:34.840 --> 00:16:42.840]   dass wir den Abstand, den gerade Abstand zum Nullpunkt,
[00:16:42.840 --> 00:16:44.840]   kann ich den gleich berechnen.
[00:16:44.840 --> 00:16:49.840]   So wäre also eine Art von möglichen Verhalten,
[00:16:49.840 --> 00:16:53.840]   dass wir vielleicht für diese Objekte zur Verfügung stellen wollen.
[00:16:53.840 --> 00:17:00.840]   Also jetzt brauche ich diese Punktobjekte,
[00:17:00.840 --> 00:17:03.840]   und die können natürlich dann von anderen Programmen verwendet werden.
[00:17:03.840 --> 00:17:06.840]   Also unsere Punktobjekte selber geben uns nur die Punkte.
[00:17:06.840 --> 00:17:08.840]   Aber ein Programm, das jetzt eben damit arbeitet,
[00:17:08.840 --> 00:17:12.840]   meinetwegen die Fläche eines Recht-X berechnet oder so,
[00:17:12.840 --> 00:17:16.840]   das würde mit den Punktobjekten arbeiten und müsste etwas mehr machen.
[00:17:16.840 --> 00:17:21.840]   Und diese anderen Programme sind natürlich auch wieder durch Klassen beschrieben.
[00:17:21.840 --> 00:17:23.840]   Und da gucken wir uns die nachher mal an,
[00:17:23.840 --> 00:17:28.840]   aber jetzt gucken wir erst mal an, wie diese Punktobjekte genauer definiert werden müssen.
[00:17:28.840 --> 00:17:33.840]   So, und all die Klassen, die mit diesen Punktobjekten arbeiten,
[00:17:33.840 --> 00:17:38.840]   die nennen wir die Klienten der Punktklasse.
[00:17:38.840 --> 00:17:41.840]   Das werden wir nachher noch mal genauer gucken, was genau das heißt.
[00:17:41.840 --> 00:17:45.840]   Aber das ist ein Weg für uns, einfach zusammenfassend zu sagen,
[00:17:45.840 --> 00:17:50.840]   alle Klassen oder alle Programme, die mit diesen Punktobjekten arbeiten.
[00:17:50.840 --> 00:17:52.840]   Das sind die Klienten.
[00:17:52.840 --> 00:17:56.840]   Und dann werden wir vielleicht nächste Woche sehen,
[00:17:56.840 --> 00:17:59.840]   wie eine Klasse ihr eigener Klient sein kann.
[00:17:59.840 --> 00:18:01.840]   Das ist eine interessante Art von Klassen,
[00:18:01.840 --> 00:18:04.840]   indem ihr in einer Klasse selber ihr eigener Klient sein kann.
[00:18:04.840 --> 00:18:08.840]   Und das wird dann eine Vorbereitung auf etwas interessanter Datenstrukturen sein.
[00:18:08.840 --> 00:18:13.840]   So, okay, also, Sie haben mal diese Punktobjekte.
[00:18:13.840 --> 00:18:17.840]   Und um mit denen zu arbeiten, da braucht man natürlich wieder eine Variable.
[00:18:17.840 --> 00:18:20.840]   Wir können ja nicht auf das Objekt selber zugreifen.
[00:18:20.840 --> 00:18:22.840]   Wir müssen irgendwie eine Variable haben.
[00:18:22.840 --> 00:18:24.840]   Und das muss natürlich eine Referenzvariable sein,
[00:18:24.840 --> 00:18:28.840]   weil Referenzvariablen können sich auf Objekte beziehen.
[00:18:28.840 --> 00:18:30.840]   Das hatten wir auch bei den Erreys so gesehen.
[00:18:30.840 --> 00:18:34.840]   Und natürlich gilt für die Variablen alles, was wir auch sonst gelernt haben,
[00:18:34.840 --> 00:18:39.840]   die muss deklariert sein, bevor wir das erste Mal mit ihr arbeiten können.
[00:18:39.840 --> 00:18:45.840]   Und natürlich diese Variablen, die sind an den Typ Point gebunden.
[00:18:45.840 --> 00:18:49.840]   Das heißt, die können nur auf Pointobjekte verweisen.
[00:18:49.840 --> 00:18:52.840]   Die können nicht auf beliebige Objekte verweisen.
[00:18:52.840 --> 00:18:55.840]   Genauso wie bei den Erre-Refahrensvariablen,
[00:18:55.840 --> 00:18:59.840]   eben hatten Erreys, die mit Int Elementen gefüllt sind.
[00:18:59.840 --> 00:19:01.840]   Oder Erreys, die mit Strings gefüllt sind.
[00:19:01.840 --> 00:19:03.840]   Oder Erreys, die mit Doubles gefüllt sind.
[00:19:03.840 --> 00:19:06.840]   Dafür gab es unterschiedliche Referenzvariablen.
[00:19:06.840 --> 00:19:11.840]   Und die eine konnte nicht für die andere verwendet werden.
[00:19:11.840 --> 00:19:14.840]   Es gibt einen Unterschied zwischen Methoden und Funktionen.
[00:19:14.840 --> 00:19:20.840]   Wo wir jetzt hier sind, können wir diese Worte noch austauschbar verwenden.
[00:19:20.840 --> 00:19:24.840]   Also Methode, Service, Funktionen, Prozedur.
[00:19:24.840 --> 00:19:28.840]   Das sind Begriffe, die wir eigentlich ziemlich gleich verwenden.
[00:19:28.840 --> 00:19:31.840]   Später werden Sie vielleicht sehen, dass man unterscheidet zwischen Methoden,
[00:19:31.840 --> 00:19:34.840]   die was verändern und Funktionen, die nichts verändern.
[00:19:34.840 --> 00:19:37.840]   Aber für uns ist das jetzt erst mal noch ein und dasselbe.
[00:19:37.840 --> 00:19:41.840]   Also, wie würden wir so eine Referenzvariable deklarieren?
[00:19:41.840 --> 00:19:43.840]   Genauso wie wir das vorher gemacht haben.
[00:19:43.840 --> 00:19:47.840]   Wir nehmen den Typ und danach einen Namen, um diese Variable zu deklarieren.
[00:19:47.840 --> 00:19:54.840]   Also, P1 wäre eine Referenzvariable, die sich auf Points Objekte beziehen kann.
[00:19:54.840 --> 00:20:00.840]   Oder Home wäre eine Referenzvariable, die sich auch auf Point Objekte beziehen kann.
[00:20:00.840 --> 00:20:03.840]   So, also, die Deklaration macht den Namen bekannt.
[00:20:03.840 --> 00:20:06.840]   Aber die Deklaration macht halt nur den Namen bekannt.
[00:20:06.840 --> 00:20:12.840]   Da gibt es noch kein Objekt, genauso wie wir eine Array-Referenzvariable deklariert haben.
[00:20:12.840 --> 00:20:15.840]   Da gab es ja auch eben nicht sofort einen Array.
[00:20:15.840 --> 00:20:17.840]   Das ist ja nicht so schwer.
[00:20:17.840 --> 00:20:19.840]   Wenn wir eben mit einem Exemplar arbeiten wollen,
[00:20:19.840 --> 00:20:22.840]   dann müssen wir das Exemplar erst einmal erschaffen oder erstellen.
[00:20:22.840 --> 00:20:25.840]   Und dafür brauchen wir eben wieder den New-Operator.
[00:20:25.840 --> 00:20:31.840]   Also, hier habe ich den Point P1 und den lasse ich jetzt gleich auf einen neuen Point verweisen,
[00:20:31.840 --> 00:20:35.840]   den ich hier mittels des New-Operators erstellt habe.
[00:20:35.840 --> 00:20:42.840]   Oder ich gehe hierhin und weise später dieser einmal deklarierten Variable,
[00:20:42.840 --> 00:20:46.840]   um eine neue Referenz zu.
[00:20:46.840 --> 00:20:48.840]   Das war genauso wie mit den Arrays.
[00:20:48.840 --> 00:20:55.840]   Wir hatten einen Array, entweder sofort initialis- hatten die Array die Referenzvariable sofort initialisiert
[00:20:55.840 --> 00:20:59.840]   und ließen sie auf diesen Array mit zehn Elementen verweisen.
[00:20:59.840 --> 00:21:05.840]   Oder aber wir deklarierten die Variable und machten dann später eine Zuweisung,
[00:21:05.840 --> 00:21:08.840]   um sie auf einen konkreten Array verweisen zu lassen.
[00:21:08.840 --> 00:21:11.840]   Das ist mit diesen Point Objekten nicht anders.
[00:21:11.840 --> 00:21:13.840]   Das geht genauso.
[00:21:13.840 --> 00:21:18.840]   Okay, also was wir so als Erstes festhalten sollten,
[00:21:18.840 --> 00:21:22.840]   Zustand plus Operationen ergibt einen Typ.
[00:21:22.840 --> 00:21:25.840]   Und der Datentyp beschreibt dann oder Typ beschreibt,
[00:21:25.840 --> 00:21:29.840]   welche Operationen zulässig sind und welche Werte zulässig sind.
[00:21:29.840 --> 00:21:33.840]   Oft machen wir das nicht so, machen wir das so, dass wir sagen,
[00:21:33.840 --> 00:21:36.840]   hier diese Art von Werten kann da sein.
[00:21:36.840 --> 00:21:38.840]   Wir schränken das nicht weiter ein.
[00:21:38.840 --> 00:21:42.840]   Wenn wir so eine X-Y-Koordinaten haben, dann werden wir einfach vielleicht zulassen,
[00:21:42.840 --> 00:21:47.840]   dass jeder mögliche X- und jede mögliche Y-Koordinate zulässig ist.
[00:21:47.840 --> 00:21:51.840]   Machen also keine Aussage über die Größe der Fläche.
[00:21:51.840 --> 00:21:55.840]   Das könnte man auch machen, aber machen wir im Allgemeinen nicht.
[00:21:55.840 --> 00:22:02.840]   Wir sagen einfach halt, zulässige Werte sind alle X- oder Y-Koordinaten, die hier möglich sind.
[00:22:02.840 --> 00:22:07.840]   Und wie bei den Arrays, wenn ich also eine Referenzvariable habe,
[00:22:07.840 --> 00:22:10.840]   kann ich mit der Referenzvariable eben arbeiten.
[00:22:10.840 --> 00:22:16.840]   Dann kann ich mit dieser Referenzvariable die Punkte entweder mir angucken oder verändern
[00:22:16.840 --> 00:22:21.840]   oder als Argument einer Methode übergeben.
[00:22:21.840 --> 00:22:25.840]   Da kann ich alles mitmachen, was ich will, genauso wie mit den Arrays.
[00:22:25.840 --> 00:22:27.840]   Ich kann mit denen arbeiten.
[00:22:27.840 --> 00:22:33.840]   Also, diese Punktobjekte, was für Zustände wollen wir jetzt da konkret haben.
[00:22:33.840 --> 00:22:41.840]   Und ich sagte, so ein Punktobjekt kann jeden Punkt in der zweidimensionalen Ebene annehmen.
[00:22:41.840 --> 00:22:44.840]   Das heißt, wir müssen uns erstmal überlegen, wie wollen wir die nennen.
[00:22:44.840 --> 00:22:48.840]   Und da bieten sich natürlich X und Y als Namen an.
[00:22:48.840 --> 00:22:54.840]   Und das müssen wir festhalten, was sollen denn diese Attribute sein?
[00:22:54.840 --> 00:22:59.840]   Diese Attribute sollen eben sein, die X-Koordinate oder Y-Koordinate.
[00:22:59.840 --> 00:23:04.840]   Und wenn ich so was mit den Points haben will, dann muss jetzt eben das System dafür sorgen,
[00:23:04.840 --> 00:23:11.840]   dass dieses Objekt, wenn es gespeichert wird, eben Platz für diese Attribute hat
[00:23:11.840 --> 00:23:14.840]   und was sonst alles noch dazukommt.
[00:23:14.840 --> 00:23:16.840]   Und das lässt sich als Aufgabe der Klasse.
[00:23:16.840 --> 00:23:20.840]   In der Klasse werden wir sagen können, nicht heute, aber im Laufe der Woche,
[00:23:20.840 --> 00:23:25.840]   die nächsten Woche, welche dieser Attribute vielleicht für jeden zugänglich sind,
[00:23:25.840 --> 00:23:28.840]   welche der Attribute geändert werden können.
[00:23:28.840 --> 00:23:31.840]   Jetzt am Anfang machen wir es ganz einfach.
[00:23:31.840 --> 00:23:33.840]   Wir haben eine Referenzvariable.
[00:23:33.840 --> 00:23:38.840]   Und mit dieser Referenzvariable können wir hier uns auf ein konkretes Pointobjekt beziehen.
[00:23:38.840 --> 00:23:40.840]   Und dann können wir damit arbeiten.
[00:23:40.840 --> 00:23:43.840]   So, jetzt müsst ihr natürlich irgendein Weg finden,
[00:23:43.840 --> 00:23:48.840]   dass diese Pointobjekte auf konkrete Punkte sich verweisen zu lassen.
[00:23:48.840 --> 00:23:53.840]   Da muss es irgendein Weg geben, vielleicht mit einer Methode oder was anderem,
[00:23:53.840 --> 00:23:58.840]   die diesen Pointobjekten Werte gibt, damit wir eben damit arbeiten können.
[00:23:58.840 --> 00:24:03.840]   Und dann können die Operationen damit eben weiterarbeiten.
[00:24:03.840 --> 00:24:09.840]   Und wenn wir uns diese, angucken, wenn wir so ein Pointobjekt erstellen,
[00:24:09.840 --> 00:24:13.840]   dann kommt das ja eigentlich nicht ganz ohne irgendeinen Zustand raus.
[00:24:13.840 --> 00:24:15.840]   Das muss ja einen legalen Zustand haben,
[00:24:15.840 --> 00:24:19.840]   weil das war ja eine unserer Aussagen über Objekte.
[00:24:19.840 --> 00:24:25.840]   Das heißt, irgendwelche Werte werden da von dem New-Operator bereits vorinstalliert.
[00:24:25.840 --> 00:24:31.840]   Und das werden wir sehen im Laufe der Zeit, wie wir das genauer kontrollieren können.
[00:24:31.840 --> 00:24:35.840]   Jetzt für Punkte wäre zum Beispiel der Origin,
[00:24:35.840 --> 00:24:42.840]   denn Nullpunkt, ein guter Wert, mit dem wir Punkte initialisieren können.
[00:24:42.840 --> 00:24:45.840]   Also, das müssen wir überlegen, was sollte denn so der Punkt,
[00:24:45.840 --> 00:24:52.840]   der von dem New-Konstaktor gebaut wird, der von dem New-Operator erstellt wird,
[00:24:52.840 --> 00:24:56.840]   was soll der denn überhaupt für Werte haben?
[00:24:56.840 --> 00:25:00.840]   Und dann natürlich wollen wir auch irgendwelches Verhalten haben,
[00:25:00.840 --> 00:25:04.840]   das also beschreibt, was mit diesen Objekten gemacht werden kann.
[00:25:04.840 --> 00:25:08.840]   Und eben, da wird es wahrscheinlich irgendeine Operation geben,
[00:25:08.840 --> 00:25:11.840]   mit der wir die Koordinaten setzen können.
[00:25:11.840 --> 00:25:14.840]   Vielleicht können wir den Punkt auch verschieben.
[00:25:14.840 --> 00:25:17.840]   Vielleicht wollen wir den Abstand zum Nullpunkt haben.
[00:25:17.840 --> 00:25:20.840]   Und ja, wenn das vielleicht ein Topografiepunkt ist,
[00:25:20.840 --> 00:25:25.840]   dann wollen wir irgendeinen Weg haben, den zu zeichnen oder sonst irgendwie klarzumachen.
[00:25:25.840 --> 00:25:31.840]   Also, wenn Sie sehen, diese Topografiepunkte sind ähnlich den Punkten.
[00:25:31.840 --> 00:25:35.840]   Aber wenn wir jetzt einen Topografiepunkt erstellen wollten,
[00:25:35.840 --> 00:25:41.840]   dann sollte der wahrscheinlich für die Schweiz nicht Null als Ursprung oder als Origin haben.
[00:25:41.840 --> 00:25:45.840]   Weil in der Schweiz sind die Werte innerhalb eines gewissen Bereichs.
[00:25:45.840 --> 00:25:51.840]   Und wenn Sie sich noch erinnern, in der Schweiz, der Ursprungspunkt da,
[00:25:51.840 --> 00:25:54.840]   der ist ein ausgewählter Ort in einem anderen Kanton.
[00:25:54.840 --> 00:26:00.840]   Also, irgendwie müssen wir festhalten können, was eben die Werte sein sollen,
[00:26:00.840 --> 00:26:02.840]   wenn wir so ein Objekt erstellen.
[00:26:02.840 --> 00:26:05.840]   Und dann eben natürlich wollen wir auch Operationen haben,
[00:26:05.840 --> 00:26:08.840]   die könnten jetzt sehr ähnlich den Operationen sein,
[00:26:08.840 --> 00:26:13.840]   die wir eben für die anderen 2D-Punkte für unsere Ebene hatten.
[00:26:13.840 --> 00:26:18.840]   Also, diese Information, wenn wir also in die Klasse reinstecken.
[00:26:18.840 --> 00:26:23.840]   Und das hatte ich gesagt, ist so der, das ist die Schablone oder das Muster.
[00:26:23.840 --> 00:26:30.840]   Das ist das Muster, das uns sagt, also Punkte haben hier einen X und Y-Zustand.
[00:26:30.840 --> 00:26:36.840]   Also, das beschreibt, dass X und Y-Dimensionen dieses Punkt ist.
[00:26:36.840 --> 00:26:41.840]   Und dann gibt es verschiedene Arten von verschiedenen Schritte, die da gemacht werden könnten.
[00:26:41.840 --> 00:26:43.840]   Und wenn wir jetzt verschiedene Punkte erstellt wurden,
[00:26:43.840 --> 00:26:48.840]   dann können die irgendwelche unterschiedliche Werte für X und Y haben.
[00:26:48.840 --> 00:26:55.840]   Der eine Punkt hat hier X-18 und Y-42 und der andere hat X-5 und Y-2.
[00:26:55.840 --> 00:26:59.840]   Das sind zwei unterschiedliche Punkte, die sich in ihren Zuständen unterscheiden,
[00:26:59.840 --> 00:27:01.840]   aber die Zustände sind immer noch ähnlich.
[00:27:01.840 --> 00:27:07.840]   Und die haben dann eben halt alle, weil es alles von derselben Schablone hergestellt wurden,
[00:27:07.840 --> 00:27:13.840]   haben dasselbe Verhalten dieselben Operationen, die damit gemacht werden können.
[00:27:13.840 --> 00:27:19.840]   Also, die Klasse erlaubt es uns eben so, ein Gebilde zu konstruieren.
[00:27:19.840 --> 00:27:20.840]   Das ist die Vorlage.
[00:27:20.840 --> 00:27:26.840]   Und dann wird, wenn wir das Objekt brauchen, wird ein Objekt gemäß dieser Vorlage erstellt.
[00:27:26.840 --> 00:27:35.840]   Also, müssen Sie das so vorstellen, wenn die Klasse jetzt eben das Objekt herstellen muss,
[00:27:35.840 --> 00:27:39.840]   dann wird das Objekt eben nach dieser Vorlage erschaffen.
[00:27:39.840 --> 00:27:42.840]   Das werden wir auch mal genauer angucken.
[00:27:42.840 --> 00:27:48.840]   Und dann wird das System dafür sorgen, dass die Operationen, die wir machen wollen, möglich sind.
[00:27:48.840 --> 00:27:51.840]   Und das wird dadurch erfeilen, dass es eben für diese Operationen,
[00:27:51.840 --> 00:27:53.840]   die wir ausführen wollen, Methoden gibt.
[00:27:53.840 --> 00:27:59.840]   Und wir hatten gesagt, dass alle Objekte, die wir erstellen, haben einen Zustand.
[00:27:59.840 --> 00:28:02.840]   Sie sehen sie, ist das noch da unten sichtbar.
[00:28:02.840 --> 00:28:03.840]   Ja, Zustand.
[00:28:03.840 --> 00:28:06.840]   Und diesen Zustand, das nennen wir die Attribute.
[00:28:06.840 --> 00:28:10.840]   Das sind die Attribute, die dieses Objekt beschreiben.
[00:28:10.840 --> 00:28:15.840]   Also, im Fall der einfachen Punkte, wären das eben die x, y Koordinaten.
[00:28:15.840 --> 00:28:21.840]   Und im Fall eines Personenobjekts wären das vielleicht der Name und die Größe
[00:28:21.840 --> 00:28:24.840]   oder irgendwelche anderen Aspekte, die uns interessieren.
[00:28:24.840 --> 00:28:31.840]   Also, Klasse ist dafür da, diese Gemeinsamkeiten zu beschreiben und das zu erstellen.
[00:28:31.840 --> 00:28:37.840]   Und damit kommen wir jetzt zu den ersten beiden Teilen, die diese Klasse da beschreiben,
[00:28:37.840 --> 00:28:40.840]   die Attribute und die Methoden.
[00:28:40.840 --> 00:28:49.840]   Also, hatte gesagt, wir wollten für jedes Objekt zwei Aspekte festhalten,
[00:28:49.840 --> 00:28:51.840]   nämlich die x und die y Koordinaten.
[00:28:51.840 --> 00:28:54.840]   Denn die bestimmen den Zustand des Exemplars.
[00:28:54.840 --> 00:28:58.840]   Das heißt, diese Daten müssen halt irgendwo gespeichert werden.
[00:28:58.840 --> 00:29:02.840]   Und das sind die Attribute, die eben Teil des Zustandes sind.
[00:29:02.840 --> 00:29:05.840]   Das ist vielleicht noch mehr vom System unterhalten, das wir nicht wissen.
[00:29:05.840 --> 00:29:12.840]   Aber das sind die Zustände, die das Programm als richtig oder wichtig herausgehoben hat.
[00:29:12.840 --> 00:29:15.840]   Und darum muss unser System in der Lage sein, diese zu speichern.
[00:29:15.840 --> 00:29:20.840]   Und es ist interessant oder wichtig zu sehen, dieses Attribut wird in der Klassenbeschreibung
[00:29:20.840 --> 00:29:23.840]   einmal für alle Objekte deklariert.
[00:29:23.840 --> 00:29:29.840]   Also, wir sagen, jedes Objekt, das nach dieser Klasse deklariert wird,
[00:29:29.840 --> 00:29:37.840]   das soll eben ein x Koordinat und eine y Koordinat speichern, was da einmal deklariert wurde.
[00:29:37.840 --> 00:29:41.840]   Aber dann, wenn wir einzelne Objekte erstellen oder Objektexemplare erstellen,
[00:29:41.840 --> 00:29:48.840]   dann werden die Attribute für jedes einzelne Objektexemplar separat gespeichert.
[00:29:48.840 --> 00:29:52.840]   Also, die Operationen haben die alle gemeinsam,
[00:29:52.840 --> 00:29:56.840]   aber die werden trotzdem die Information, die mit dem Objekt zusammengehört,
[00:29:56.840 --> 00:29:59.840]   wird für dieses Objekt gespeichert.
[00:29:59.840 --> 00:30:01.840]   Also, Attribut wird gespeichert.
[00:30:01.840 --> 00:30:05.840]   Und wir werden auch später sehen, dass zumindest im Prinzip die Operation
[00:30:05.840 --> 00:30:09.840]   auch für die an dieses Objekt gebunden ist.
[00:30:09.840 --> 00:30:17.840]   Das ist der Grund, warum wir dann in der Lage sind, so flexibel mit diesen Sachen zu arbeiten.
[00:30:17.840 --> 00:30:24.840]   Also, unsere Klasse, wir würden eigentlich das Keyword "Klar" verwenden,
[00:30:24.840 --> 00:30:29.840]   um so eine Klasse zu deklarieren.
[00:30:29.840 --> 00:30:35.840]   Also, diese Gruppe von Pointobjekten wird durch diese Klassendefinition beschrieben.
[00:30:35.840 --> 00:30:41.840]   Und wenn wir eben halt diese Attribute angeben, dann müssen wir den Attributen auch wieder einen Typ geben.
[00:30:41.840 --> 00:30:46.840]   Sonst weiß das System nicht, was für mögliche Zustände da erlaubt sind.
[00:30:46.840 --> 00:30:51.840]   Und wir sagen eben halt in diesem einfachen Beispiel, dass wir als Typ "ins" nehmen.
[00:30:51.840 --> 00:30:57.840]   Also, wir haben hier eine beliebige, irgendeinen Wert, der sich durch eine "int" darstellen.
[00:30:57.840 --> 00:31:00.840]   Kann man Klasse nachträglich anpassen.
[00:31:00.840 --> 00:31:02.840]   Machen wir sie erst mal.
[00:31:02.840 --> 00:31:05.840]   Und danach werden wir sehen, was wir danach ändern können.
[00:31:05.840 --> 00:31:14.840]   So, diese Code, diese Code, die ich Ihnen hier gezeigt habe, der muss in einer ganz bestimmten Datei abgelegt sein.
[00:31:14.840 --> 00:31:17.840]   Die muss nämlich den Namen Point.java haben.
[00:31:17.840 --> 00:31:20.840]   Wenn sie den Namen nicht hat, dann beschwert ihr das System.
[00:31:20.840 --> 00:31:23.840]   Das kennen Sie ja schon vom Beginn des Semesters.
[00:31:23.840 --> 00:31:26.840]   Das sind Regeln, an die wir uns halten müssen.
[00:31:26.840 --> 00:31:29.840]   Und die wir natürlich mit einem Aufwand umgehen könnten.
[00:31:29.840 --> 00:31:31.840]   Und ich empfehle Ihnen das gar nicht erst zu machen.
[00:31:31.840 --> 00:31:37.840]   Und darum, so eine Klasse würde jetzt hier in Point.java abgelegt sein.
[00:31:37.840 --> 00:31:42.840]   Also, wenn wir das gemacht haben, dann gibt es eben für unser Programm einen neuen Typ.
[00:31:42.840 --> 00:31:44.840]   Der Typ hat den Namen Point.
[00:31:44.840 --> 00:31:50.840]   Und jedes Point-Objekt oder jedes Point-Objekt-Exemplar enthält zwei Daten, zwei Attribute,
[00:31:50.840 --> 00:31:56.840]   eine ganze Zahl "int", die wir "x" nennen, und eine andere ganze Zahl, die wir "y" nennen.
[00:31:56.840 --> 00:32:01.840]   Das ist unser Point-Klasse, mit der wir arbeiten können.
[00:32:01.840 --> 00:32:03.840]   Das ist die Arbeit.
[00:32:03.840 --> 00:32:07.840]   Und jetzt haben wir, also wenn wir das so machen, haben wir diese Klasse definiert.
[00:32:07.840 --> 00:32:11.840]   Aber wir haben noch kein Verhalten definiert. Darauf komme ich dann gleich.
[00:32:11.840 --> 00:32:14.840]   Aber erst mal haben wir hier gucken, das haben wir die Klasse definiert.
[00:32:14.840 --> 00:32:20.840]   Das ist manchmal eine sinnvolle Sache, weil ich so kann ich halt immer zwei Punkte zusammenarbeiten.
[00:32:20.840 --> 00:32:27.840]   Also eben die "x" und "y", das sind eben die Attribute jedes Point-Objekt.
[00:32:27.840 --> 00:32:33.840]   Das ist das, wenn wir von der Attributen reden, die sind das, was das Objekt beschreiben.
[00:32:33.840 --> 00:32:38.840]   So, jetzt hatte ich gesagt, um darauf zuzugreifen, brauchen wir wieder eine Referenzvariable.
[00:32:38.840 --> 00:32:46.840]   Und die Referenzvariable legt den Typ des Objekts fest, auf das ich mit dieser Referenzvariable arbeiten kann.
[00:32:46.840 --> 00:32:55.840]   Also eben, wie ich vorhin schon zeigte, mit Point-P1 kann ich halt den, eine Referenzvariable deklarieren,
[00:32:55.840 --> 00:32:58.840]   die sich auf Point-Objekte beziehen kann.
[00:32:58.840 --> 00:33:03.840]   Und dann kann ich eine andere nehmen und die auf einen konkreten Point verweisen lassen.
[00:33:03.840 --> 00:33:11.840]   So, jetzt, diese Attribute sind also Variablen, die innerhalb eines Objekts,
[00:33:11.840 --> 00:33:14.840]   als Teil des Objektzustandes gespeichert sind.
[00:33:14.840 --> 00:33:17.840]   Also wichtig ist, dass Sie dieses Innerhalb verinnerlichen.
[00:33:17.840 --> 00:33:21.840]   Die Variable, also das Attribut, ist in, im Objekt.
[00:33:21.840 --> 00:33:26.840]   Das gehört, das ist sozusagen ein Objektumschlungen.
[00:33:26.840 --> 00:33:28.840]   Das Objekt ist wichtig.
[00:33:28.840 --> 00:33:31.840]   Ohne das Objekt kommen wir an diese Werte nicht heran.
[00:33:31.840 --> 00:33:37.840]   Und die werden halt deklariert im Text zwischen den geschweiften Klammern.
[00:33:37.840 --> 00:33:42.840]   Und die Sündtagsdeklaration, also die Sündtags für diese Deklaration ist genauso,
[00:33:42.840 --> 00:33:45.840]   wie wir die Variablen im Methoden deklariert hatten.
[00:33:45.840 --> 00:33:51.840]   Wir geben einen Typ an, wir geben einen Namen an, ganz einfach.
[00:33:51.840 --> 00:33:58.840]   So, mir fragt, eben fragt jemand, müssen jetzt diese Klassen innerhalb des Hauptprogramms Main sein?
[00:33:58.840 --> 00:34:00.840]   Nein, ganz und gar nicht.
[00:34:00.840 --> 00:34:05.840]   Ihr Programm besteht jetzt hier aus einer Public Class,
[00:34:05.840 --> 00:34:10.840]   nennen wir die mal Main oder nennen wir die irgendwas, MAX.
[00:34:10.840 --> 00:34:16.840]   Und dann haben Sie, dann kommt da was, und dann haben Sie hier eine andere Public Class.
[00:34:16.840 --> 00:34:20.840]   Und dann haben wir die vielleicht hier, dann haben wir die hier Pointe.
[00:34:20.840 --> 00:34:24.840]   Und sehen Sie, ich hätte gesagt, die müssen in unterschiedlichen Dateien sein.
[00:34:24.840 --> 00:34:30.840]   Der muss in der, diese Klasse muss in der Datei Max.Java sein.
[00:34:30.840 --> 00:34:35.840]   Und wenn Sie das nicht machen wollen, beschwert sich das System.
[00:34:35.840 --> 00:34:39.840]   Sie können das auch anders einstellen, aber warum wollen Sie sich das Leben schwierig machen?
[00:34:39.840 --> 00:34:42.840]   Also, so haben Sie die verschiedenen Klassen.
[00:34:42.840 --> 00:34:46.840]   Wir werden später noch sehen, dass man das auch erweitern kann.
[00:34:46.840 --> 00:34:48.840]   Dann kann auch das noch etwas komplizierter machen.
[00:34:48.840 --> 00:34:51.840]   Aber das wollen wir jetzt anfangs gar nicht machen.
[00:34:51.840 --> 00:34:56.840]   Wir haben einfach Klassen, die alle sozusagen auf der obersten Ebene sind.
[00:34:56.840 --> 00:35:01.840]   Und mit denen wir arbeiten können.
[00:35:01.840 --> 00:35:05.840]   So, also so habe ich das dann in meinem Programm.
[00:35:05.840 --> 00:35:09.840]   Also, die Attribute, das sind eben die Zustandsvariabeln.
[00:35:09.840 --> 00:35:12.840]   Und auf die, die können alles Mögliche sein.
[00:35:12.840 --> 00:35:17.840]   Die können String sein, die können Double sein, die können auch Errace sein und so weiter.
[00:35:17.840 --> 00:35:21.840]   Alles ist da ohne weiteres möglich.
[00:35:21.840 --> 00:35:25.840]   Und wenn ich jetzt mit so einem Attribut arbeiten will,
[00:35:25.840 --> 00:35:28.840]   als wenn ich das entweder lesen oder verändern will,
[00:35:28.840 --> 00:35:32.840]   das sind ja die beiden Wege, die wir kennen, um mit Variabeln zu arbeiten,
[00:35:32.840 --> 00:35:36.840]   dann muss ich eben eine Referenzvariable nehmen.
[00:35:36.840 --> 00:35:41.840]   Ich nehme die Referenzvariable und dann habe ich diesen berühmten Punkt, den haben wir ja schon mal gesehen.
[00:35:41.840 --> 00:35:44.840]   Und danach kommt das Attribut.
[00:35:44.840 --> 00:35:47.840]   So kann ich auf den das Attribut lesen.
[00:35:47.840 --> 00:35:50.840]   Oder wenn ich das Attribut setzen will, mache ich das genauso,
[00:35:50.840 --> 00:35:53.840]   nur dass ich das eben auf die linke Seite schreibe.
[00:35:53.840 --> 00:35:56.840]   Und dann habe ich hier eben eine Zuweisung.
[00:35:56.840 --> 00:35:58.840]   Das ist eine Zuweisung.
[00:35:58.840 --> 00:36:02.840]   Und dieser Value muss natürlich dem Typ entsprechen,
[00:36:02.840 --> 00:36:07.840]   den wir als Typ für diese Attribute definiert hatten.
[00:36:07.840 --> 00:36:11.840]   Wenn da ein Int verlangt ist, dann muss diese Value,
[00:36:11.840 --> 00:36:15.840]   das da berechnet wird, eben diesen Typ ergeben.
[00:36:15.840 --> 00:36:18.840]   Also, zum Beispiel, wenn wir mit diesen Punktkoordinaten arbeiten,
[00:36:18.840 --> 00:36:21.840]   haben wir hier eine Referenzvariable P1,
[00:36:21.840 --> 00:36:24.840]   die verweist auf einen Punkt, der hier konstruiert wird.
[00:36:24.840 --> 00:36:26.840]   Und dann haben wir hier P2.
[00:36:26.840 --> 00:36:29.840]   Und wenn ich jetzt kann ich hier auf das X-Attribut zugreifen,
[00:36:29.840 --> 00:36:31.840]   und dann würde das eben gedruckt werden.
[00:36:31.840 --> 00:36:36.840]   Oder ich kann hier auf das Y-Attribut des Objekts zugreifen,
[00:36:36.840 --> 00:36:41.840]   dass ich mittels P2 erreiche und das auf irgendeinen Wert setze.
[00:36:41.840 --> 00:36:47.840]   Damit kann ich also ganz normal ohne Umstände arbeiten.
[00:36:47.840 --> 00:36:52.840]   Wir werden später sehen, dass man das noch ein bisschen schwieriger machen kann,
[00:36:52.840 --> 00:36:54.840]   also dass man das genauer kontrollieren kann,
[00:36:54.840 --> 00:36:56.840]   wer was lesen darf und so weiter.
[00:36:56.840 --> 00:36:58.840]   Aber das wollen wir heute noch nicht machen.
[00:36:58.840 --> 00:37:01.840]   So, und wenn wir so eine Situation haben,
[00:37:01.840 --> 00:37:06.840]   also hier haben wir eine Referenzvariable,
[00:37:06.840 --> 00:37:09.840]   wir haben hier den Punkt und wir haben hier ein Attribut,
[00:37:09.840 --> 00:37:15.840]   dann sagen wir, dass die Referenzvariable dereferenziert wurde.
[00:37:15.840 --> 00:37:20.840]   Also wir nehmen die Referenzvariable und benutzen die jetzt,
[00:37:20.840 --> 00:37:22.840]   um ein Objekt zu finden.
[00:37:22.840 --> 00:37:27.840]   Und dann gucken wir uns hier das Attribut, dieses Objekt an,
[00:37:27.840 --> 00:37:29.840]   oder wir setzen das Attribut.
[00:37:29.840 --> 00:37:31.840]   Das nennen wir D-Referenzieren.
[00:37:31.840 --> 00:37:33.840]   Also das D weist darauf hin,
[00:37:33.840 --> 00:37:36.840]   dass wir uns für das Objekt selber interessieren,
[00:37:36.840 --> 00:37:39.840]   nicht für die Attribute des Objekts zu interessieren,
[00:37:39.840 --> 00:37:41.840]   nicht für das Objekt als Ganzes.
[00:37:41.840 --> 00:37:44.840]   Dafür würden wir ja mit den Referenzvariabeln arbeiten,
[00:37:44.840 --> 00:37:47.840]   nein, für einen Aspekt dieses Objekts,
[00:37:47.840 --> 00:37:49.840]   eben für eines der Attribute.
[00:37:49.840 --> 00:37:51.840]   Und dieser gleiche Weg,
[00:37:51.840 --> 00:37:54.840]   Referenzvariable, Punkt und Attribut,
[00:37:54.840 --> 00:37:57.840]   den können wir später auch benutzen, um Methoden aufzurufen.
[00:37:57.840 --> 00:38:00.840]   Auch da werden wir wieder eine Referenzvariable brauchen,
[00:38:00.840 --> 00:38:02.840]   wir werden den Punkt brauchen,
[00:38:02.840 --> 00:38:04.840]   und natürlich brauchen wir dann keinen Attribut,
[00:38:04.840 --> 00:38:08.840]   sondern den Namen einer Methode gegebenenfalls mit Parametern.
[00:38:08.840 --> 00:38:11.840]   Also diese Dot-Notation, die wir auch früher schon mal gesehen haben,
[00:38:11.840 --> 00:38:14.840]   das ist der Weg, wie ich auf einzelne Attribute
[00:38:14.840 --> 00:38:18.840]   dieses irgendeines Objekts zugreifen kann.
[00:38:18.840 --> 00:38:21.840]   Und Sie erinnern sich jetzt vielleicht, warum,
[00:38:21.840 --> 00:38:23.840]   jetzt wird es auch klar, warum, wenn wir,
[00:38:23.840 --> 00:38:25.840]   als wir die Länge eines Erreys wollten,
[00:38:25.840 --> 00:38:28.840]   warum das eben ohne Klammern war.
[00:38:28.840 --> 00:38:35.840]   Weil dieses Längsattribut ist ein Attribut des Erreys.
[00:38:35.840 --> 00:38:37.840]   Das ist ein Attribut,
[00:38:37.840 --> 00:38:39.840]   wenn ich hier irgendein Erreihabe,
[00:38:39.840 --> 00:38:44.840]   kann ich eben mittels dieser Notation auf die Länge zugreifen
[00:38:44.840 --> 00:38:46.840]   und die Länge mir eben anschauen.
[00:38:46.840 --> 00:38:50.840]   Und das ist jetzt ein Attribut, wo wir das lesen können,
[00:38:50.840 --> 00:38:52.840]   dass wir aber nicht ändern können.
[00:38:52.840 --> 00:38:56.840]   Es ist nicht möglich, durch die Ändern des Längenattributs
[00:38:56.840 --> 00:38:58.840]   die Länge des Erreys anzupassen.
[00:38:58.840 --> 00:39:01.840]   Das geht nicht, das unterstützt das System nicht.
[00:39:01.840 --> 00:39:05.840]   Deswegen war das eben ein Attribut,
[00:39:05.840 --> 00:39:07.840]   deswegen waren da auch keine Klammern.
[00:39:07.840 --> 00:39:09.840]   Und was wir jetzt sagen würden,
[00:39:09.840 --> 00:39:12.840]   ist, dass er die Referenzvariable "my array",
[00:39:12.840 --> 00:39:16.840]   das ist die Referenzvariable, mit der wir hier arbeiten.
[00:39:16.840 --> 00:39:21.840]   Die wurde dereferenziert, um auf das Attribut längst zuzugreifen.
[00:39:21.840 --> 00:39:24.840]   Also haben wir das damals gemacht.
[00:39:24.840 --> 00:39:31.840]   Also, die Klasse beschreibt, also die Klas,
[00:39:31.840 --> 00:39:33.840]   beschreibt, wie die Objekte aussehen sollen.
[00:39:33.840 --> 00:39:37.840]   Und wenn jetzt eben ein Objekt erstellt wird,
[00:39:37.840 --> 00:39:39.840]   dann macht der New Operator das,
[00:39:39.840 --> 00:39:43.840]   der New Operator weiß, wo die Information über die Klasse zu finden ist
[00:39:43.840 --> 00:39:46.840]   und erstellt dann ein konkretes Objekt,
[00:39:46.840 --> 00:39:49.840]   dass wir eben ein Exemplar der Klasse ist
[00:39:49.840 --> 00:39:53.840]   oder von manchen Leuten wird es auch ein Repräsentant der Klasse nennen.
[00:39:53.840 --> 00:39:57.840]   Aber ein Zugriff auf die Attribute ist nur möglich,
[00:39:57.840 --> 00:40:00.840]   wenn es eben so ein Exemplar auch gibt.
[00:40:00.840 --> 00:40:05.840]   Genauso wie bei den arrays, wir mussten einen konkreten array erstellt haben,
[00:40:05.840 --> 00:40:08.840]   auf dessen Elemente wir zugreifen konnten.
[00:40:08.840 --> 00:40:12.840]   Wenn das Sinn machen sollte, die Referenzvariable alleine,
[00:40:12.840 --> 00:40:14.840]   gab uns noch keinen array.
[00:40:14.840 --> 00:40:17.840]   Und genauso ist es hier mit Referenzvariablen,
[00:40:17.840 --> 00:40:19.840]   die für eine Klasse oder für einen den Typ,
[00:40:19.840 --> 00:40:21.840]   der durch die Klasse bestimmt wird, erstellt werden.
[00:40:21.840 --> 00:40:24.840]   Die Klasse ist nur die Vorlage.
[00:40:24.840 --> 00:40:27.840]   Die Klasse macht nichts selber.
[00:40:27.840 --> 00:40:31.840]   Deswegen können wir auch in der Klasse keine Anweisungen haben,
[00:40:31.840 --> 00:40:33.840]   außer vielleicht Initialisierung.
[00:40:33.840 --> 00:40:35.840]   Und natürlich Methoden.
[00:40:35.840 --> 00:40:38.840]   Wir werden das noch sehen, dass wir Methoden definieren können,
[00:40:38.840 --> 00:40:41.840]   die uns sagen, wie wir mit der Klasse arbeiten wollen.
[00:40:41.840 --> 00:40:45.840]   Aber sonst gibt es in einer Klasse eigentlich keine Operationen.
[00:40:45.840 --> 00:40:49.840]   Das ist einfach nicht vorgesehen.
[00:40:49.840 --> 00:40:53.840]   Und daher gibt es so was für uns jetzt einfach auch nicht.
[00:40:53.840 --> 00:40:57.840]   Also, erste Zusammenfassung.
[00:40:57.840 --> 00:41:01.840]   New liefert uns einen Verweis auf ein Exemplar,
[00:41:01.840 --> 00:41:06.840]   der dann in dieser Verweis kann eine Referenzvariable gespeichert werden.
[00:41:06.840 --> 00:41:12.840]   Und das ist halt der Weg, wie wir zu Objektortributen kommen.
[00:41:12.840 --> 00:41:17.840]   Wir gehen hin und erstellen ein Objekt mit dem New-Operator
[00:41:17.840 --> 00:41:21.840]   und greifen dann auf die einzelnen Attribute zu,
[00:41:21.840 --> 00:41:24.840]   indem wir die Referenzvariable in dieser Dot-Notation
[00:41:24.840 --> 00:41:27.840]   mit der Attribut verknüpfen.
[00:41:27.840 --> 00:41:32.840]   Und weil das Referenzvariable sind, gelten natürlich die Referenzsementics.
[00:41:32.840 --> 00:41:37.840]   Die gleichen Regeln, die wir für Errace hatten, gelten hier auch.
[00:41:37.840 --> 00:41:40.840]   Ich habe hier einen Punkt, eine Referenzvariable p1,
[00:41:40.840 --> 00:41:43.840]   die sich hier auf diesen Punkt bezieht.
[00:41:43.840 --> 00:41:47.840]   Auf diesen Punkt habe ich die x- und y-Attribute auf 3 und 2 gesetzt.
[00:41:47.840 --> 00:41:50.840]   Jetzt habe ich hier eine zweite Referenzvariable p2,
[00:41:50.840 --> 00:41:55.840]   die sich auch auf den selben Punkt bezieht, auf das selbe Objekt.
[00:41:55.840 --> 00:42:00.840]   Wenn ich jetzt hier mir das x-Attribut von p2 angucke,
[00:42:00.840 --> 00:42:02.840]   dann finde ich natürlich die 3.
[00:42:02.840 --> 00:42:05.840]   Und wenn ich mir das y-Attribut von p2 angucke,
[00:42:05.840 --> 00:42:08.840]   dann finde ich da natürlich die 2.
[00:42:08.840 --> 00:42:13.840]   Und wenn ich jetzt hingehe und das x-Attribut ändere,
[00:42:13.840 --> 00:42:17.840]   also das x-Attribut, das ich über p2 erreiche, in vier ändere,
[00:42:17.840 --> 00:42:21.840]   dann natürlich ist das x-Attribut, dass ich da sehe, 4.
[00:42:21.840 --> 00:42:23.840]   Und das y-Attribut ist unverändert.
[00:42:23.840 --> 00:42:29.840]   Aber genauso gilt, dass wenn ich jetzt das x-Attribut von p1 mir angucke,
[00:42:29.840 --> 00:42:31.840]   dass das auch 4 ist. Warum?
[00:42:31.840 --> 00:42:36.840]   Weil x, p1 und p2 beziehen sich auf das selbe Objekt.
[00:42:36.840 --> 00:42:41.840]   Wenn ich also diese Zuweisung gemacht habe, dann hat sich das geändert.
[00:42:41.840 --> 00:42:45.840]   Und danach eben auch p1, wenn ich dann das x-Attribut mir angucke,
[00:42:45.840 --> 00:42:47.840]   hat den Wert 4.
[00:42:47.840 --> 00:42:51.840]   Das ist wie seinerzeit das bei den Erreys war.
[00:42:51.840 --> 00:42:54.840]   Und wenn wir jetzt nicht mehr auf dieses,
[00:42:54.840 --> 00:42:59.840]   wenn wir jetzt wollen, dass dieses p1 oder p2 nicht mehr auf das Objekt verweist,
[00:42:59.840 --> 00:43:02.840]   dann machen wir das, was wir auch schon mal gesehen haben.
[00:43:02.840 --> 00:43:07.840]   Wir setzen diese Referenzvariable auf diesen besonderen Wert, Null.
[00:43:07.840 --> 00:43:10.840]   Null ist dieser besondere Wert, der ist gut für alle Klassen.
[00:43:10.840 --> 00:43:16.840]   Und wenn ich das einmal ausgeführt habe, dann eben ist p2 nicht mehr in der Lage,
[00:43:16.840 --> 00:43:20.840]   auf dieses Objekt Exemplar zuzugreifen.
[00:43:20.840 --> 00:43:23.840]   Und Null noch p1 greift darauf zu.
[00:43:23.840 --> 00:43:26.840]   Okay, haben wir jetzt Punkt für die Pause.
[00:43:26.840 --> 00:43:28.840]   Machen wir jetzt hier Pause.
[00:43:28.840 --> 00:43:32.840]   Und danach machen wir weiter.
[00:43:35.840 --> 00:43:40.840]   Also, wenn wir dafür sorgen wollen, dass eben diese Referenzvariable
[00:43:40.840 --> 00:43:45.840]   auf keinen Objekt verweist, dann verwenden wir diesen besonderen Wert Null.
[00:43:45.840 --> 00:43:49.840]   Das ist ein Wert, den jede Referenzvariable haben kann.
[00:43:49.840 --> 00:43:52.840]   Also jede Variable, die die Referenz hermentlich unterstützt,
[00:43:52.840 --> 00:43:55.840]   sowohl also die Referenzvariable für Erreys,
[00:43:55.840 --> 00:44:00.840]   als auch für die Referenzvariable für Typen, die wir selbst deklarieren.
[00:44:00.840 --> 00:44:04.840]   Nachdem ich das einmal auf Null gesetzt habe, verweist das nichts.
[00:44:04.840 --> 00:44:06.840]   Ich habe das natürlich auch mit Strings.
[00:44:06.840 --> 00:44:09.840]   Da kann ich, wenn ich will, dass dieser String auch auf keinen anderen String mehr verweist,
[00:44:09.840 --> 00:44:12.840]   auch diesen String zu Null setzen.
[00:44:12.840 --> 00:44:18.840]   Und wenn eine Referenzvariable den Wert Null hat, dann sagen wir es eine Nullreferenz.
[00:44:18.840 --> 00:44:22.840]   Und Null kann eben nicht dereferenziert werden.
[00:44:22.840 --> 00:44:27.840]   Der Wert einer Referenzvariable, die auf keinen Objekt verweist.
[00:44:27.840 --> 00:44:31.840]   Wenn die auf keinen Objekt verweist, dann sind manche Sachen nicht möglich.
[00:44:31.840 --> 00:44:35.840]   Also wenn es einen Objekt gibt, dann kann ich das X-Attribut mir angucken.
[00:44:35.840 --> 00:44:40.840]   Aber wenn es kein Objekt gibt, nachdem ich hier das zu Null gesetzt habe,
[00:44:40.840 --> 00:44:43.840]   dann kann ich mir keinen Attribut angucken.
[00:44:43.840 --> 00:44:46.840]   Dann kann ich nicht sehen, was das Y-Attribut ist,
[00:44:46.840 --> 00:44:49.840]   weil das eben nicht definiert ist.
[00:44:49.840 --> 00:44:51.840]   Genauso war das bei Erreys.
[00:44:51.840 --> 00:44:58.840]   Wenn es einen Errey gibt, dann kann ich das Element mit Index Null auf einen bestimmten Wert setzen.
[00:44:58.840 --> 00:45:01.840]   Ich kann die Länge abfragen.
[00:45:01.840 --> 00:45:04.840]   Aber wenn ich einmal diese Referenzvariable auf Null gesetzt habe,
[00:45:04.840 --> 00:45:06.840]   dann kann ich nicht mehr die Länge abfragen.
[00:45:06.840 --> 00:45:10.840]   Und ich kann auch nicht irgendeines der Elemente auf irgendeinen Wert setzen,
[00:45:10.840 --> 00:45:14.840]   weil es eben halt keine Elemente gibt.
[00:45:14.840 --> 00:45:18.840]   Und dieses Null, das daran erinnern sich, wird auch benutzt,
[00:45:18.840 --> 00:45:21.840]   wenn ein neuer Erreyer stellt wird.
[00:45:21.840 --> 00:45:27.840]   Dann wurde damals jedes Element auf einen Wert gesetzt, der dieser Null entspricht.
[00:45:27.840 --> 00:45:30.840]   Für Zahlen waren das eben Null oder Null.0.
[00:45:30.840 --> 00:45:34.840]   Aber für Strings hatten wir gesehen, war das dieser besondere Wert Null.
[00:45:34.840 --> 00:45:41.840]   Und das gilt jetzt auch für Erreys, die eben auf Objekte verweisen können.
[00:45:41.840 --> 00:45:43.840]   Gilt das genauso.
[00:45:43.840 --> 00:45:48.840]   Da wird eben das Element, da wird jetzt auf den Wert gesetzt, der eben Null entspricht.
[00:45:48.840 --> 00:45:53.840]   Und das heißt, wenn also ein Erreyelement auf irgendein Objekt verweisen kann,
[00:45:53.840 --> 00:45:58.840]   dann wird dieses Erreyelement bei der Konstruktion auch auf Null gesetzt.
[00:45:58.840 --> 00:46:02.840]   Null ist der Wert, den wir vorfinden in unseren Erreys,
[00:46:02.840 --> 00:46:07.840]   bevor wir eben da konkret andere Werte abspeichern.
[00:46:07.840 --> 00:46:09.840]   Wenn wir einen Wert Erreyer stellen,
[00:46:09.840 --> 00:46:13.840]   wenn wir also einen Erreyer stellen, der hier ein Erreyer von Strings ist,
[00:46:13.840 --> 00:46:15.840]   dann gibt es einen Erreyer zurück.
[00:46:15.840 --> 00:46:19.840]   Und jedes dieser Elemente hat den Wert Null.
[00:46:19.840 --> 00:46:24.840]   Wogegen, als wir einen Int Erreyer stellten, hatte jeder diesen Wert Null.
[00:46:24.840 --> 00:46:25.840]   Diesen Wert Null.
[00:46:25.840 --> 00:46:29.840]   Aber jetzt für Strings oder irgendwelche anderen Objektreferenzen
[00:46:29.840 --> 00:46:33.840]   wird das Element auf Null gesetzt.
[00:46:33.840 --> 00:46:39.840]   Und das heißt, dass wir dann erst danach mit arbeiten können.
[00:46:39.840 --> 00:46:41.840]   Also hier habe ich diesen Erreye Words,
[00:46:41.840 --> 00:46:46.840]   der eben ein Erreyes der Platz für fünf Stringsreferenzen hat.
[00:46:46.840 --> 00:46:50.840]   Da habe ich also hier diesen Erreye oder einen anderen Erreye,
[00:46:50.840 --> 00:46:52.840]   den ich für den Zeichnen brauche.
[00:46:52.840 --> 00:46:57.840]   Und wenn ich den Erreyer stelle, sind die Anfangs alle Null.
[00:46:57.840 --> 00:47:01.840]   Und wenn ich jetzt so einen Erreyer habe,
[00:47:01.840 --> 00:47:07.840]   ich kann das auch wieder mit so einer Direkten Initialisierung machen,
[00:47:07.840 --> 00:47:13.840]   dann kann ich selektiv zum Beispiel das Element mit dem Index 1 auf Null setzen.
[00:47:13.840 --> 00:47:16.840]   Und dann ist das eben halt auf Null gesetzt
[00:47:16.840 --> 00:47:20.840]   und hat eben zurzeit keine Referenz auf irgendeinen Strings.
[00:47:20.840 --> 00:47:25.840]   Also, hat eine Referenz variabel in Wert Null,
[00:47:25.840 --> 00:47:27.840]   dann können wir sie nicht de-referenzieren,
[00:47:27.840 --> 00:47:29.840]   weil es verweist ja auf kein Objekt.
[00:47:29.840 --> 00:47:32.840]   De-referenzieren heißt, wir gehen zum Objekt
[00:47:32.840 --> 00:47:34.840]   und sehen uns dann da das Attribut an
[00:47:34.840 --> 00:47:39.840]   oder später rufen eine entsprechende Methode auf.
[00:47:39.840 --> 00:47:42.840]   Und wenn eben eine Erreferenz variabel den Wert Null hat,
[00:47:42.840 --> 00:47:44.840]   dann gab es eben keine Länge.
[00:47:44.840 --> 00:47:48.840]   Die Länge gibt es nur, wenn der Wert un- gleich Null ist.
[00:47:48.840 --> 00:47:52.840]   Wenn der Wert Null ist, dann geht das nicht mehr,
[00:47:52.840 --> 00:47:55.840]   nur wenn der Wert Null ist, geht es nicht.
[00:47:55.840 --> 00:47:57.840]   Der Wert muss un- gleich Null sein.
[00:47:57.840 --> 00:48:02.840]   Und das war der Grund auch, warum wir das Längenattribut nur abfragen können,
[00:48:02.840 --> 00:48:05.840]   wenn es einen wirklichen Erre- gibt.
[00:48:05.840 --> 00:48:07.840]   Und wenn Sie jetzt doch versuchen sollten,
[00:48:07.840 --> 00:48:11.840]   den mit dem Null die Null-Ref- renz zu de-referenzieren,
[00:48:11.840 --> 00:48:13.840]   dann beschwert sich das System.
[00:48:13.840 --> 00:48:16.840]   Dann beschwert sich das System und sagt, das geht nicht.
[00:48:16.840 --> 00:48:20.840]   Dann gibt es zur Ausführungszeit, also zur Laufzeit, einen Fehler.
[00:48:20.840 --> 00:48:22.840]   Das kann man ja erst zur Laufzeit feststellen,
[00:48:22.840 --> 00:48:25.840]   weil dann sieht man ja, dass da kein Objekt ist.
[00:48:25.840 --> 00:48:29.840]   Also hier zum Beispiel haben wir P2 auf Null gesetzt.
[00:48:29.840 --> 00:48:35.840]   P2 ist eine Referenz, die auf denselben Punkt verweist wie P1.
[00:48:35.840 --> 00:48:37.840]   Und jetzt setzt sich danach auf Null.
[00:48:37.840 --> 00:48:42.840]   Und wenn ich jetzt versuchen sollte, auf das X-Attribut oder Öfterattribut zuzugreifen,
[00:48:42.840 --> 00:48:44.840]   dann gibt es eben einen Fehler.
[00:48:44.840 --> 00:48:46.840]   Und dann sagt das System "exception",
[00:48:46.840 --> 00:48:49.840]   das ist der Standardausdruck für Laufzeitfehler.
[00:48:49.840 --> 00:48:52.840]   Hier ist eine Exception.
[00:48:52.840 --> 00:48:55.840]   Und es gibt eine Null-Pointer-Exception.
[00:48:55.840 --> 00:48:58.840]   Das ist, wenn wir später nochmal genauer angucken.
[00:48:58.840 --> 00:49:02.840]   Also Null ist eben, dieses Null ist nicht ein besonderes Objekt,
[00:49:02.840 --> 00:49:04.840]   sondern ist einfach ein Objekt, das sagt,
[00:49:04.840 --> 00:49:09.840]   dass eine Referenz, die sagt, dass diese Variable sich auf kein Objekt
[00:49:09.840 --> 00:49:14.840]   oder keinen Array, kein Objekt irgendeiner Klasse zur Zeit bezieht.
[00:49:14.840 --> 00:49:18.840]   Und das sollen wir nicht machen, dann gibt es eben entsprechenden Fehler.
[00:49:18.840 --> 00:49:22.840]   Nun ist es so, weil das, jemand fragte mich in der Pause,
[00:49:22.840 --> 00:49:24.840]   gibt es in Java Pointers?
[00:49:24.840 --> 00:49:27.840]   Und die Antwort war damals, die sagte, nein, gibt es eigentlich nicht.
[00:49:27.840 --> 00:49:29.840]   So was machen wir nicht.
[00:49:29.840 --> 00:49:32.840]   Natürlich gibt es irgendwo Pointers tief im System.
[00:49:32.840 --> 00:49:34.840]   Und wenn Sie so was versuchen,
[00:49:34.840 --> 00:49:40.840]   wo Sie also versuchen, mit einer Null-Refenz zu de-referenzieren,
[00:49:40.840 --> 00:49:42.840]   dann gibt es eben eine Null-Pointer-Exception,
[00:49:42.840 --> 00:49:46.840]   weil das System dann eben feststellt, dass hier etwas nicht in Ordnung ist.
[00:49:46.840 --> 00:49:50.840]   Also sehen Sie so ein bisschen, in der Implementation gibt es natürlich schon Pointer,
[00:49:50.840 --> 00:49:54.840]   aber für uns als Programmierer, oder Programmiererin,
[00:49:54.840 --> 00:49:57.840]   gibt es keine solche Probleme.
[00:49:57.840 --> 00:50:02.840]   Also das ist einfach die Regel, die wir hier haben.
[00:50:02.840 --> 00:50:09.840]   Also, jetzt, da diese Null-Referenzen ja eben so ärgerlich sind,
[00:50:09.840 --> 00:50:13.840]   muss unser Programm normalerweise prüfen,
[00:50:13.840 --> 00:50:18.840]   ob eine Variable oder ein Array-Element, was auch immer Null ist.
[00:50:18.840 --> 00:50:22.840]   Oder wenn ich eine Methode habe, die eine Referenzvariable entgegen nimmt,
[00:50:22.840 --> 00:50:24.840]   wenn ich nichts anderes weiß,
[00:50:24.840 --> 00:50:28.840]   muss die Methode eigentlich prüfen, ob die übergebende Variable Null ist.
[00:50:28.840 --> 00:50:32.840]   Weil die könnt ihr in Werten Null haben, und dann geht vieles nicht.
[00:50:32.840 --> 00:50:36.840]   Und was erlaubt ist, Sie können, was wir machen können ist,
[00:50:36.840 --> 00:50:39.840]   wir können mittels dieses Gleichheitsoperators checken,
[00:50:39.840 --> 00:50:47.840]   ob eben ein Array-Element oder eine Variable optional sind.
[00:50:47.840 --> 00:50:51.840]   Das kann ich checken, und wenn das Null ist, dann mache ich eben etwas nicht.
[00:50:51.840 --> 00:50:55.840]   Wenn das Null ist, dann kann ich eben etwas machen.
[00:50:55.840 --> 00:50:58.840]   Wir werden später noch mehr über Exceptions lernen.
[00:50:58.840 --> 00:51:01.840]   Zurzeit wollen wir die einfach mal verhindern,
[00:51:01.840 --> 00:51:04.840]   und wollen, wenn es geht, mit denen nichts zu tun haben.
[00:51:04.840 --> 00:51:07.840]   Aber wir können die eben nicht ganz ignorieren,
[00:51:07.840 --> 00:51:11.840]   und wenn Sie eben versehentlich eine Null-Referenz de-referenzieren sollten,
[00:51:11.840 --> 00:51:13.840]   dann gibt es eben eine Exception.
[00:51:13.840 --> 00:51:17.840]   Und eben ein stabiles Programm sorgt dafür,
[00:51:17.840 --> 00:51:21.840]   dass eben gecheckt wird, bevor eine Variable de-referenziert wird.
[00:51:21.840 --> 00:51:26.840]   Also, können natürlich checken, ob so eine Referenz Null ist oder nicht.
[00:51:26.840 --> 00:51:32.840]   Also, Sie haben hier einen Loop, der geht durch so ein Array von Words durch.
[00:51:32.840 --> 00:51:36.840]   Und wenn dieses Element ungleich Null ist,
[00:51:36.840 --> 00:51:43.840]   dann erst wollen wir hingehen, und die Methode ToUpperCase eben aufrufen.
[00:51:43.840 --> 00:51:50.840]   Wenn das Element Null wäre, dann würden wir natürlich das nicht machen wollen,
[00:51:50.840 --> 00:51:53.840]   weil das wäre eben dann gar nicht erlaubt.
[00:51:53.840 --> 00:51:57.840]   Also, könnten wir so einen Exkluziten-Test haben, der sagt eben hier,
[00:51:57.840 --> 00:52:03.840]   wenn das Element ungleich Null ist, dann bitte diesen Block ausführen.
[00:52:03.840 --> 00:52:06.840]   Aber das kann man noch ein bisschen kompakter schreiben,
[00:52:06.840 --> 00:52:10.840]   und so sehen Sie es auch in vielen realistischen Programmen,
[00:52:10.840 --> 00:52:14.840]   dass wir halt eben, oder könnten sogar auch hingehen und checken,
[00:52:14.840 --> 00:52:16.840]   ob das einen bestimmten Wert hat.
[00:52:16.840 --> 00:52:18.840]   Weil wir gucken nach, ist es nicht Null.
[00:52:18.840 --> 00:52:22.840]   Wenn es nicht Null ist, gucken wir nach, ob es einen bestimmten Wert hat.
[00:52:22.840 --> 00:52:28.840]   Und wenn das der Fall ist, dann gehen wir hin und setzen es auf ToUpper,
[00:52:28.840 --> 00:52:30.840]   setzen es in Großbuchstaben.
[00:52:30.840 --> 00:52:33.840]   Aber jetzt sehen Sie es schon, jetzt haben wir hier ein If, noch ein If und so weiter.
[00:52:33.840 --> 00:52:37.840]   Das ist eigentlich nicht das, was wir gerne wollen.
[00:52:37.840 --> 00:52:40.840]   Das sieht ja unübersichtlich aus.
[00:52:40.840 --> 00:52:42.840]   Und das erinnern wir uns vielleicht daran,
[00:52:42.840 --> 00:52:45.840]   dass es bei der bedingten Auswertung doch so ist,
[00:52:45.840 --> 00:52:51.840]   dass die Auswertung aufhört, sobald wir wissen, was das Ergebnis ist.
[00:52:51.840 --> 00:52:54.840]   Also, wenn ich einen logischen Und-Operator habe,
[00:52:54.840 --> 00:52:59.840]   sobald einer der operanten Falls ist, hört die Auswertung auf,
[00:52:59.840 --> 00:53:01.840]   weil wir wissen ja, das bleibt Falls.
[00:53:01.840 --> 00:53:06.840]   Und daher kann ich so eine Folge von Tests doch viel einfacher so machen.
[00:53:06.840 --> 00:53:11.840]   Ich checke erst, ob das Element, das ich mit dem R.A. mit dem ich arbeiten will,
[00:53:11.840 --> 00:53:13.840]   Null ist oder Ungleich Null ist.
[00:53:13.840 --> 00:53:18.840]   Und wenn es Ungleich Null ist, dann gehe ich hin und mache weiter.
[00:53:18.840 --> 00:53:25.840]   Dann gehe ich hin und checke danach, ob das Element eben diesen String hat,
[00:53:25.840 --> 00:53:31.840]   für den ich etwas bestimmt einen Schritt durchführen will oder etwas machen will.
[00:53:31.840 --> 00:53:35.840]   Also, dann, wenn das eben Null sein sollte wie hier,
[00:53:35.840 --> 00:53:40.840]   dann ist das hier Falls und dann wird dieser andere Teil gar nicht erst ausgeführt.
[00:53:40.840 --> 00:53:45.840]   Das heißt, ich habe so kompakt geschrieben, dass ich das nur ausführen will,
[00:53:45.840 --> 00:53:48.840]   wenn diese Bedingungen erfüllt sind.
[00:53:48.840 --> 00:53:53.840]   Die Referenz muss Ungleich Null sein und der String, auf den diese Referenz verweist,
[00:53:53.840 --> 00:53:56.840]   die muss gleich dem String gut bei sein.
[00:53:56.840 --> 00:54:00.840]   Und dann erst will ich diese Operation machen.
[00:54:00.840 --> 00:54:02.840]   So können Sie, das werden Sie in vielen Programmen sehen,
[00:54:02.840 --> 00:54:06.840]   und so können Sie auch selber ohne eine Schachtelung von If-Statements machen,
[00:54:06.840 --> 00:54:12.840]   zu müssen selber kompakt checken, ob diese Referenz eine Null-Refreenz ist oder nicht.
[00:54:12.840 --> 00:54:14.840]   Hallo.
[00:54:14.840 --> 00:54:18.840]   Und eben sehr oft übergeben wir das Null als Parametern eine Methode,
[00:54:18.840 --> 00:54:22.840]   wenn wir der irgendwie nur einen bestimmten, wenn wir eben selber nicht
[00:54:22.840 --> 00:54:26.840]   ein weiteres Objekt geben wollen, mit dem sie arbeiten soll.
[00:54:26.840 --> 00:54:30.840]   Wenn ich eine Methode habe, die eine Referenzvariable erwartet,
[00:54:30.840 --> 00:54:35.840]   sei es eine Referenzvariable für einen Array, sei es eine Referenzvariable
[00:54:35.840 --> 00:54:42.840]   für irgendein Punkt-Objekt oder sowas, kann ich immer Null übergeben.
[00:54:42.840 --> 00:54:46.840]   Und damit sage ich dann eben, in diesem Fall gibt es kein Array
[00:54:46.840 --> 00:54:48.840]   oder keinen Point-Objekt usw.
[00:54:48.840 --> 00:54:53.840]   Und daher muss dann die Methode eventuell prüfen, ob der Parameter Null ist.
[00:54:53.840 --> 00:54:58.840]   Manchmal sagen unsere Aufgabenstellungen, sie können sicher sein,
[00:54:58.840 --> 00:55:03.840]   dass die Referenzvariable oder dass der Parameter ungleichen Null ist.
[00:55:03.840 --> 00:55:05.840]   Dann brauchen sie nicht mehr checken.
[00:55:05.840 --> 00:55:09.840]   Aber wenn wir nichts sagen, ist es eine gute Idee, im Programm zu checken,
[00:55:09.840 --> 00:55:12.840]   ob die Referenzvariable Null ist.
[00:55:12.840 --> 00:55:17.840]   Und dann können Sie eben auch, was Sie auch oft sehen, Null zurückgeben.
[00:55:17.840 --> 00:55:21.840]   Wenn Sie Null zurückgeben, dann ist das vielleicht so eine Fehleranzeige.
[00:55:21.840 --> 00:55:24.840]   Normalerweise gibt die Methode einen Array zurück,
[00:55:24.840 --> 00:55:30.840]   aber jetzt gibt sie eben halt Null zurück, um zu sagen, da ist irgendwas schief gelaufen.
[00:55:30.840 --> 00:55:34.840]   Also, noch mal eine Zusammenfassung.
[00:55:34.840 --> 00:55:40.840]   Die Referenzvariablen erlauben den Zugriff auf einen Array- oder ein Objektexemplar.
[00:55:40.840 --> 00:55:44.840]   Und die Referenzvariable muss auf einen konkreten Array
[00:55:44.840 --> 00:55:48.840]   oder muss auf ein konkretes Objekt verweisen, um so etwas,
[00:55:48.840 --> 00:55:51.840]   um eben so einen Zugriff zu erlauben.
[00:55:51.840 --> 00:55:55.840]   Und erst, wenn wir eben Referenzvariable mit einem Objekt,
[00:55:55.840 --> 00:55:57.840]   also einem Array oder einem Exemplar,
[00:55:57.840 --> 00:56:00.840]   dass wir durch eine Klasse konstruiert haben, verknüpft haben,
[00:56:00.840 --> 00:56:04.840]   dann erst können wir auf die Attribute zugreifen,
[00:56:04.840 --> 00:56:07.840]   auf die Elemente zugreifen und so weiter.
[00:56:07.840 --> 00:56:10.840]   Sonst geht das alles nicht.
[00:56:10.840 --> 00:56:17.840]   Die Verknüpfung kann passieren, indem wir nachher so eine Zuweisung ausführen
[00:56:17.840 --> 00:56:20.840]   oder dass wir eine Zuweisung ausführen,
[00:56:20.840 --> 00:56:24.840]   wo wir auf der rechten Seite eine Referenzvariable haben,
[00:56:24.840 --> 00:56:32.840]   auf der linken Seite und die natürlich beide auf dieselbe Art von Objekten verweisen müssen.
[00:56:32.840 --> 00:56:36.840]   Das kann wir mit den Arrays auch gesehen, wenn ich in ein Interray,
[00:56:36.840 --> 00:56:42.840]   wenn ich eine Referenzvariable habe, die sich auf einen Array von ganzen Zahlen beziehen kann,
[00:56:42.840 --> 00:56:46.840]   dann kann die sich auf einen beliebigen Array von ganzen Zahlen beziehen.
[00:56:46.840 --> 00:56:48.840]   Egal, welcher Länge.
[00:56:48.840 --> 00:56:56.840]   Und das ist eben halt die Einschränkung, die die Typ-Deklaration zur Folge hat.
[00:56:56.840 --> 00:57:02.840]   So, und Referenzvariable verwenden immer Referenz-Semitics.
[00:57:02.840 --> 00:57:10.840]   Und das heißt, zwei können oder mehr Referenzvariable können auf derselbe Objekt verweisen.
[00:57:10.840 --> 00:57:15.840]   Ich habe hier dieses P1, das konstruiert so ein Punktobjekt
[00:57:15.840 --> 00:57:20.840]   und ich habe hier P2, dass ich auf dieselbe Objekt verweisen lasse,
[00:57:20.840 --> 00:57:28.840]   dass hier konstruiert wurde und indem jetzt hier nachträglich die x und y Attribute geändert wurden.
[00:57:28.840 --> 00:57:32.840]   Und wenn ich jetzt eben auf dieses Objekt zugreife, auf mittels P2,
[00:57:32.840 --> 00:57:37.840]   bekomme ich dieselben Attributwerte, die ich bekomme, wenn ich mittels P1 darauf zuweile.
[00:57:37.840 --> 00:57:42.840]   Und wenn eben P2, die Referenzvariable P2 verwendet wird,
[00:57:42.840 --> 00:57:49.840]   um irgendein Attribut zu ändern, dann ist das auch durch die andere Referenzvariable sichtbar.
[00:57:49.840 --> 00:57:51.840]   Genauso, wie das bei den Errays war.
[00:57:51.840 --> 00:57:55.840]   Genauso war kein bisschen anders.
[00:57:55.840 --> 00:58:01.840]   Und wenn wir eben Elemente eines Errays haben, die Referenztypen sind,
[00:58:01.840 --> 00:58:08.840]   also einen Erray von Strings oder einen Erray von Points oder einen Erray von irgendwelchen Panels oder was auch immer,
[00:58:08.840 --> 00:58:12.840]   so speichert natürlich diese Erray-Elemente nicht das Objekt selber,
[00:58:12.840 --> 00:58:16.840]   sondern auch wieder nur einen Verweis auf das Objekt.
[00:58:16.840 --> 00:58:20.840]   Nur bei Basestypen, da wird der Wert direkt gespeichert.
[00:58:20.840 --> 00:58:24.840]   Bei allen Referenztypen speichert dann der Erray eine Referenz.
[00:58:24.840 --> 00:58:30.840]   Und deswegen brauchen wir für die Initialisierung im allgemeinen zwei Schritte.
[00:58:30.840 --> 00:58:35.840]   Erst werden wir den Erray erstellen und initialisieren
[00:58:35.840 --> 00:58:41.840]   und dann gegebenenfalls die Referenzvariable auf diesen Erray verweisen lassen.
[00:58:41.840 --> 00:58:48.840]   Also wenn ich eben halt den Erray habe, am Anfang haben die Elemente alle den Wert 0 oder 0.0 oder auch Null,
[00:58:48.840 --> 00:58:53.840]   wenn es eine Referenz auf Objekte ist, dann kann ich da in zweiten Schritt hingehen
[00:58:53.840 --> 00:58:57.840]   und konkrete Objektreferenzen unterbringen.
[00:58:57.840 --> 00:59:02.840]   Oder beim String, das ist ein einfaches Beispiel eines Objekts.
[00:59:02.840 --> 00:59:08.840]   Am Anfang besteht der Orray aus vier Mal-Null-Refrenzen
[00:59:08.840 --> 00:59:11.840]   und dann kann ich hingehen, in diesem Fall mache ich das so,
[00:59:11.840 --> 00:59:19.840]   dass ich in jedes dieser Elemente eine Referenz auf den String reinsetze, den ich je konstruiere
[00:59:19.840 --> 00:59:25.840]   und ich konstruiere halt hier den String, der dadurch gefronten wird, dass ich diesen String wurt,
[00:59:25.840 --> 00:59:31.840]   mit dem String konkateniere, der den durch den Loopzäler angegeben wird.
[00:59:31.840 --> 00:59:35.840]   Dann habe ich das Wort Null, eins Wort zwei und so weiter.
[00:59:35.840 --> 00:59:41.840]   Und da das eben Referenzvariable sind, was ich letzte Woche über die,
[00:59:41.840 --> 00:59:47.840]   oder auch am Dienstag über die Erray-Refrenzen als Parameter gesagt habe,
[00:59:47.840 --> 00:59:51.840]   das gilt jetzt auch für diese Objekte, weil ich hatte damals ja gesagt,
[00:59:51.840 --> 00:59:56.840]   Errays sind, Erray-Refrenzen sind auch wieder Referenzen auf Objekte.
[00:59:56.840 --> 01:00:02.840]   Und die können wir natürlich als Parameter übergeben und es gelten wieder die Referenzsementix-Regeln.
[01:00:02.840 --> 01:00:08.840]   Das heißt also, wenn ich ein Objekt übergebe, übergebe ich eine Referenz auf ein Objekt
[01:00:08.840 --> 01:00:11.840]   und eben übergebe das bei Referenz.
[01:00:11.840 --> 01:00:18.840]   Also die Methode bekommt die Referenz und die kann dann eben mit diesem Objekt arbeiten.
[01:00:18.840 --> 01:00:21.840]   Wenn das System das zulässt, das Objekt verändert.
[01:00:21.840 --> 01:00:25.840]   Wie beim Erray-Parameter, wenn ich ein Erray-Parameter übergebe,
[01:00:25.840 --> 01:00:30.840]   kann die Methode die einzelne Elemente des Errays lesen und auch verändern.
[01:00:30.840 --> 01:00:35.840]   Und das können Sie einmal ausnutzen, wenn Sie mich wegen an verschiedenen Stellen
[01:00:35.840 --> 01:00:39.840]   in Ihrem Programm vom Keyboard lesen wollen, dann es macht Sinn,
[01:00:39.840 --> 01:00:43.840]   so einen Scanner mit dem Input nur einmal zu konstruieren.
[01:00:43.840 --> 01:00:46.840]   Wenn Sie das mehrfach konstruieren, dann können andere Probleme auftreten.
[01:00:46.840 --> 01:00:54.840]   Dann haben Sie halt eine Referenz-Variable-Konsole, die jetzt eben eine Referenz auf ein Scanner-Exemplar ist
[01:00:54.840 --> 01:01:00.840]   und die können Sie jetzt eben als Parameter für diese Methode oder für eine andere Methode verwenden.
[01:01:00.840 --> 01:01:08.840]   Und dann kann jede dieser Methode von Ihnen, von dem der Konsole lesen und dementsprechend weiterarbeiten.
[01:01:08.840 --> 01:01:13.840]   Und hier diese Methode, die Sie irgendwo haben, das ist eine Methode hier,
[01:01:13.840 --> 01:01:16.840]   weil aesthetics sind das Methoden in Ihrem Hauptprogramm.
[01:01:16.840 --> 01:01:21.840]   Die erwarten eine Referenz auf einen Scanner, das der jetzt Konsole heißt,
[01:01:21.840 --> 01:01:26.840]   es ist reine, weil man kein besserer Name eingefallen ist, der Name spielt keine Rolle
[01:01:26.840 --> 01:01:31.840]   und diese Methode erwartet auch wieder eine Referenz auf einen Scanner.
[01:01:31.840 --> 01:01:36.840]   Und jede von denen kann dann entsprechend lesen und damit arbeiten.
[01:01:36.840 --> 01:01:40.840]   Also Objekt als Parameter, Wiederreferenz-Variable
[01:01:40.840 --> 01:01:45.840]   und dann ist es die Sache des Objekts zu entscheiden, was für Operationen
[01:01:45.840 --> 01:01:50.840]   und gegebenenfalls Methoden möglich sind, was für Attribute existieren.
[01:01:50.840 --> 01:01:54.840]   Bei den Array-Elementen hatten wir gesehen, dass die verändert werden können.
[01:01:54.840 --> 01:01:59.840]   Aber wir hatten auch gesehen bei den Strings, dass Strings können nicht verändert werden.
[01:01:59.840 --> 01:02:04.840]   Wenn ich einen String übergebe, dann muss die Methode mit dem String arbeiten
[01:02:04.840 --> 01:02:06.840]   und kann sonst nichts anderes machen.
[01:02:06.840 --> 01:02:08.840]   Sie kann den String nicht verändern.
[01:02:08.840 --> 01:02:11.840]   Sie kann neuen Strings konstruieren, aber sie kann nichts verändern.
[01:02:11.840 --> 01:02:15.840]   Aber das war eine Entscheidung, die das Objekt gefällt hat
[01:02:15.840 --> 01:02:20.840]   oder die festgelegt wurde von den Leuten, die das Objekt erstellt haben.
[01:02:20.840 --> 01:02:26.840]   Die haben das so aufgesetzt, dass eben halt Änderungen nicht möglich sind.
[01:02:26.840 --> 01:02:31.840]   Und Strings können eben nicht verändert werden, weil man die eben besonders optimiert hat.
[01:02:31.840 --> 01:02:34.840]   Es gibt schon einen Weg, wie man auch das umgehen kann,
[01:02:34.840 --> 01:02:38.840]   aber das ist kein Thema für die Einführung in die Programmierung.
[01:02:38.840 --> 01:02:42.840]   Und sie sollten auch nicht das versuchen, weil Programme, die das machen,
[01:02:42.840 --> 01:02:48.840]   sind sehr schnell unübersichtlich und vor allen Dingen, die funktionieren dann auch nicht immer überall.
[01:02:48.840 --> 01:02:52.840]   So, das habe ich zum Thema Objekte und Attribute
[01:02:52.840 --> 01:02:56.840]   und jetzt wollte ich auch zum Thema Klassen und ihre Klienten sagen.
[01:02:56.840 --> 01:02:59.840]   Nun ist es aber so, bei unseren Übungsaufgaben, die wir haben,
[01:02:59.840 --> 01:03:05.840]   wird es immer schwieriger, Aufgaben zu finden, die halbwegs interessant sind.
[01:03:05.840 --> 01:03:10.840]   Und deswegen haben wir uns gedacht, müssten wir Ihnen ein bisschen mehr über I/O erzählen,
[01:03:10.840 --> 01:03:13.840]   einfach weil sonst einfach das zu langweilig wird.
[01:03:13.840 --> 01:03:19.840]   Oder Sie verbringen zu viel Zeit damit, dass Sie eben Zahlen eingeben.
[01:03:19.840 --> 01:03:25.840]   Und deswegen haben wir, wie gesagt, irgendwo bringen wir diese Kapitel 5 schubweise unter,
[01:03:25.840 --> 01:03:28.840]   ein bisschen was mit I/O wollen wir ja machen.
[01:03:28.840 --> 01:03:34.840]   Und als erstes wollte ich Ihnen kurz zeigen, wie Sie statt von der Konsole einzulesen,
[01:03:34.840 --> 01:03:39.840]   mit Dateien arbeiten können. Das macht Ihr Leben vielleicht etwas leichter.
[01:03:39.840 --> 01:03:43.840]   Und daher mache ich das jetzt als Einschub. Die Slides finden Sie,
[01:03:43.840 --> 01:03:47.840]   falls Sie jetzt die runtergeladen haben, sollten gegen Ende der anderen Slides,
[01:03:47.840 --> 01:03:50.840]   weil ich nicht genau wusste, wann ich den Einschub mache.
[01:03:50.840 --> 01:03:53.840]   Die finden Sie auch alle auf dem Netz.
[01:03:53.840 --> 01:03:57.840]   Und wenn Sie mal je sehen, dass Slides nicht auf dem Netz sind,
[01:03:57.840 --> 01:04:02.840]   schicken Sie mir Mail oder posten Sie es im Kurskanal, dann ist irgendwas schief gelaufen
[01:04:02.840 --> 01:04:05.840]   und wir versuchen das zu fixen.
[01:04:05.840 --> 01:04:10.840]   Also, jetzt wollen wir also nicht mehr nur von der Konsole lesen,
[01:04:10.840 --> 01:04:12.840]   sondern mit irgendwelchen Dateien arbeiten.
[01:04:12.840 --> 01:04:17.840]   Und da gibt es in Java eine klasse File, die erlaubt Operationen mit Dateien,
[01:04:17.840 --> 01:04:19.840]   also mit Files.
[01:04:19.840 --> 01:04:22.840]   Und damit können wir solche Dateien lesen und schreiben.
[01:04:22.840 --> 01:04:26.840]   Und jetzt, wo wir wissen, was eine Klasse ist, können wir uns ungefähr vorstellen,
[01:04:26.840 --> 01:04:28.840]   was dahintersteckt.
[01:04:28.840 --> 01:04:31.840]   Und wir können dann auch verschiedene Operationen ausführen.
[01:04:31.840 --> 01:04:37.840]   Eine der Operationen ist zum Beispiel, dass wir herausfinden, wie groß ist die File.
[01:04:37.840 --> 01:04:41.840]   Und natürlich, das ist ein scharfes Messer, mit dem wir arbeiten.
[01:04:41.840 --> 01:04:43.840]   Wir können diese Dateien umbenennen.
[01:04:43.840 --> 01:04:45.840]   Wir können die Dateien löschen.
[01:04:45.840 --> 01:04:48.840]   Sie können damit sich viel Freude bereiten.
[01:04:48.840 --> 01:04:51.840]   So, jetzt, wie machen wir das?
[01:04:51.840 --> 01:04:55.840]   Nun, um das zu machen, müssen wir dem System sagen,
[01:04:55.840 --> 01:04:58.840]   dass wir mit Files arbeiten wollen.
[01:04:58.840 --> 01:05:00.840]   Das heißt, Sie müssen einen Importstatement haben.
[01:05:00.840 --> 01:05:05.840]   Es sagt, importiere diese Fileservices.
[01:05:05.840 --> 01:05:09.840]   Und wenn ich das einmal gemacht habe, dann, wie bei dem Scanner,
[01:05:09.840 --> 01:05:14.840]   dann erstelle ich ein neues Exemplar dieses FileManagers
[01:05:14.840 --> 01:05:21.840]   und dem gebe ich als Tring den Namen der Datei, die ich gerne öffnen will
[01:05:21.840 --> 01:05:23.840]   oder mit der ich arbeiten will.
[01:05:23.840 --> 01:05:26.840]   Das sieht man natürlich nicht, aber das können wir ja fixen.
[01:05:26.840 --> 01:05:36.840]   Also, dann gebe ich hier, der als Tring den Namen der Datei, mit der ich arbeiten will.
[01:05:36.840 --> 01:05:38.840]   Und dann brauche ich natürlich wieder eine Referenzvariable.
[01:05:38.840 --> 01:05:42.840]   Die Referenzvariable ist eben vom Typ File.
[01:05:42.840 --> 01:05:45.840]   Also, die bezieht sich auf FileObjekte.
[01:05:45.840 --> 01:05:49.840]   Und dann kann ich jetzt mit dieser Datei arbeiten.
[01:05:49.840 --> 01:05:54.840]   Und zum Beispiel könnte ich jetzt sagen, wenn diese File existiert
[01:05:54.840 --> 01:05:57.840]   und die File einen länger größer als 1000 bytes hat,
[01:05:57.840 --> 01:06:00.840]   dann möchte ich sie deliten.
[01:06:00.840 --> 01:06:01.840]   Vielleicht, ja.
[01:06:01.840 --> 01:06:03.840]   Aber dann ist sie weg.
[01:06:03.840 --> 01:06:08.840]   Ist sie weg und da gibt es keinen Backup, die ist einfach weg.
[01:06:08.840 --> 01:06:15.840]   Deswegen, passen Sie auf, welches Beispiel Sie mit welchem da anwenden
[01:06:15.840 --> 01:06:17.840]   und was Sie da machen.
[01:06:17.840 --> 01:06:23.840]   So, jetzt diese File, das ist nicht diese Referenzvariable File,
[01:06:23.840 --> 01:06:27.840]   die erlaubt es mir, mit dieser File zu arbeiten.
[01:06:27.840 --> 01:06:29.840]   Das ist nicht die File selber.
[01:06:29.840 --> 01:06:32.840]   Das ist eine Referenzvariable, die es mir erlaubt,
[01:06:32.840 --> 01:06:35.840]   mit dieser File zu arbeiten.
[01:06:35.840 --> 01:06:37.840]   Und was heißt arbeiten?
[01:06:37.840 --> 01:06:41.840]   Ich kann eine von verschiedenen Methoden ausführen
[01:06:41.840 --> 01:06:43.840]   oder Operationen ausführen.
[01:06:43.840 --> 01:06:47.840]   Ich kann also checken, ob die File überhaupt existiert.
[01:06:47.840 --> 01:06:50.840]   Ich kann checken, ob ich die File lesen kann.
[01:06:50.840 --> 01:06:52.840]   Je nach Betriebssystem gibt es da die Möglichkeit,
[01:06:52.840 --> 01:06:54.840]   das einzuschränken.
[01:06:54.840 --> 01:06:56.840]   Ich kann den Namen bekommen.
[01:06:56.840 --> 01:06:59.840]   Ich kann die Länge bekommen, wie viele Elemente da sind.
[01:06:59.840 --> 01:07:01.840]   Ja, wir können die deliten, wenn wir wollen.
[01:07:01.840 --> 01:07:03.840]   Und wir können die auch umbenennen.
[01:07:03.840 --> 01:07:07.840]   So, jetzt wichtig ist diese Operationen,
[01:07:07.840 --> 01:07:11.840]   die machen Sie auf der Datei, aber die bestimmen Sie
[01:07:11.840 --> 01:07:16.840]   mit dem File-Objekt, das Sie hier erstellt haben.
[01:07:16.840 --> 01:07:21.840]   Diese Konstrukte, der New-Operator,
[01:07:21.840 --> 01:07:26.840]   gibt Ihnen ein File-Objekt, mit dem Sie jetzt arbeiten können.
[01:07:26.840 --> 01:07:30.840]   Und ein solches File-Objekt nennt man eine Handel.
[01:07:30.840 --> 01:07:36.840]   Also dieser Ausdruck, File-New-File, mit dem entsprechenden Namen,
[01:07:36.840 --> 01:07:38.840]   der erstellt nicht die Datei,
[01:07:38.840 --> 01:07:43.840]   der erstellt nur ein Objekt, mit dem Sie arbeiten können,
[01:07:43.840 --> 01:07:45.840]   das für die entsprechende Datei steht.
[01:07:45.840 --> 01:07:48.840]   Und so ein Objekt nennt man die Handel.
[01:07:48.840 --> 01:07:51.840]   Ich kenne kein gutes deutsches Wort dafür.
[01:07:51.840 --> 01:07:56.840]   Also ist die Handel, mit der können Sie diese Datei
[01:07:56.840 --> 01:08:00.840]   entweder manipulieren oder inspizieren oder irgendwas machen.
[01:08:00.840 --> 01:08:05.840]   Damit können Sie Operationen mit der Datei machen.
[01:08:05.840 --> 01:08:10.840]   Dass diese New-Operator hier erstellt eben nur die Handel,
[01:08:10.840 --> 01:08:13.840]   erstellt nicht die Datei selber.
[01:08:13.840 --> 01:08:16.840]   Und deswegen gibt es eben eine Methode,
[01:08:16.840 --> 01:08:20.840]   mit der Sie feststellen können, ob die Datei existiert.
[01:08:20.840 --> 01:08:22.840]   Deswegen gibt es diese Exist-Methode,
[01:08:22.840 --> 01:08:26.840]   weil ich kann ein File-Objekt, also so ein Objekt,
[01:08:26.840 --> 01:08:31.840]   für eine Datei, die es gar nicht gibt.
[01:08:31.840 --> 01:08:37.840]   Ich kann hier die Datei Fubar, den Namen Fubar als Namen angeben,
[01:08:37.840 --> 01:08:40.840]   den gibt es wahrscheinlich auf meinem Computer nicht.
[01:08:40.840 --> 01:08:43.840]   Das ist okay, weil jetzt habe ich eine Handel,
[01:08:43.840 --> 01:08:49.840]   mit der ich die Fubar-Datei, wenn sie existieren sollte, manipulieren kann.
[01:08:49.840 --> 01:08:52.840]   Das ist nicht diese Fubar-Datei.
[01:08:52.840 --> 01:08:54.840]   Wenn ich die erstellen will,
[01:08:54.840 --> 01:08:56.840]   dann muss ich andere Schritte machen,
[01:08:56.840 --> 01:08:59.840]   auf die komme ich nachher noch zu sprechen.
[01:08:59.840 --> 01:09:02.840]   Wichtig ist, dass Sie wissen, dass exist ist wichtig,
[01:09:02.840 --> 01:09:05.840]   damit Sie feststellen können, ob die Datei,
[01:09:05.840 --> 01:09:10.840]   der Namen Sie da oben angeben haben, bereits existiert.
[01:09:10.840 --> 01:09:14.840]   So, jetzt haben wir so eine Datei und jetzt wollen wir aus der Lesen.
[01:09:14.840 --> 01:09:17.840]   Und jetzt sehen Sie, das können Sie schon.
[01:09:17.840 --> 01:09:19.840]   Das haben Sie schon gelernt.
[01:09:19.840 --> 01:09:21.840]   Sie sehen Sie, wir haben das schon mal Input gemacht.
[01:09:21.840 --> 01:09:26.840]   Wir hatten doch den Scanner, hatten wir einen neuen Scanner produziert,
[01:09:26.840 --> 01:09:32.840]   der hier eben für uns den Input machte, das eben richtig gemachte.
[01:09:32.840 --> 01:09:34.840]   Und dann haben wir von dem Scanner gelesen.
[01:09:34.840 --> 01:09:38.840]   Und was, wenn ich jetzt von einer Datei lesen will, das mache ich dann,
[01:09:38.840 --> 01:09:41.840]   dann muss ich meinem Scanner halt sagen,
[01:09:41.840 --> 01:09:44.840]   der Scanner möge doch bitte nicht von dem Konsole lesen,
[01:09:44.840 --> 01:09:47.840]   von System.in, sondern von einem anderen Ort.
[01:09:47.840 --> 01:09:49.840]   Und wie mache ich das?
[01:09:49.840 --> 01:09:53.840]   Ich gehe hierhin, ich gebe zum Beispiel den Dateinamen Input.txt an,
[01:09:53.840 --> 01:09:58.840]   ich erstelle eine Handel, ein neues File Management Objekt
[01:09:58.840 --> 01:10:03.840]   und dann übergebe ich dieses Objekt an den Konstruktor,
[01:10:03.840 --> 01:10:06.840]   der den Scanner erstellen will.
[01:10:06.840 --> 01:10:11.840]   Und dann geht der hin und erstellt einen entsprechenden Scanner für uns,
[01:10:11.840 --> 01:10:18.840]   der jetzt aus dieser Datei eben die Daten ist.
[01:10:18.840 --> 01:10:20.840]   Und eben, wie jemand fragte,
[01:10:20.840 --> 01:10:26.840]   File ist eben auch eine Klasse, der New Operator erstellt eine Referenz
[01:10:26.840 --> 01:10:30.840]   auf irgend so ein File Objekt, das File Objekt,
[01:10:30.840 --> 01:10:33.840]   das sagt dann irgendwo eines der Attribute,
[01:10:33.840 --> 01:10:39.840]   wird dann sein eben welchen Namen der Betreffende angegeben hat,
[01:10:39.840 --> 01:10:44.840]   ob man das lesen oder schreiben darf, wie lang das ist,
[01:10:44.840 --> 01:10:47.840]   vielleicht eine Million Bytes oder so was,
[01:10:47.840 --> 01:10:50.840]   das alles wird in dieser Handel festgehalten.
[01:10:50.840 --> 01:10:54.840]   Und die gebe ich dem Scanner und das Scanner hat dann eben so einen Pointer
[01:10:54.840 --> 01:10:59.840]   und der weiß dann von wo er die nächste Zahl oder was auch immer abliefern muss.
[01:10:59.840 --> 01:11:03.840]   Und jetzt da das viele, das sind jetzt hier drei,
[01:11:03.840 --> 01:11:08.840]   zwei Schritte, die eben halt hier sehr oft zusammengefasst werden,
[01:11:08.840 --> 01:11:11.840]   die werden so zusammengefasst, ich will einen neuen Scanner,
[01:11:11.840 --> 01:11:16.840]   einen neuen Scanner, der soll hier für diese Datei erstellt werden,
[01:11:16.840 --> 01:11:23.840]   die hier durch diese File Handel, die ich jetzt hier on the fly konstruiere,
[01:11:23.840 --> 01:11:25.840]   erstellen möchte.
[01:11:25.840 --> 01:11:27.840]   So was finden Sie häufig in Programmen
[01:11:27.840 --> 01:11:31.840]   und dann können Sie natürlich da den Allfallnamen Ihrer Wahl einsetzen.
[01:11:31.840 --> 01:11:35.840]   Wo finden Sie jetzt mehr Dokumentation über den Scanner?
[01:11:35.840 --> 01:11:39.840]   Ja, können Sie eben den Dokumentation finden,
[01:11:39.840 --> 01:11:43.840]   sei es über irgendein Search Service oder irgendwas,
[01:11:43.840 --> 01:11:48.840]   der Java 11 Scanner ist der gleiche wie der Java 17 Scanner,
[01:11:48.840 --> 01:11:51.840]   da finden Sie dann Informationen über die Klasse Scanner
[01:11:51.840 --> 01:11:55.840]   und da finden Sie dann eben halt Informationen und so weiter,
[01:11:55.840 --> 01:11:57.840]   wie man damit arbeitet und so weiter.
[01:11:57.840 --> 01:12:00.840]   So, dann gibt es einiges mehr, da gibt es doch viel, viel mehr Text,
[01:12:00.840 --> 01:12:02.840]   den ich Ihnen gar nicht zeigen will.
[01:12:02.840 --> 01:12:05.840]   So, jetzt gibt es halt verschiedene Möglichkeiten,
[01:12:05.840 --> 01:12:07.840]   so einen Scanner zu konstruieren.
[01:12:07.840 --> 01:12:12.840]   Und da gibt es eben unterschiedliche Inputquellen
[01:12:12.840 --> 01:12:14.840]   und diese Inputquellen haben wir ja gesehen,
[01:12:14.840 --> 01:12:18.840]   die wurden dem Scanner als Parameter übergeben.
[01:12:18.840 --> 01:12:22.840]   Wir hatten einmal System.in, dem Scanner gesagt,
[01:12:22.840 --> 01:12:25.840]   wir wollen von System.in lesen
[01:12:25.840 --> 01:12:28.840]   und dann hat der Scanner aufgesetzt worden,
[01:12:28.840 --> 01:12:30.840]   um von der Konsole zu lesen
[01:12:30.840 --> 01:12:33.840]   oder wir sagen, der Scanner soll von der Datei lesen,
[01:12:33.840 --> 01:12:36.840]   die durch dieses File-Objekt beschrieben ist.
[01:12:36.840 --> 01:12:39.840]   So, und wenn wir das jetzt machen, da sehen wir halt hier,
[01:12:39.840 --> 01:12:41.840]   da sind verschiedene Optionen.
[01:12:41.840 --> 01:12:44.840]   Wir können eben einen Scanner haben, der uns aus einer File liest,
[01:12:44.840 --> 01:12:47.840]   wir können die Character-Sets ändern,
[01:12:47.840 --> 01:12:50.840]   wir können das ziemlich kompliziert,
[01:12:50.840 --> 01:12:55.840]   wir können unser System mit einem Western Key Set,
[01:12:55.840 --> 01:12:57.840]   also Buchstaben Set schreiben
[01:12:57.840 --> 01:13:02.840]   und dann Buchstaben in einem anderen Alphabet lesen.
[01:13:02.840 --> 01:13:04.840]   Da kann man alle viele Sachen machen,
[01:13:04.840 --> 01:13:06.840]   ist eigentlich nicht unser Problem.
[01:13:06.840 --> 01:13:08.840]   Wir nehmen den einfachsten Fall,
[01:13:08.840 --> 01:13:11.840]   dass wir einfach aus einer Datei lesen wollen.
[01:13:11.840 --> 01:13:14.840]   So, dann gucken wir uns an, aha, hier gibt es also die Regel,
[01:13:14.840 --> 01:13:18.840]   weitere Informationen über diesen Scanner,
[01:13:18.840 --> 01:13:21.840]   und da sind wir konstruiert, ein Scanner,
[01:13:21.840 --> 01:13:24.840]   der Werte dann eben liefern wird und so weiter.
[01:13:24.840 --> 01:13:28.840]   Und wenn wir das jetzt weitergucken, da sehen wir hier unten so eine Warnung.
[01:13:28.840 --> 01:13:33.840]   File Not Found Exceptions, die wird raus, wird geworfen,
[01:13:33.840 --> 01:13:37.840]   wenn die Quelle nicht gefunden wurde, was bedeutet das?
[01:13:37.840 --> 01:13:40.840]   Naja, jetzt können wir ja sagen, oh, mal gucken, was das ist.
[01:13:40.840 --> 01:13:44.840]   Wir könnten ja ein Programm schreiben, das sowas macht.
[01:13:44.840 --> 01:13:47.840]   Wir haben hier ein Programm, unser Main-Programm,
[01:13:47.840 --> 01:13:52.840]   unser anonymes Service-Programm, haben wir File I/O genannt.
[01:13:52.840 --> 01:13:54.840]   Hier haben wir die Main-Methode,
[01:13:54.840 --> 01:13:58.840]   und in dieser Main-Methode machen wir, was ich eben vorgestellt habe,
[01:13:58.840 --> 01:14:02.840]   und wir versuchen eben da, ein Scanner für diese Datei zu erstellen.
[01:14:02.840 --> 01:14:05.840]   Und wenn wir das machen, dann beschwert sich das System.
[01:14:05.840 --> 01:14:08.840]   Der beschwert sich konkreter Compiler
[01:14:08.840 --> 01:14:13.840]   und sagt, unhandled exception type, file not found exception.
[01:14:13.840 --> 01:14:18.840]   Und da gibt erfreulicherweise Eclipse bereits zwei Hilfsmöglichkeiten,
[01:14:18.840 --> 01:14:22.840]   und die erste da, add to host declaration,
[01:14:22.840 --> 01:14:24.840]   die werde ich jetzt noch gerade erklären.
[01:14:24.840 --> 01:14:27.840]   Die zweite Option, die muss später kommen.
[01:14:27.840 --> 01:14:30.840]   Da muss man noch ein paar mehr Sachen erklären,
[01:14:30.840 --> 01:14:33.840]   um das später anders zu machen.
[01:14:33.840 --> 01:14:36.840]   So, was geht hier vor oder was passiert?
[01:14:36.840 --> 01:14:39.840]   Also, Exceptions, hat ich schon mal gesagt,
[01:14:39.840 --> 01:14:42.840]   ist ein Fehler, der während der Laufzeit auftritt.
[01:14:42.840 --> 01:14:44.840]   Das ist eine Ausnahme.
[01:14:44.840 --> 01:14:46.840]   Es ist die Folge eines Fehlers,
[01:14:46.840 --> 01:14:49.840]   der erst zur Laufzeit festgestellt werden kann.
[01:14:49.840 --> 01:14:52.840]   Zum Beispiel, das hatten wir auch schon mal gesehen,
[01:14:52.840 --> 01:14:55.840]   wenn wir versuchen, eine ganze Zahl, also eine Int,
[01:14:55.840 --> 01:14:58.840]   durch 0 zu dividieren, das haut nicht hin.
[01:14:58.840 --> 01:15:00.840]   Da gibt es eben einen Fehler.
[01:15:00.840 --> 01:15:03.840]   Oder wenn wir versuchen, auf ein Array-Element zuzugreifen,
[01:15:03.840 --> 01:15:05.840]   das nicht existiert.
[01:15:05.840 --> 01:15:06.840]   Das haut auch nicht hin.
[01:15:06.840 --> 01:15:07.840]   Da gibt es auch einen Fehler.
[01:15:07.840 --> 01:15:09.840]   Oder wenn wir versuchen sollten,
[01:15:09.840 --> 01:15:12.840]   eine Nullreferenz zu de-referenzieren,
[01:15:12.840 --> 01:15:14.840]   dann gibt es auch einen Fehler.
[01:15:14.840 --> 01:15:16.840]   In all diesen Situationen,
[01:15:16.840 --> 01:15:18.840]   oder lesendes falschen Types,
[01:15:18.840 --> 01:15:23.840]   wenn wir in der Datei oder im Input eine Int erwarten,
[01:15:23.840 --> 01:15:25.840]   also eine ganze Zahl erwarten,
[01:15:25.840 --> 01:15:27.840]   und es kommt irgendein Text,
[01:15:27.840 --> 01:15:29.840]   dann gibt es auch eine Exception.
[01:15:29.840 --> 01:15:32.840]   In all diesen Situationen beschwert sich das System
[01:15:32.840 --> 01:15:34.840]   und genauso in dem Fall,
[01:15:34.840 --> 01:15:36.840]   wenn wir versuchen, aus einer Datei zu lesen,
[01:15:36.840 --> 01:15:38.840]   die nicht existiert.
[01:15:38.840 --> 01:15:40.840]   Und wenn wir jetzt versuchen sollten,
[01:15:40.840 --> 01:15:42.840]   aus so einer Datei zu lesen,
[01:15:42.840 --> 01:15:44.840]   dann stellt das System fest zur Laufzeit,
[01:15:44.840 --> 01:15:46.840]   dass die Datei gar nicht existiert.
[01:15:46.840 --> 01:15:48.840]   Und dann wird eine Exception generiert,
[01:15:48.840 --> 01:15:50.840]   das genauer, denn wir später,
[01:15:50.840 --> 01:15:52.840]   das ist auch wieder ein Objekt.
[01:15:52.840 --> 01:15:54.840]   Ein Objekt, das eben die Exception modelliert.
[01:15:54.840 --> 01:15:57.840]   Und diese Exception wird weitergereicht,
[01:15:57.840 --> 01:16:00.840]   bis irgendein Teil des Programms
[01:16:00.840 --> 01:16:02.840]   diese Exception bearbeiten kann.
[01:16:02.840 --> 01:16:04.840]   Vielleicht kann das das Programm selber,
[01:16:04.840 --> 01:16:07.840]   oder wenn das Programm das nicht kann,
[01:16:07.840 --> 01:16:10.840]   dann gibt es vielleicht jemand anders in der Umgebung,
[01:16:10.840 --> 01:16:12.840]   der das behandeln kann.
[01:16:12.840 --> 01:16:15.840]   Und das ist das, was wir Werfen nennen.
[01:16:15.840 --> 01:16:19.840]   Das Programm generiert die Exception
[01:16:19.840 --> 01:16:21.840]   und reicht sie weiter.
[01:16:21.840 --> 01:16:23.840]   Das nennen wir Werfen.
[01:16:23.840 --> 01:16:25.840]   Die Exception wird geworfen.
[01:16:25.840 --> 01:16:27.840]   Und jetzt gucken wir mal,
[01:16:27.840 --> 01:16:29.840]   welcher Teil des Programms ist in der Lage,
[01:16:29.840 --> 01:16:31.840]   diese Exception zu behandeln,
[01:16:31.840 --> 01:16:34.840]   also ist es in der Lage, die aufzufangen.
[01:16:34.840 --> 01:16:36.840]   Also hier haben wir ein Beispiel,
[01:16:36.840 --> 01:16:38.840]   so wie es bisher, unser Main-Programm.
[01:16:38.840 --> 01:16:40.840]   Da haben wir eine Methode FU.
[01:16:40.840 --> 01:16:43.840]   Die Methode FU ruft eine Methode BAR auf.
[01:16:43.840 --> 01:16:46.840]   Und jetzt geht unser Programm hin
[01:16:46.840 --> 01:16:49.840]   und führt das Main aus, ruft FU auf,
[01:16:49.840 --> 01:16:52.840]   dann wird erst Main aufgerufen, dann FU,
[01:16:52.840 --> 01:16:54.840]   dann wird BAR aufgerufen
[01:16:54.840 --> 01:16:56.840]   und dann wird das Programm ausgeführt.
[01:16:56.840 --> 01:16:58.840]   Und dann geht es eben wieder zurück
[01:16:58.840 --> 01:17:00.840]   und dann geht es zurück und dann geht es zurück
[01:17:00.840 --> 01:17:02.840]   und dann sind wir fertig.
[01:17:02.840 --> 01:17:04.840]   Und jetzt ist der normale Fluss
[01:17:04.840 --> 01:17:06.840]   unseres Methoden aufruft.
[01:17:06.840 --> 01:17:08.840]   Wenn wir jetzt aber hingingen
[01:17:08.840 --> 01:17:10.840]   und diese Methode hier ändern
[01:17:10.840 --> 01:17:12.840]   und zwar dahingehend ändern,
[01:17:12.840 --> 01:17:14.840]   dass wir hier versuchen,
[01:17:14.840 --> 01:17:16.840]   durch Null zu dividieren,
[01:17:16.840 --> 01:17:18.840]   dann, naja, was passiert?
[01:17:18.840 --> 01:17:20.840]   Am Anfang ist alles noch genau so.
[01:17:20.840 --> 01:17:22.840]   Und wir kommen jetzt zu dem Punkt,
[01:17:22.840 --> 01:17:24.840]   dass die Division durch Null gemacht wird.
[01:17:24.840 --> 01:17:26.840]   Da wird eben eine Exception festgestellt.
[01:17:26.840 --> 01:17:28.840]   Da ist ein Fehler aufgetreten.
[01:17:28.840 --> 01:17:30.840]   Und jetzt im nächsten Moment,
[01:17:30.840 --> 01:17:33.840]   wenn jemand von diesen anderen Methoden in der Lage ist,
[01:17:33.840 --> 01:17:35.840]   diesen Fehler zu beheben,
[01:17:35.840 --> 01:17:37.840]   springen wir sofort zu einem Punkt,
[01:17:37.840 --> 01:17:40.840]   außerhalb dieser drei Methoden hin.
[01:17:40.840 --> 01:17:43.840]   Das heißt, da wird dann hoffentlich jemand sein,
[01:17:43.840 --> 01:17:45.840]   der diese Exception aufhängt.
[01:17:45.840 --> 01:17:48.840]   Und das ist das Thema hoffentlich so aufgesetzt,
[01:17:48.840 --> 01:17:52.840]   dass da die Exception gefangen werden kann.
[01:17:52.840 --> 01:17:55.840]   Und Java bemüht sich eben zu verhindern,
[01:17:55.840 --> 01:17:57.840]   dass da irgendwelche Kontrolltransfer stattfinden,
[01:17:57.840 --> 01:17:59.840]   die man nicht vorher gesehen hat.
[01:17:59.840 --> 01:18:01.840]   Und daher ist das System so aufgesetzt,
[01:18:01.840 --> 01:18:03.840]   dass wir für jede Exception
[01:18:03.840 --> 01:18:06.840]   irgendwo einen Handler haben müssen,
[01:18:06.840 --> 01:18:08.840]   also einen Programmsegment haben müssen,
[01:18:08.840 --> 01:18:10.840]   dass diese Exception bearbeitet.
[01:18:10.840 --> 01:18:13.840]   Es gibt bei den Exceptions zwei große Gruppen.
[01:18:13.840 --> 01:18:15.840]   Da gibt es einmal Exceptions,
[01:18:15.840 --> 01:18:18.840]   die müssen vom Programm aufgefangen werden.
[01:18:18.840 --> 01:18:21.840]   Und die müssen einfach aufgefangen werden.
[01:18:21.840 --> 01:18:23.840]   Es gibt andere Exceptions,
[01:18:23.840 --> 01:18:26.840]   wie zum Beispiel, dass die Batterie aufgehört hat,
[01:18:26.840 --> 01:18:28.840]   oder dass irgendwie der Prozessor nicht mehr funktioniert.
[01:18:28.840 --> 01:18:31.840]   Da kann das Programm nichts machen.
[01:18:31.840 --> 01:18:33.840]   Und da erwarten wir auch nichts.
[01:18:33.840 --> 01:18:35.840]   Aber viele Exceptions, so wie Nullreferenz oder so,
[01:18:35.840 --> 01:18:39.840]   da erwarten wir, dass das Programm die eigentlich aufhängt.
[01:18:39.840 --> 01:18:42.840]   Jetzt gibt es Exceptions, die können überall auftreten.
[01:18:42.840 --> 01:18:46.840]   Eben wie die Division durch Null,
[01:18:46.840 --> 01:18:50.840]   oder das De-referenzieren von Null, oder solche Sachen.
[01:18:50.840 --> 01:18:54.840]   Und auf diese Exceptions ist das Java-System vorbereitet.
[01:18:54.840 --> 01:18:56.840]   Das heißt, das Java-System hat dafür gesorgt,
[01:18:56.840 --> 01:18:58.840]   dass wenn sie durch Null dividieren,
[01:18:58.840 --> 01:19:01.840]   irgendwer geht hin und wird das dann entsprechend auffangen
[01:19:01.840 --> 01:19:03.840]   und damit bearbeiten.
[01:19:03.840 --> 01:19:06.840]   Und dann gibt es andere Exceptions,
[01:19:06.840 --> 01:19:11.840]   und das sind die, die eben was komplizierteren sind,
[01:19:11.840 --> 01:19:13.840]   da weiß das System nicht,
[01:19:13.840 --> 01:19:15.840]   dass so eine Exception auftreten kann.
[01:19:15.840 --> 01:19:18.840]   Das heißt, das System braucht Hilfe,
[01:19:18.840 --> 01:19:21.840]   um zu wissen, wie eine solche Exception behandelt wird.
[01:19:21.840 --> 01:19:25.840]   Es ist nicht so, dass alle Programme aus einer Datei lesen.
[01:19:25.840 --> 01:19:28.840]   Daher die Exception, dass die Datei nicht da ist,
[01:19:28.840 --> 01:19:30.840]   ist nicht eine von den Exceptions,
[01:19:30.840 --> 01:19:32.840]   auf die das System bereits vorbereitet ist.
[01:19:32.840 --> 01:19:37.840]   Daher müssen wir dem System helfen, diese Exception zu managen.
[01:19:37.840 --> 01:19:43.840]   So, und diese Exceptions, für die das System mehr Informationen braucht,
[01:19:43.840 --> 01:19:51.840]   die nennen wir CheckedExceptions, überprüfte Ausnahmen.
[01:19:51.840 --> 01:19:54.840]   Das sind Ausnahmen, die das System noch überprüfen wird,
[01:19:54.840 --> 01:19:58.840]   bevor es zulässt, dass wir mit solchen Ausnahmen arbeiten.
[01:19:58.840 --> 01:20:01.840]   Und wer prüft hier natürlich der Compiler?
[01:20:01.840 --> 01:20:07.840]   Der Compiler prüft, ob eine Exception entweder lokal aufgefangen wird,
[01:20:07.840 --> 01:20:09.840]   dann ist der Compiler zufrieden.
[01:20:09.840 --> 01:20:12.840]   Oder, dass die aufgerufene Methode angibt,
[01:20:12.840 --> 01:20:15.840]   dass eine Exception auftreten kann.
[01:20:15.840 --> 01:20:17.840]   Dann ist der Compiler auch zufrieden,
[01:20:17.840 --> 01:20:20.840]   weil, wenn eine Methode sagt, ich bin in der Lage,
[01:20:20.840 --> 01:20:22.840]   ich reiche diese Exception weiter
[01:20:22.840 --> 01:20:25.840]   und irgendjemand anders ist bereit, die zu bearbeiten,
[01:20:25.840 --> 01:20:28.840]   dann weiß der Compiler, dass es irgendwo einen Teil gibt,
[01:20:28.840 --> 01:20:30.840]   der das bearbeiten wird.
[01:20:30.840 --> 01:20:33.840]   Daher muss der Checked der Compiler,
[01:20:33.840 --> 01:20:36.840]   ob solche Exceptions richtig aufgesetzt wurden.
[01:20:36.840 --> 01:20:38.840]   Wenn das nicht der Fall ist,
[01:20:38.840 --> 01:20:40.840]   dann beschwert sich der Compiler und sagt,
[01:20:40.840 --> 01:20:42.840]   dieses Programm können wir nicht übersetzen.
[01:20:42.840 --> 01:20:43.840]   Das haben Sie gesehen.
[01:20:43.840 --> 01:20:46.840]   Vorhin gibt es eben diese Error Message,
[01:20:46.840 --> 01:20:49.840]   UnhandledExceptionType, FileNotFoundException,
[01:20:49.840 --> 01:20:51.840]   wissen wir nicht, was wir damit machen können,
[01:20:51.840 --> 01:20:53.840]   und da müssen wir irgendetwas unternehmen.
[01:20:53.840 --> 01:20:57.840]   Wir müssen festlegen, wie unser Programm
[01:20:57.840 --> 01:20:59.840]   mit I/O-Problemen umgeht,
[01:20:59.840 --> 01:21:03.840]   weil sonst weiß das ja das System nicht.
[01:21:03.840 --> 01:21:06.840]   Jetzt gibt es eben zwei Möglichkeiten,
[01:21:06.840 --> 01:21:08.840]   die eine ist, selber lokal zu machen
[01:21:08.840 --> 01:21:11.840]   oder einfach die Arbeit zu delegieren,
[01:21:11.840 --> 01:21:13.840]   an jemand anders.
[01:21:13.840 --> 01:21:16.840]   Das ist dieser Vorschlag, eine AdSrose-Deklaration,
[01:21:16.840 --> 01:21:20.840]   eine AdSrose-Deklaration dazu zu fügen.
[01:21:20.840 --> 01:21:22.840]   Das ist eine Ankündigung,
[01:21:22.840 --> 01:21:25.840]   die ich bei der Deklaration einer Methode mache,
[01:21:25.840 --> 01:21:29.840]   wo ich sage, diese Methode könnte diese Exception
[01:21:29.840 --> 01:21:31.840]   eben generieren,
[01:21:31.840 --> 01:21:34.840]   oder die könnte von woanders her kommen,
[01:21:34.840 --> 01:21:37.840]   und diese Methode wird diese Exception
[01:21:37.840 --> 01:21:40.840]   nicht selber auffangen.
[01:21:40.840 --> 01:21:43.840]   Das heißt, wer immer diese Methode aufruft,
[01:21:43.840 --> 01:21:47.840]   muss dafür sorgen, dass die Exceptions bearbeitet wird.
[01:21:47.840 --> 01:21:49.840]   Wer die Methode aufruft,
[01:21:49.840 --> 01:21:51.840]   muss diese Exception entweder fangen
[01:21:51.840 --> 01:21:54.840]   oder wiederum ankündigen,
[01:21:54.840 --> 01:21:56.840]   bis es eben ganz nach oben geht
[01:21:56.840 --> 01:21:59.840]   und ganz nach oben, also im Jahressystem,
[01:21:59.840 --> 01:22:01.840]   ist man natürlich vorbereitet,
[01:22:01.840 --> 01:22:03.840]   alle Arten von Exceptions,
[01:22:03.840 --> 01:22:05.840]   die behandelt werden können,
[01:22:05.840 --> 01:22:08.840]   in irgendeiner Form aufzufangen.
[01:22:08.840 --> 01:22:11.840]   Das heißt also, in unserer Methode,
[01:22:11.840 --> 01:22:14.840]   wenn wir eine Methode, eine Static Methode haben,
[01:22:14.840 --> 01:22:17.840]   dann würden wir dahinterher schreiben,
[01:22:17.840 --> 01:22:19.840]   "Srose-Type",
[01:22:19.840 --> 01:22:22.840]   oder genauso, wenn wir irgendeine andere Methode
[01:22:22.840 --> 01:22:24.840]   später mal schreiben,
[01:22:24.840 --> 01:22:27.840]   die wir auch ankündigen müssen,
[01:22:27.840 --> 01:22:30.840]   da würden wir eben schreiben,
[01:22:30.840 --> 01:22:33.840]   dass diese Methode eine solche Exception generieren kann.
[01:22:33.840 --> 01:22:36.840]   Und dann danach erst kommen die Geschweifeklammern,
[01:22:36.840 --> 01:22:39.840]   in denen der Body der Methode ist.
[01:22:39.840 --> 01:22:41.840]   Und dann ist eben halt,
[01:22:41.840 --> 01:22:44.840]   und natürlich Type muss ein Exception-Typ sein,
[01:22:44.840 --> 01:22:47.840]   da kann nicht irgendein beliebiger Typ sein,
[01:22:47.840 --> 01:22:50.840]   sondern eben die Art der Exception,
[01:22:50.840 --> 01:22:53.840]   die geworfen werden kann.
[01:22:53.840 --> 01:22:56.840]   Das gilt für Methode, gilt für die Art,
[01:22:56.840 --> 01:22:59.840]   wie wir Objekte konstruieren und so weiter.
[01:22:59.840 --> 01:23:02.840]   Da muss das eben, wenn das angekündigt wird,
[01:23:02.840 --> 01:23:05.840]   müssen wir damit arbeiten.
[01:23:05.840 --> 01:23:08.840]   Also wenn ich sage, hier gibt es einen Weg,
[01:23:08.840 --> 01:23:11.840]   eine Objekt zu deklarieren,
[01:23:11.840 --> 01:23:14.840]   dann kann ich sagen, aber diese Deklaration
[01:23:14.840 --> 01:23:17.840]   wirft eventuell eine solche Exception.
[01:23:17.840 --> 01:23:20.840]   Und das ist das, was wir vorher gesehen haben.
[01:23:20.840 --> 01:23:23.840]   Als wir gesehen haben,
[01:23:23.840 --> 01:23:26.840]   dass dieser Weg den Scanner zu konstruieren,
[01:23:26.840 --> 01:23:29.840]   indem wir eben halt,
[01:23:29.840 --> 01:23:32.840]   wenn wir eine Datei als Datenquelle übergeben,
[01:23:32.840 --> 01:23:35.840]   da ist es eben möglich,
[01:23:35.840 --> 01:23:38.840]   der Versuch, einen solchen Scanner zu konstruieren,
[01:23:38.840 --> 01:23:41.840]   dass der eben eine solche Exception generieren wird.
[01:23:41.840 --> 01:23:44.840]   Und das heißt eben,
[01:23:44.840 --> 01:23:47.840]   die wird auftreten,
[01:23:47.840 --> 01:23:50.840]   wenn diese Datei, mit der wir arbeiten wollen,
[01:23:50.840 --> 01:23:53.840]   nicht existiert.
[01:23:53.840 --> 01:23:56.840]   Da steht dieses Thrust,
[01:23:56.840 --> 01:23:59.840]   das heißt, wer immer den New-Operator
[01:23:59.840 --> 01:24:02.840]   mit dieser Form von Konstruktionsanweisung verbinden will,
[01:24:02.840 --> 01:24:05.840]   dann muss sich eben um diese Exceptions kümmern.
[01:24:05.840 --> 01:24:08.840]   Und das können wir einfach machen,
[01:24:08.840 --> 01:24:11.840]   indem wir einfach hier dieses dazufügen.
[01:24:11.840 --> 01:24:14.840]   Wir sagen unsere Methode Main,
[01:24:14.840 --> 01:24:17.840]   die wirft auch möglicherweise eine FileNotFoundException.
[01:24:17.840 --> 01:24:20.840]   Wir hoffen ja nicht, dass das passiert,
[01:24:20.840 --> 01:24:23.840]   weil wir werden ja hoffentlich immer nur Dateinamen geben,
[01:24:23.840 --> 01:24:26.840]   die auch existieren.
[01:24:26.840 --> 01:24:29.840]   Aber sollte es mal einen Dateinamen geben, der nicht existiert,
[01:24:29.840 --> 01:24:32.840]   dann wird das passieren und das System ist darauf vorbereitet.
[01:24:32.840 --> 01:24:35.840]   Dann ist der Compiler zufrieden, das System ist zufrieden,
[01:24:35.840 --> 01:24:38.840]   die Methode funktioniert, alles wird richtig aufgesetzt und so weiter.
[01:24:38.840 --> 01:24:41.840]   Nicht alle Konstruktoren hatten das Problem.
[01:24:41.840 --> 01:24:44.840]   Deswegen, wenn wir einen Input-Stream hatten,
[01:24:44.840 --> 01:24:47.840]   wie den System.in, da kann das nicht passieren.
[01:24:47.840 --> 01:24:50.840]   Und deswegen konnten wir eben auch ein Scanner
[01:24:50.840 --> 01:24:53.840]   vor System.in erstellen.
[01:24:53.840 --> 01:24:56.840]   Und jetzt doch ganz einfach drei Worte zum Thema Output.
[01:24:56.840 --> 01:24:59.840]   Jetzt haben wir so eine Datei.
[01:24:59.840 --> 01:25:02.840]   Wie können wir da schreiben?
[01:25:02.840 --> 01:25:05.840]   Da gibt es auch wieder einen guten Service, den wir auch benutzen können.
[01:25:05.840 --> 01:25:08.840]   Nämlich die Printstream-Klasse.
[01:25:08.840 --> 01:25:11.840]   Das ist eine andere Service, der es uns erlaubt,
[01:25:11.840 --> 01:25:14.840]   Daten elegant und einfach in eine Datei auszugeben.
[01:25:14.840 --> 01:25:17.840]   Und all die Operationen, die wir von System.out kennen,
[01:25:17.840 --> 01:25:20.840]   die funktionieren auch mit Printstream.
[01:25:20.840 --> 01:25:23.840]   Also Print, PrintLine.
[01:25:23.840 --> 01:25:26.840]   Das ist das, was wir vorher gesehen haben.
[01:25:26.840 --> 01:25:29.840]   Müssen wir natürlich importieren.
[01:25:29.840 --> 01:25:32.840]   Aber ich gehe hierhin, ich habe wieder meinen
[01:25:32.840 --> 01:25:35.840]   Filehandel für die File, die ich haben will.
[01:25:35.840 --> 01:25:38.840]   Und dann gehe ich hin und möchte gerne einen neuen
[01:25:38.840 --> 01:25:41.840]   Printstream haben.
[01:25:41.840 --> 01:25:44.840]   Ein Printstream, der mit dieser File arbeitet.
[01:25:44.840 --> 01:25:47.840]   Oder eben kompakt hier, alles auf einer Stile.
[01:25:47.840 --> 01:25:50.840]   Ein Printstream, der mit dieser Datei arbeitet.
[01:25:50.840 --> 01:25:53.840]   Wenn ich das habe, dann ja, wie hatten wir vorgedruckt?
[01:25:53.840 --> 01:25:56.840]   Wir hatten hier unseren Loop, der zum Beispiel
[01:25:56.840 --> 01:25:59.840]   irgendwas zehnmal das trockt.
[01:25:59.840 --> 01:26:02.840]   Das ging durch System.out.
[01:26:02.840 --> 01:26:05.840]   Und jetzt gehen wir hin und definieren uns eben
[01:26:05.840 --> 01:26:08.840]   einen entsprechenden Printstream, den wir vielleicht den Namen
[01:26:08.840 --> 01:26:11.840]   FileOutput geben.
[01:26:11.840 --> 01:26:14.840]   Und jetzt brauchen wir hingehen und ersetzen das System.out
[01:26:14.840 --> 01:26:17.840]   durch den FileOutputstream, den wir hier oben konstruiert haben.
[01:26:17.840 --> 01:26:20.840]   Und dann können wir genauso wie wir zum Standard Output,
[01:26:20.840 --> 01:26:23.840]   also zum Konsolidrucken, können wir jetzt
[01:26:23.840 --> 01:26:26.840]   eine Datei auserschreiben.
[01:26:26.840 --> 01:26:29.840]   Und der Schöne ist, wenn die Datei nicht existiert,
[01:26:29.840 --> 01:26:32.840]   dann wird sie erstellt.
[01:26:32.840 --> 01:26:35.840]   So können wir also unsere eigenen Daten da schreiben.
[01:26:35.840 --> 01:26:38.840]   Natürlich nichts ist umsonst.
[01:26:38.840 --> 01:26:41.840]   Was passiert nämlich, wenn sie existiert?
[01:26:41.840 --> 01:26:44.840]   Naja, wenn sie existiert, die Datei, dann wird sie überschrieben.
[01:26:44.840 --> 01:26:47.840]   Und dann wird sie auf die Datei gesagt.
[01:26:47.840 --> 01:26:50.840]   Wir wollen hier auf diese Datei, wollen wir jetzt schreiben.
[01:26:50.840 --> 01:26:53.840]   Und darum eben müssen wir aufpassen.
[01:26:53.840 --> 01:26:56.840]   Wenn wir eben sehen wollen, was da gemacht ist,
[01:26:56.840 --> 01:26:59.840]   müssen wir in Eclipse refresh machen.
[01:26:59.840 --> 01:27:02.840]   Dann wird die Datei, wird,
[01:27:02.840 --> 01:27:05.840]   refreshed das System sich.
[01:27:05.840 --> 01:27:08.840]   Und dann können wir auf die Datei gucken.
[01:27:08.840 --> 01:27:11.840]   Und dann sollte die Datei, wenn die jetzt Output text hieß,
[01:27:11.840 --> 01:27:14.840]   dann wird sie auf die Datei geöffnet.
[01:27:14.840 --> 01:27:17.840]   Da würden sie die dann finden und würden die dann entsprechend
[01:27:17.840 --> 01:27:20.840]   aus, würden sie dann sehen.
[01:27:20.840 --> 01:27:23.840]   Da würden sie dann das 10 mal sehen.
[01:27:23.840 --> 01:27:26.840]   Also, wie gesagt, Prinzt Trem, ja, ist sehr komfortabel.
[01:27:26.840 --> 01:27:29.840]   Beliebter Fehler ist,
[01:27:29.840 --> 01:27:32.840]   eine Datei zum Schreiben öffnen, die Methode mehrfach ausführen,
[01:27:32.840 --> 01:27:35.840]   dann wird die Datei mehrfach geöffnet.
[01:27:35.840 --> 01:27:38.840]   Aber der alte Inhalt G von Ohren,
[01:27:38.840 --> 01:27:41.840]   die wir hier gefunden haben, ist sehr komfortabel.
[01:27:41.840 --> 01:27:44.840]   Das ist ein sehr komfortabeles Problem.
[01:27:44.840 --> 01:27:47.840]   Das ist ein sehr komfortabeles Problem.
[01:27:47.840 --> 01:27:50.840]   Das ist ein sehr komfortabeles Problem.
[01:27:50.840 --> 01:27:53.840]   Das ist ein sehr komfortabeles Problem.
[01:27:53.840 --> 01:27:56.840]   Das ist ein sehr komfortabeles Problem.
[01:27:56.840 --> 01:27:59.840]   Das ist ein sehr komfortabeles Problem.

