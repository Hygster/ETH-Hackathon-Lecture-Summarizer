
[00:00:00.000 --> 00:00:06.000]   Wir haben ja verschiedene kleinere technische Probleme.
[00:00:06.000 --> 00:00:09.000]   Was könnte am Freitag den 3C noch alles schief gehen?
[00:00:09.000 --> 00:00:14.000]   Wir werden versuchen, hoffentlich alles so hinzubekommen, dass es funktioniert.
[00:00:14.000 --> 00:00:20.000]   Unser heutiges Thema ist, wir fangen damit mal an, dass wir nochmal das Thema Schleifen uns angucken.
[00:00:20.000 --> 00:00:25.000]   Aber bevor ich das mache, wo ich noch kurz ein paar Berichtigungen oder Erläutungen geben zu dem,
[00:00:25.000 --> 00:00:29.000]   was ich letzte und vorletzte Folie und Gesagt habe.
[00:00:29.000 --> 00:00:34.000]   In der letzten Vorlesung war natürlich ein Cut- und Paid-Feder gewesen.
[00:00:34.000 --> 00:00:40.000]   Natürlich müssen wir, wenn wir die ganze String abarbeiten,
[00:00:40.000 --> 00:00:48.000]   dann müssen wir dafür sorgen, dass eben der eine Teil von 0 bis 3, das heißt bis 2 einschließlich,
[00:00:48.000 --> 00:00:53.000]   und der andere Aufruf von 3 ab aufwärts,
[00:00:53.000 --> 00:00:58.000]   diesen String oder diese Teil des Trings bearbeitet, das heißt da unten darf kein plus 1 stehen,
[00:00:58.000 --> 00:01:03.000]   sondern da muss einfach der Selberausdruck erscheinen, wie da oben.
[00:01:03.000 --> 00:01:07.000]   Und dann war die einigen Übungsgruppenkampf zur Sprache oder meinten einige Studierende,
[00:01:07.000 --> 00:01:11.000]   ich hätte gesagt, dass TRU wäre die stärkste Vorbedingung, das stimmt natürlich nicht,
[00:01:11.000 --> 00:01:13.000]   das habe ich mir wahrscheinlich versprochen.
[00:01:13.000 --> 00:01:19.000]   Ich glaube, was ich sagen wollte war folgendes, sehen Sie, wenn Sie ein ausländiges Triple haben,
[00:01:19.000 --> 00:01:22.000]   von der Art TRU, Statement S und Q.
[00:01:22.000 --> 00:01:27.000]   Das ist schon eine wichtige Aussage, vielleicht habe ich das Wort stark da verwendet,
[00:01:27.000 --> 00:01:30.000]   das könnte auch sein, eine wichtige Aussage, warum,
[00:01:30.000 --> 00:01:35.000]   weil die sagt uns, egal welchen Zustand wir vor dem Statement S haben,
[00:01:35.000 --> 00:01:39.000]   danach nach der Ausführung von S gilt die Aussage Q.
[00:01:39.000 --> 00:01:42.000]   Das heißt wir brauchen uns insbesondere keine Gedanken machen,
[00:01:42.000 --> 00:01:49.000]   was eben passiert, wie wir überhaupt dieses Statement S erreichen.
[00:01:49.000 --> 00:01:53.000]   Deswegen ist das eine wichtige Aussage, und das heißt aber nicht,
[00:01:53.000 --> 00:01:59.000]   dass TRU die stärkste Aussage, die stärkste Vorbedingung ist, das ist nicht richtig,
[00:01:59.000 --> 00:02:02.000]   weil Vorbedingungen sind nicht unbedingt vergleichbar.
[00:02:02.000 --> 00:02:06.000]   Wenn Sie eine Vorbedingung haben, die sagt X ist größer 5
[00:02:06.000 --> 00:02:10.000]   und eine andere, die sagt X ist ungleich 9,
[00:02:10.000 --> 00:02:14.000]   das sind zwei Vorbedingungen, P1 und P2.
[00:02:14.000 --> 00:02:20.000]   Und weder ist P1, P1 ist nicht stärker als P2, das gilt nicht,
[00:02:20.000 --> 00:02:24.000]   und P2 ist auch nicht stärker als P1.
[00:02:24.000 --> 00:02:28.000]   Also solche Aussagen sind nicht immer unbedingt vergleichbar
[00:02:28.000 --> 00:02:35.000]   und können nicht immer eben sagen, eine ist stärker als die andere.
[00:02:35.000 --> 00:02:37.000]   Also und daher, ich hoffe, das habe ich nicht verwirkt.
[00:02:37.000 --> 00:02:41.000]   Und dann habe ich auf dem Chat verschiedene Fragen gesehen
[00:02:41.000 --> 00:02:50.000]   zum Thema dieser Post- und Prieinkrement-Operationen.
[00:02:50.000 --> 00:02:55.000]   Sehen Sie, wenn wir so einen Statement uns angucken
[00:02:55.000 --> 00:02:59.000]   im Compiler-Laufsatzsystem, da geht der Compiler nicht hin,
[00:02:59.000 --> 00:03:02.000]   guckt sie da, hier ist ein A und da ist ein B,
[00:03:02.000 --> 00:03:04.000]   ach, da kommt noch ein C.
[00:03:04.000 --> 00:03:07.000]   Das ist eine andere, da ist eine Multiplikation.
[00:03:07.000 --> 00:03:10.000]   Da gibt es eine Datenstruktur, die zum Beispiel sagt, ach,
[00:03:10.000 --> 00:03:13.000]   wir wollen ein Plus machen und da wollen wir A
[00:03:13.000 --> 00:03:16.000]   und da wollen wir hier als einen Operanten haben
[00:03:16.000 --> 00:03:19.000]   und die B und C als andere Operanten.
[00:03:19.000 --> 00:03:21.000]   Und wenn ich jetzt sage, ach, hier habe ich so eine Zuweisung,
[00:03:21.000 --> 00:03:23.000]   okay, hier habe ich eine Zuweisung
[00:03:23.000 --> 00:03:25.000]   und das heißt, das Ergebnis der Zuweisung
[00:03:25.000 --> 00:03:28.000]   wird dann in der Variable Z gespeichert.
[00:03:28.000 --> 00:03:29.000]   So, ja.
[00:03:29.000 --> 00:03:31.000]   Wenn ich jetzt aber hingehe
[00:03:31.000 --> 00:03:44.000]   zum Beispiel dieses B plus Plus-Inkrement verwenden will,
[00:03:44.000 --> 00:03:47.000]   dann geht das System hin und verwendet noch mehr in dem Grafen.
[00:03:47.000 --> 00:03:50.000]   Ach, hier soll das B verwendet werden.
[00:03:50.000 --> 00:03:55.000]   Aber das B soll ja auch noch jetzt hier um eins erhöht werden
[00:03:55.000 --> 00:03:58.000]   und das soll auch wieder in B gespeichert werden.
[00:03:58.000 --> 00:04:01.000]   Und dann geht das System hin und sagt sich, ha, hier muss ich aufpassen.
[00:04:01.000 --> 00:04:06.000]   Also, diese Speicherung, die darf erst passieren,
[00:04:06.000 --> 00:04:10.000]   nachdem dieser Operant gelesen wurde.
[00:04:10.000 --> 00:04:13.000]   Die Addition kann vielleicht schon stattfinden.
[00:04:13.000 --> 00:04:16.000]   Und so weiß das System dann, ja, ich muss also erst das machen,
[00:04:16.000 --> 00:04:18.000]   dann das, dann das, dann das, ja.
[00:04:18.000 --> 00:04:23.000]   Und dann erst wird das eben halt richtig gespeichert.
[00:04:23.000 --> 00:04:27.000]   Es geht eben, wenn Sie eben A wird gesetzt zu A plus Plus, ja,
[00:04:27.000 --> 00:04:30.000]   dann ist da eben auch so eine Konstruktion.
[00:04:30.000 --> 00:04:34.000]   Wir haben hier A, wir haben hier A plus Plus, ja.
[00:04:34.000 --> 00:04:37.000]   Und wir haben hier nochmal das System,
[00:04:37.000 --> 00:04:41.000]   weiß dann schon, in welcher Reihenfolge die verschiedenen
[00:04:41.000 --> 00:04:45.000]   Operationen ausgeführt werden dürfen oder nicht.
[00:04:45.000 --> 00:04:50.000]   Also, lassen Sie sich nicht von der einfachen textuellen Darstellung verwirren.
[00:04:50.000 --> 00:04:52.000]   Lesen Sie das nicht einfach so, wie Sie das wollen.
[00:04:52.000 --> 00:04:55.000]   Deswegen, mein Ratschlag, machen Sie es nicht.
[00:04:55.000 --> 00:04:58.000]   Ja, sehen Sie, es ist wirklich toll, wenn Sie, hier haben wir,
[00:04:58.000 --> 00:05:05.000]   hier haben wir diesen Ausdruck Y, ist Plus Plus B, also Prieinkrement B,
[00:05:05.000 --> 00:05:08.000]   mal A plus Prieinkrement B, ja.
[00:05:08.000 --> 00:05:12.000]   Wenn ich das in der Reihenfolge mache für die Werte A und B,
[00:05:12.000 --> 00:05:16.000]   A, 2 und B, 1, bekomme ich 7.
[00:05:16.000 --> 00:05:21.000]   Wenn ich die Reihenfolge vertausche, das ist ja wirklich ein Morgs,
[00:05:21.000 --> 00:05:23.000]   wie Sie sich das hier denken.
[00:05:23.000 --> 00:05:25.000]   Das tut mir leid.
[00:05:25.000 --> 00:05:27.000]   Also, ich komme einfach mit dem, ich komme mit meinem Stiften,
[00:05:27.000 --> 00:05:29.000]   ich kann nicht überall schreiben.
[00:05:29.000 --> 00:05:32.000]   Daran habe ich natürlich beim Design der Slides nicht gedacht.
[00:05:32.000 --> 00:05:35.000]   Also, wenn Sie sich die beiden angucken, ja,
[00:05:35.000 --> 00:05:37.000]   die sind eigentlich, würden wir ja denken,
[00:05:37.000 --> 00:05:42.000]   dass der komutative Aditionsapparator wirklich in beiden Fällen das Gleiche bringt.
[00:05:42.000 --> 00:05:46.000]   Aber nein, aufgrund dieser Prieinkrement-Operationen
[00:05:46.000 --> 00:05:48.000]   ist das dann eben unterschiedlich.
[00:05:48.000 --> 00:05:51.000]   Daher machen Sie sowas nicht, weil es ist extrem verwirrend, ja,
[00:05:51.000 --> 00:05:54.000]   dass das und diese beiden Ausdrücke für dieselben Werte
[00:05:54.000 --> 00:05:58.000]   unterschiedliche Ergebnisse liefern, das ist wirklich nicht gut.
[00:05:58.000 --> 00:06:01.000]   Deswegen machen Sie es nicht, ist ja, denn Sie brauchen es wirklich,
[00:06:01.000 --> 00:06:03.000]   oder Sie wissen genau, was Sie machen, ja.
[00:06:03.000 --> 00:06:07.000]   So, okay, jetzt zum Thema eben noch mehr Schleifen.
[00:06:07.000 --> 00:06:10.000]   Und da kommen wir zum ersten Thema,
[00:06:10.000 --> 00:06:12.000]   dass wir haben die Terminierung, ja.
[00:06:12.000 --> 00:06:14.000]   Und eine einfache Aufgabe für Sie,
[00:06:14.000 --> 00:06:17.000]   Sie wollen ein Programm schreiben und eine Methode schreiben,
[00:06:17.000 --> 00:06:21.000]   die Zahlen von 1 bis N durch Komma getrennt ausgibt, ja.
[00:06:21.000 --> 00:06:23.000]   Und irgendeine Obergrenze wird eingegeben
[00:06:23.000 --> 00:06:27.000]   und dann sollte das System ausgeben, 1,2 und so weiter, ja.
[00:06:27.000 --> 00:06:29.000]   So, und das wäre natürlich nicht zu...
[00:06:29.000 --> 00:06:32.000]   Das können Sie sofort machen, ist nicht sehr schwierig, ja.
[00:06:32.000 --> 00:06:37.000]   Also, wir brauchen da klar ein Scanner, da lesen wir die Anzahl, die Zahl, ja.
[00:06:37.000 --> 00:06:41.000]   Und dann gäbe es verschiedene Möglichkeiten, das zu machen.
[00:06:41.000 --> 00:06:43.000]   Ich habe jetzt zwei Optionen, ja.
[00:06:43.000 --> 00:06:46.000]   Die eine ist, wir gehen hin und wir drucken in jeder Zeile
[00:06:46.000 --> 00:06:48.000]   erstmal die Zahl und dann das Komma.
[00:06:48.000 --> 00:06:53.000]   Oder in der anderen drucke ich erst das Komma und dann die Zahl, ja.
[00:06:53.000 --> 00:06:57.000]   Und so könnte ich auf diese Weise meinen, dass ich das Problem löse.
[00:06:57.000 --> 00:07:01.000]   Also, gucke ich mich... also, die erste an, die Option A wäre also die,
[00:07:01.000 --> 00:07:05.000]   dass ich eben hingehe und das für jede Zeil...
[00:07:05.000 --> 00:07:07.000]   jeder Zeil die Zahl... die Zahl drucken und das Komma.
[00:07:07.000 --> 00:07:10.000]   Und das ist leider eine federhafte Lösung,
[00:07:10.000 --> 00:07:13.000]   die nämlich nicht das bringt, was wir wollen,
[00:07:13.000 --> 00:07:16.000]   weil am Ende ist immer noch ein extra Komma.
[00:07:16.000 --> 00:07:18.000]   Und wenn ich mir die andere Lösung angucke,
[00:07:18.000 --> 00:07:23.000]   weil das die Lösung, also das Komma erst drucke,
[00:07:23.000 --> 00:07:25.000]   das ist auch nicht die richtige Lösung.
[00:07:25.000 --> 00:07:27.000]   Wenn ich das mache, was bekomme ich dann?
[00:07:27.000 --> 00:07:31.000]   Dann bekomme ich ein extra Komma zu Beginn der Zeile,
[00:07:31.000 --> 00:07:32.000]   will ich auch nicht haben.
[00:07:32.000 --> 00:07:34.000]   Und es ist ein Problem, dass Sie immer wieder haben,
[00:07:34.000 --> 00:07:41.000]   dass Sie bei so einem Loop die erste oder letzte Interaktion anders ausführen,
[00:07:41.000 --> 00:07:43.000]   irgendwie etwas ändern müssen.
[00:07:43.000 --> 00:07:46.000]   So die Analogie ist, wenn Sie einen Gartenzaun bauen,
[00:07:46.000 --> 00:07:49.000]   da bauen Sie ja auch, praktisch Sie gehen hin
[00:07:49.000 --> 00:07:53.000]   und Sie stellen einen Betonieren, einen Pfosten
[00:07:53.000 --> 00:07:55.000]   und dann installieren Sie die Querstreben.
[00:07:55.000 --> 00:07:57.000]   Wenn Sie nach dem System verfahren,
[00:07:57.000 --> 00:08:00.000]   dann haben Sie am Ende so einen Konstrukt,
[00:08:00.000 --> 00:08:03.000]   zwei Querstreben, die da leer im Raum stehen.
[00:08:03.000 --> 00:08:07.000]   Das ist praktisch der Anders, den wir da gewählt haben,
[00:08:07.000 --> 00:08:10.000]   wenn wir das Komma drucken, nachdem wir die Zahl ausgegeben haben.
[00:08:10.000 --> 00:08:14.000]   Oder umgekehrt der Anders wäre, dass wir die Querstreben installieren
[00:08:14.000 --> 00:08:16.000]   und dann den Pfosten betonieren,
[00:08:16.000 --> 00:08:19.000]   dann hätten wir die Querstreben zu Beginn völlig falsch.
[00:08:19.000 --> 00:08:21.000]   Und da sehen Sie, wie die Lösung sein muss.
[00:08:21.000 --> 00:08:23.000]   Die Lösung muss da sein muss,
[00:08:23.000 --> 00:08:26.000]   dass wir zum Beispiel einen ersten Pfosten betonieren
[00:08:26.000 --> 00:08:33.000]   und dann eben halt immer wieder diese Teile da anbauen.
[00:08:33.000 --> 00:08:37.000]   Und genauso würden wir eben unseren Loop konstruieren,
[00:08:37.000 --> 00:08:44.000]   dass wir eben halt den ersten Pfosten betonieren,
[00:08:44.000 --> 00:08:46.000]   also die erste Zahl ausgeben
[00:08:46.000 --> 00:08:50.000]   und dann die weiteren Zahlen in der Reihenfolge,
[00:08:50.000 --> 00:08:55.000]   Zahl ausgeben und dann am Ende die Zeile abschließen.
[00:08:55.000 --> 00:08:57.000]   So können wir das machen.
[00:08:57.000 --> 00:09:03.000]   Oder wir könnten natürlich auch den Durchlauf der letzten Zeile verändern.
[00:09:03.000 --> 00:09:07.000]   Das heißt, wir würden also nicht bis zum Max gehen,
[00:09:07.000 --> 00:09:09.000]   sondern bis zu Max minus 1
[00:09:09.000 --> 00:09:12.000]   und würden dann in der letzten Zeile eben den Pfosten betonieren,
[00:09:12.000 --> 00:09:14.000]   also die Zahl ausgeben.
[00:09:14.000 --> 00:09:16.000]   Was gibt es denn da so Interessantes?
[00:09:16.000 --> 00:09:18.000]   Habe ich etwas falsches auf den Slides?
[00:09:18.000 --> 00:09:19.000]   Nein, nicht.
[00:09:19.000 --> 00:09:21.000]   Guter Börsen-Tab.
[00:09:21.000 --> 00:09:23.000]   Ja, gut, dann geben Sie doch allen Kollegen mit.
[00:09:23.000 --> 00:09:25.000]   Die dürfen auch gewinnen.
[00:09:25.000 --> 00:09:27.000]   Nein, seien Sie nicht so selbstsüchtig,
[00:09:27.000 --> 00:09:29.000]   dass Sie nur an sich denken.
[00:09:29.000 --> 00:09:31.000]   Okay, ja.
[00:09:31.000 --> 00:09:33.000]   So gibt es verschiedene Möglichkeiten,
[00:09:33.000 --> 00:09:37.000]   wie Sie das Problem eben in den Griff bekommen können.
[00:09:37.000 --> 00:09:40.000]   Und wenn Sie eben sehen, das ist ja oft bei 1er-Roy.
[00:09:40.000 --> 00:09:43.000]   Die erste oder letzte Interaktion ist nicht ganz richtig.
[00:09:43.000 --> 00:09:48.000]   Die Schleife wird einmal zu viel oder einmal zu wenig durchlaufen.
[00:09:48.000 --> 00:09:54.000]   Und auf den deutschen Wikipedia-Seiten gibt es sogar dafür eine eigene Webseite.
[00:09:54.000 --> 00:09:58.000]   Aber eben, das ist nicht den Inhalt dieser Webseite.
[00:09:58.000 --> 00:10:00.000]   Dazu kann ich nichts sagen.
[00:10:00.000 --> 00:10:03.000]   Aber es ist ein Problem, dass es immer wieder gibt.
[00:10:03.000 --> 00:10:06.000]   Und darum sollten wir genau überlegen,
[00:10:06.000 --> 00:10:14.000]   wie wir diese Zahl eben halt, wie wir euch die Schleifen eben kontrollieren.
[00:10:14.000 --> 00:10:17.000]   Können wir jetzt verschiedene Systeme umsetzen,
[00:10:17.000 --> 00:10:19.000]   ja, verschiedene Beispiele.
[00:10:19.000 --> 00:10:21.000]   Da will ich jetzt nicht in einzelnen genauer durchgehen.
[00:10:21.000 --> 00:10:23.000]   Ja, der interessante Fall ist der.
[00:10:23.000 --> 00:10:27.000]   Was machen wir denn, wenn wir aus dem Programm
[00:10:27.000 --> 00:10:32.000]   die Daten, die wir einlesen, also Input-Werte,
[00:10:32.000 --> 00:10:37.000]   benutzen, um zu entscheiden, ob die Schleife noch weiter bearbeitet werden soll.
[00:10:37.000 --> 00:10:39.000]   Sondern wenn Sie immer wieder mal haben,
[00:10:39.000 --> 00:10:43.000]   Sie müssen irgendwelche Zahlen addieren oder Sie müssen irgendwas anderes bearbeiten
[00:10:43.000 --> 00:10:45.000]   und da nehmen Sie Input ein.
[00:10:45.000 --> 00:10:49.000]   Und bis dann der Input irgendeinen von Ihnen ausgewählten Centinell,
[00:10:49.000 --> 00:10:52.000]   also Schlusswert hat, würden Sie in diesem Loop bleiben.
[00:10:52.000 --> 00:10:55.000]   Und das ist halt ein unbestimmter Loop.
[00:10:55.000 --> 00:10:58.000]   Und wir wissen nicht, wie oft er ausgeführt wird.
[00:10:58.000 --> 00:11:02.000]   Und daher wäre das ein guter Kandidat für eine Weißchleife.
[00:11:02.000 --> 00:11:04.000]   Und das Problem ergibt sich,
[00:11:04.000 --> 00:11:07.000]   dass eben der Wert nicht nur zur Berechnung verwendet wird,
[00:11:07.000 --> 00:11:12.000]   sondern auch noch eben eine Aufgabe in der Kontrolle des Loop-Sat.
[00:11:12.000 --> 00:11:16.000]   Das ist wirklich wichtig da, dass wir das so.
[00:11:16.000 --> 00:11:21.000]   Also, solche Hinweise, also Hinweiszeichen aus Centines,
[00:11:21.000 --> 00:11:24.000]   geben uns dann an, ob wir das Ende einer Reihe erreicht haben.
[00:11:24.000 --> 00:11:28.000]   Zum Beispiel, wir wollen ein Programm schreiben, das Zahlen einliest,
[00:11:28.000 --> 00:11:31.000]   bis die Benutzerin oder die Benutzer,
[00:11:31.000 --> 00:11:35.000]   bin ich sehr störend hier in der Vorlesung.
[00:11:35.000 --> 00:11:38.000]   Ist das eine große Ablenkung, was ich hier mache?
[00:11:38.000 --> 00:11:39.000]   Ist das so langweilig?
[00:11:39.000 --> 00:11:42.000]   Ich kann auch ganz schnell machen, wissen Sie,
[00:11:42.000 --> 00:11:45.000]   wenn das Ihnen allen Ihren Kollegen gefällt.
[00:11:45.000 --> 00:11:48.000]   Es können auch in den Oberfloraum gehen,
[00:11:48.000 --> 00:11:51.000]   da können Sie sich vergnügen so viel wie Sie wollen.
[00:11:51.000 --> 00:11:56.000]   Also, wir wollen die Zahlen einlesen, bis der Benutzer eine Null eingibt.
[00:11:56.000 --> 00:11:59.000]   Und dann soll die Summe aller eingegebenen Zahlen ausgegeben werden.
[00:11:59.000 --> 00:12:02.000]   Also, wir wollen das so machen, der Benutzer gibt uns Zahlen ein.
[00:12:02.000 --> 00:12:04.000]   Und wenn dann irgendwann mal die Null kommt,
[00:12:04.000 --> 00:12:10.000]   dann wissen wir, dass das Programm die bis dann aufgezähltens Werte ausgeben soll.
[00:12:10.000 --> 00:12:12.000]   So, wie würden wir das denn jetzt machen?
[00:12:12.000 --> 00:12:16.000]   Also, ein einfacher Weg, das zu machen, die aber leider nicht richtig ist,
[00:12:16.000 --> 00:12:19.000]   wäre doch so, wir haben den Scanner hier.
[00:12:19.000 --> 00:12:22.000]   Wir lesen, wir haben den Scanner aufgesetzt.
[00:12:22.000 --> 00:12:25.000]   Wir initialisieren unsere Summe mit Null.
[00:12:25.000 --> 00:12:30.000]   Und wir fangen an zu zählen.
[00:12:30.000 --> 00:12:34.000]   Oder wir haben hier diesen Wert, den wir benutzen wollen,
[00:12:34.000 --> 00:12:37.000]   den wir von der Konsole bekommen.
[00:12:37.000 --> 00:12:40.000]   Wir setzen den mal zu 1, irgendein Wert nur nicht Null,
[00:12:40.000 --> 00:12:42.000]   weil Null ist ja unser Sentinel.
[00:12:42.000 --> 00:12:46.000]   Und jetzt gehe ich hin und gucke nach,
[00:12:46.000 --> 00:12:49.000]   der Lube ist also, das erste Mal ist er ja sicher ungleich Null.
[00:12:49.000 --> 00:12:54.000]   Und jetzt gehe ich hin, lese vom Benutzer oder von der Konsole eine neue Zahl
[00:12:54.000 --> 00:12:56.000]   und dann addiere ich die Zahl auf.
[00:12:56.000 --> 00:13:02.000]   So, und wenn ich das so mache, dann läuft das, ja, das läuft im Prinzip schon.
[00:13:02.000 --> 00:13:07.000]   Für dieses eine Beispiel, das ich hier gewählt habe, funktioniert das.
[00:13:07.000 --> 00:13:09.000]   Aber es ist trotzdem eine schlechte Lösung.
[00:13:09.000 --> 00:13:12.000]   Sehen Sie, warum das eine schlechte Lösung ist?
[00:13:12.000 --> 00:13:14.000]   Oder wer meint, das wäre eine gute Lösung?
[00:13:14.000 --> 00:13:17.000]   Wenn die Lösung erfüllt die Anforderung,
[00:13:17.000 --> 00:13:23.000]   dass Sie das, was wir hier erfüllen wollen, erledigt,
[00:13:23.000 --> 00:13:26.000]   das würde wahrscheinlich die Punkte in der Prüfung geben,
[00:13:26.000 --> 00:13:28.000]   aber trotzdem ist es eine schlechte Lösung.
[00:13:28.000 --> 00:13:31.000]   Weil wenn Sie jetzt auf einmal den Sentinel ändern wollten,
[00:13:31.000 --> 00:13:33.000]   Sie wollten mir wegen des Programms so ändern,
[00:13:33.000 --> 00:13:38.000]   dass der Sentinel minus 1 ist, was passiert denn dann?
[00:13:38.000 --> 00:13:42.000]   Dann gehen wir hin, das Programm läuft genauso ab wie bisher.
[00:13:42.000 --> 00:13:49.000]   Wir checken halt jetzt hier, ob die Zahl, die wir gelesen haben, ungleich minus 1 ist.
[00:13:49.000 --> 00:13:51.000]   Und dann lesen wir und addieren das.
[00:13:51.000 --> 00:13:56.000]   Aber wenn wir das so machen, bekommen wir nicht das Ergebnis, das wir wollen.
[00:13:56.000 --> 00:14:01.000]   Wir kriegen das Ergebnis 79 und gegen 80 das richtige Ergebnis wäre.
[00:14:01.000 --> 00:14:02.000]   Und warum ist das der Fall?
[00:14:02.000 --> 00:14:06.000]   Weil wir haben hier jedes Mal, nachdem wir den Wert eingelesen haben,
[00:14:06.000 --> 00:14:09.000]   diesen Wert zur Summe dazu addiert.
[00:14:09.000 --> 00:14:14.000]   Aber dann in der nächsten Iteration haben wir diesen Wert benutzt,
[00:14:14.000 --> 00:14:18.000]   um zu gucken, ob wir das Ende des Loops erreicht haben.
[00:14:18.000 --> 00:14:21.000]   Und dann wenn ja, dann gehen wir raus und sind wir da sofort fertig.
[00:14:21.000 --> 00:14:25.000]   Aber das Problem ist, zu dem der Schaden ist schon passiert.
[00:14:25.000 --> 00:14:32.000]   Wir haben schon das den Zahl zu dem Sum-Akumulator hinzu addiert.
[00:14:32.000 --> 00:14:34.000]   Also daher ist das eine schlechte Lösung,
[00:14:34.000 --> 00:14:38.000]   weil eben diese Lösung funktioniert nur zufälligerweise,
[00:14:38.000 --> 00:14:40.000]   wenn der Sentinel 0 ist,
[00:14:40.000 --> 00:14:45.000]   weil in dem Fall wir eben den beliebig oft dazu addieren könnten.
[00:14:45.000 --> 00:14:51.000]   Also eben, das ist nicht richtig,
[00:14:51.000 --> 00:14:56.000]   weil wenn wir so einen Weg machen, dann bekommen wir das falsche Ergebnis.
[00:14:56.000 --> 00:14:58.000]   Das heißt, wir müssen da denken, was ich eben sagte,
[00:14:58.000 --> 00:15:03.000]   wir müssen den ersten und letzten Durchgang durch eine Schleife anders behalten.
[00:15:03.000 --> 00:15:11.000]   Das Problem ist, dass wir eben halt hingehen und die Zahl einfach dazu addieren.
[00:15:11.000 --> 00:15:14.000]   Das ist einfach das Problem und das wollen wir nicht machen.
[00:15:14.000 --> 00:15:17.000]   Und wir müssen uns überlegen, wie wir das am besten machen.
[00:15:17.000 --> 00:15:21.000]   Also ein Weg, das Ganze zu überlegen wäre,
[00:15:21.000 --> 00:15:25.000]   also diese Lösung, die wir da als Erster hatten, war keine gute Basis,
[00:15:25.000 --> 00:15:27.000]   weil wir können eben, wenn wir das auf -1 ändern,
[00:15:27.000 --> 00:15:30.000]   dann sehen wir, dass das Problem eben nicht funktioniert.
[00:15:30.000 --> 00:15:34.000]   So, und unser Programm eben folgt diese Muster,
[00:15:34.000 --> 00:15:36.000]   dass ich vorher mit den Zaunfällen hätte,
[00:15:36.000 --> 00:15:39.000]   wir müssten irgendwie unterscheiden,
[00:15:39.000 --> 00:15:42.000]   dass beim letzten Verhindern,
[00:15:42.000 --> 00:15:48.000]   dass beim letzten Durchlauf durch den Rumpf der Sentinel noch immer dazu addiert wird.
[00:15:48.000 --> 00:15:50.000]   Das wollen wir einfach nicht haben.
[00:15:50.000 --> 00:15:52.000]   Das heißt, wir könnten also,
[00:15:52.000 --> 00:15:57.000]   müssen irgendwie einen Weg finden, das zu verhindern.
[00:15:57.000 --> 00:15:59.000]   Und eine Möglichkeit wäre zum Beispiel,
[00:15:59.000 --> 00:16:02.000]   dass wir die erste Schleife herausnehmen.
[00:16:02.000 --> 00:16:06.000]   Das heißt, wir gehen einmal hin und lesen den ersten Input.
[00:16:06.000 --> 00:16:08.000]   Und dann addieren wir den Input.
[00:16:08.000 --> 00:16:15.000]   Und danach lesen wir den Sentinel für die nächste Entscheidung.
[00:16:15.000 --> 00:16:21.000]   Weil dann kann ich den Input benutzen, um korrekt zu entscheiden,
[00:16:21.000 --> 00:16:25.000]   ob der Loop eben nochmal ausgeführt werden soll oder nicht.
[00:16:25.000 --> 00:16:29.000]   Und ohne, dass ich dann versieh, nicht den Sentinel dazu addiere,
[00:16:29.000 --> 00:16:33.000]   weil die Addition findet dann erst in der nächsten Iteration statt.
[00:16:33.000 --> 00:16:37.000]   Also die Addition funktioniert erst,
[00:16:37.000 --> 00:16:41.000]   nachdem ich einmal gecheckt habe, dass der Input nicht der Sentinel war.
[00:16:41.000 --> 00:16:44.000]   Also so würde ich das im Prinzip strukturieren.
[00:16:44.000 --> 00:16:46.000]   Also so müsste das Programm dann aussehen,
[00:16:46.000 --> 00:16:52.000]   dass ich also hier die erste Iteration herausgenommen habe.
[00:16:52.000 --> 00:16:56.000]   So einen Wert bekomme, der entweder richtig ist
[00:16:56.000 --> 00:17:02.000]   oder entweder das Ende der Schleife anzeigt,
[00:17:02.000 --> 00:17:04.000]   also gar nicht erst, dass die Schleife durchgeht,
[00:17:04.000 --> 00:17:07.000]   oder eben halt der hinzuaddiert werden muss.
[00:17:07.000 --> 00:17:11.000]   Und dann im Loop gehe ich hin und lese immer wieder neue Zahlen.
[00:17:11.000 --> 00:17:14.000]   Aber benutze die erst in der folgenden Iteration,
[00:17:14.000 --> 00:17:18.000]   um zu sehen, ob eben das Ende des Loops erreicht ist oder nicht.
[00:17:18.000 --> 00:17:21.000]   Also wenn Sie immer solche Eingabeprobleme haben,
[00:17:21.000 --> 00:17:26.000]   denken Sie daran, dass eventuell der erste Durchlauf da anders gemacht werden muss.
[00:17:26.000 --> 00:17:28.000]   Und Sie könnten natürlich auch das Problem dadurch fixen,
[00:17:28.000 --> 00:17:30.000]   dass Sie den letzten Durchlauf ändern
[00:17:30.000 --> 00:17:33.000]   und zum Beispiel nochmal eine Korrektur vornehmen oder so was.
[00:17:33.000 --> 00:17:35.000]   Aber das ist eigentlich der sauberste Weg,
[00:17:35.000 --> 00:17:37.000]   weil da ist ganz klar, was Sie machen wollen.
[00:17:37.000 --> 00:17:39.000]   Und weil das relativ häufig vorkommt,
[00:17:39.000 --> 00:17:42.000]   gibt es auch ein Konstrukt in der Programmiersprache,
[00:17:42.000 --> 00:17:47.000]   der eben halt diese Test am Ende des Loops durchführt.
[00:17:47.000 --> 00:17:49.000]   Das ist die "Doo-Weilschleife".
[00:17:49.000 --> 00:17:52.000]   Da ist das Keyword "Doo", was Sie hier sehen können.
[00:17:52.000 --> 00:17:56.000]   Und das "Weil" steht am Ende und dann kommt da eben so ein Test.
[00:17:56.000 --> 00:17:58.000]   Und das ist eben so, wir kommen mal an,
[00:17:58.000 --> 00:18:00.000]   wir führen die Anweisungen im Loop aus
[00:18:00.000 --> 00:18:02.000]   und dann wird der Test ausgeführt,
[00:18:02.000 --> 00:18:07.000]   wenn ja, wird eine weitere Iteration ausgeführt
[00:18:07.000 --> 00:18:10.000]   und wenn nein, wird das eben beendet.
[00:18:10.000 --> 00:18:12.000]   Und so könnten Sie das eben halt machen.
[00:18:12.000 --> 00:18:15.000]   So würden Sie auch eben nicht ganz unbedingt,
[00:18:15.000 --> 00:18:19.000]   könnten Sie das Zeichen, das Beispiel, das wir früher hatten,
[00:18:19.000 --> 00:18:22.000]   machen Sie, könnten so lange diesen Loop ausführen,
[00:18:22.000 --> 00:18:26.000]   bis die Benutzerin oder der Benutzer den richtigen Pin eingebt.
[00:18:26.000 --> 00:18:28.000]   So, okay?
[00:18:28.000 --> 00:18:32.000]   Also das eben, denken Sie daran, wenn Sie Schleifen aufsetzen,
[00:18:32.000 --> 00:18:34.000]   es ist nicht immer nur von 0 bis N,
[00:18:34.000 --> 00:18:39.000]   sondern es sind auch andere System, andere Möglichkeiten da.
[00:18:39.000 --> 00:18:40.000]   So, jetzt weiß ich,
[00:18:40.000 --> 00:18:43.000]   wie Sie gestern in der Algorithmus-Datenstruktur
[00:18:43.000 --> 00:18:45.000]   und Vorlesung über Invarianten was gehört.
[00:18:45.000 --> 00:18:47.000]   Gut, dann können wir ja weiter machen.
[00:18:47.000 --> 00:18:50.000]   So, also ja, jetzt haben wir also gesehen,
[00:18:50.000 --> 00:18:53.000]   das ist so, haben wir jetzt Loops kennengelernt,
[00:18:53.000 --> 00:18:58.000]   und wir wollen natürlich Aussagen auch über eben Schleifen machen.
[00:18:58.000 --> 00:19:00.000]   Wir haben gesehen, wie wir das mit IF Anweisungen machen,
[00:19:00.000 --> 00:19:03.000]   wie wir da Götje Hoart-Tüppel definieren.
[00:19:03.000 --> 00:19:07.000]   Wir haben gesehen, wie wir Folgen von Anweisungen bearbeiten.
[00:19:07.000 --> 00:19:10.000]   Und jetzt wollen wir uns eben angucken,
[00:19:10.000 --> 00:19:13.000]   wie wir auch über Schleifen vernünftig Aussagen machen können,
[00:19:13.000 --> 00:19:17.000]   weil viele Programme verbringen viel Zeit in Schleifen.
[00:19:17.000 --> 00:19:19.000]   Und das ist aber einiges schwieriger,
[00:19:19.000 --> 00:19:21.000]   als was wir hier vorher hatten.
[00:19:21.000 --> 00:19:23.000]   Deswegen haben wir das erst gemacht, warum?
[00:19:23.000 --> 00:19:26.000]   Weil nicht nur werden die Schleifen mehrfach ausgeführt,
[00:19:26.000 --> 00:19:30.000]   wir wissen eventuell gar nicht mal zu Beginn des Programmes,
[00:19:30.000 --> 00:19:32.000]   oder wenn wir das Programm uns angucken,
[00:19:32.000 --> 00:19:34.000]   wie oft die Schleifen ausgeführt werden.
[00:19:34.000 --> 00:19:37.000]   Das ist gar nicht mal der Bekannter.
[00:19:37.000 --> 00:19:40.000]   So, und jetzt, um das nicht zu kompliziert zu machen,
[00:19:40.000 --> 00:19:43.000]   fokussieren wir uns auf die Weilloops.
[00:19:43.000 --> 00:19:46.000]   Die sind letztlich allgemeiner als der Vorloop,
[00:19:46.000 --> 00:19:51.000]   weil ich kann jeden da leicht um, leicht transformieren.
[00:19:51.000 --> 00:19:55.000]   Und Weilloop ist auch die allgemeinste Form.
[00:19:55.000 --> 00:19:57.000]   Und wenn ich mit dem Weilloop zurechtkomme,
[00:19:57.000 --> 00:20:00.000]   dann kann ich mir auch überlegen, wie das mit dem Vorloop geht.
[00:20:00.000 --> 00:20:03.000]   So, und jetzt machen wir noch eine weitere Einschränkung.
[00:20:03.000 --> 00:20:07.000]   Einschränkung im Vergleich zu dem, was vielleicht die eine oder die andere
[00:20:07.000 --> 00:20:11.000]   von Ihnen schon mal gelernt hat.
[00:20:11.000 --> 00:20:16.000]   Wir wollen im Loop keine nicht lokalen Kontrolltransfers.
[00:20:16.000 --> 00:20:18.000]   Was ist ein Kontrolltransfer?
[00:20:18.000 --> 00:20:22.000]   Ein Kontrolltransfer ist eben halt der Programmfluss,
[00:20:22.000 --> 00:20:27.000]   oder die Kontrolle, nicht zur nächsten Anweisung geht,
[00:20:27.000 --> 00:20:30.000]   die da im Textuell oder im Text danach erscheint,
[00:20:30.000 --> 00:20:34.000]   und dann dann irgendeine andere Anweisung ausführt.
[00:20:34.000 --> 00:20:37.000]   Also ein Kontrolltransfer findet dann statt,
[00:20:37.000 --> 00:20:41.000]   wenn die nächste ausgeführte Anweisung nicht die Anweisung ist,
[00:20:41.000 --> 00:20:44.000]   die im Programm Text direkt darauf folgt.
[00:20:44.000 --> 00:20:48.000]   Und direkt darauf folgt heißt, also wenn ich hier ein if-Statement habe,
[00:20:48.000 --> 00:20:52.000]   so, und jetzt habe ich hier else, so, so,
[00:20:52.000 --> 00:20:55.000]   und jetzt habe ich hier dieses Statement,
[00:20:55.000 --> 00:20:58.000]   das ist das letzte Statement des if-Blocks,
[00:20:58.000 --> 00:21:00.000]   natürlich danach hier weiter.
[00:21:00.000 --> 00:21:04.000]   Das ist ein lokaler Kontrolltransfer.
[00:21:04.000 --> 00:21:07.000]   Warum? Weil die nächste Ausführung, die nächste Anweisung,
[00:21:07.000 --> 00:21:12.000]   ist diese Anweisung hier unten, nicht irgendeine andere.
[00:21:12.000 --> 00:21:14.000]   So, das wollen wir natürlich zulassen,
[00:21:14.000 --> 00:21:17.000]   sonst könnten wir ja keine if-Statements in unseren Loops haben.
[00:21:17.000 --> 00:21:19.000]   Was wir aber nicht zulassen wollen,
[00:21:19.000 --> 00:21:21.000]   was es aber in manchen Programmiersprachen gibt,
[00:21:21.000 --> 00:21:24.000]   ist, dass sie mit wegen aus der Mitte hier,
[00:21:24.000 --> 00:21:28.000]   wo hin springen oder aus der Mitte einer Schleife,
[00:21:28.000 --> 00:21:30.000]   irgendwo hin springen.
[00:21:30.000 --> 00:21:35.000]   Das wollen wir nicht zulassen, weil das macht es eben um einiges schwieriger.
[00:21:35.000 --> 00:21:38.000]   Also wir wollen solche nicht lokalen Kontrolltransfers,
[00:21:38.000 --> 00:21:42.000]   also die, die eben aus der, die nicht zur nächsten Instruktion gehen,
[00:21:42.000 --> 00:21:47.000]   die wollen wir eben halt nicht zulassen, die wollen wir halt nicht erlauben.
[00:21:47.000 --> 00:21:52.000]   Also, wie können wir jetzt anfangen, über Loops Aussagen zu machen?
[00:21:52.000 --> 00:21:55.000]   Gucken wir uns doch mal hier diesen einfachen Loop hier an.
[00:21:55.000 --> 00:22:01.000]   Wir haben hier zwei, sind alles in Variable und kein Overflow,
[00:22:01.000 --> 00:22:05.000]   kein Underflow tritt auf und daher weiß ich, dass das alles gut laufen wird.
[00:22:05.000 --> 00:22:08.000]   Und ich habe mir die, die Deklarationen hier spart,
[00:22:08.000 --> 00:22:10.000]   damit ich mehr Platz auf den Slides habe.
[00:22:10.000 --> 00:22:13.000]   Also gucken wir uns diesen Loop hier an.
[00:22:13.000 --> 00:22:17.000]   Die Variable y, die Variable i werden beide mit 0 initialisiert.
[00:22:17.000 --> 00:22:19.000]   Und jetzt habe ich hier ein While Loop,
[00:22:19.000 --> 00:22:22.000]   dem solange i um gleich x ist, wird i erhöht,
[00:22:22.000 --> 00:22:26.000]   danach wird y erhöht und danach bin ich fertig.
[00:22:26.000 --> 00:22:30.000]   So, jetzt wenn ich mir das angucke, was,
[00:22:30.000 --> 00:22:34.000]   was müsste ich festhalten als Vorbedingung,
[00:22:34.000 --> 00:22:39.000]   damit dieser Loop überhaupt einmal normalerweise terminiert?
[00:22:39.000 --> 00:22:42.000]   Oder was, was macht er überhaupt? Kann man auch überlegen, ja?
[00:22:42.000 --> 00:22:47.000]   Also er fängt an und erhöht i bis es x bekommt
[00:22:47.000 --> 00:22:53.000]   und dann erhöht er gleichzeitig, addiert er den Wert zu y hinzu.
[00:22:53.000 --> 00:22:57.000]   Also dieses y am Ende muss doch die Summe von irgendwas sein,
[00:22:57.000 --> 00:23:02.000]   die Summe von all diesen i's, die ich hier aufadiere,
[00:23:02.000 --> 00:23:06.000]   also von den, den Werten, die ich hier bekomme.
[00:23:06.000 --> 00:23:08.000]   Aber wie funktioniert das?
[00:23:08.000 --> 00:23:15.000]   Ich erhöhe das i bis, dass es eben, solange es um gleich x ist.
[00:23:15.000 --> 00:23:20.000]   Eine Grundbedingung, die erfüllt sein muss, damit so was funktioniert.
[00:23:20.000 --> 00:23:23.000]   Ja, ja?
[00:23:23.000 --> 00:23:27.000]   Also x muss einen Wert haben, das ist richtig.
[00:23:27.000 --> 00:23:31.000]   Also x muss auch definiert sein, okay, das ist hier abgehakt,
[00:23:31.000 --> 00:23:33.000]   weil alles sind invariable, ja?
[00:23:33.000 --> 00:23:37.000]   Aber, vielleicht haben Sie das gesehen, ja? Ja, bitte.
[00:23:37.000 --> 00:23:41.000]   Muss größer als i sein?
[00:23:41.000 --> 00:23:43.000]   Ja.
[00:23:43.000 --> 00:23:48.000]   Okay, also ein Vorschlag wäre, x muss größer als i sein, ja?
[00:23:48.000 --> 00:23:51.000]   Das ist eine richtige Aussage.
[00:23:51.000 --> 00:24:00.000]   Das ist aber nicht unbe, ja, das ist, ja, okay.
[00:24:00.000 --> 00:24:03.000]   Was darf denn x nicht sein?
[00:24:03.000 --> 00:24:05.000]   Gibt es irgendeinen Wert, ja?
[00:24:05.000 --> 00:24:09.000]   Also x muss auch, ja, ihr muss x werden.
[00:24:09.000 --> 00:24:13.000]   Ja, genau, ihr muss x werden, das ist genau, hat der Kollege gesagt,
[00:24:13.000 --> 00:24:18.000]   ihr muss x werden, weil wenn i x ist, ja, dann ist es eben halt nicht der Fall.
[00:24:18.000 --> 00:24:23.000]   Aber was, also, also jetzt eben, er sich war der andere Kollege, der sagt,
[00:24:23.000 --> 00:24:25.000]   der x muss größer als i sein, schon richtig.
[00:24:25.000 --> 00:24:27.000]   Was haben wir denn hier für i was festgehalten?
[00:24:27.000 --> 00:24:30.000]   Wir haben doch für i festgehalten, dass i gleich null ist, ja?
[00:24:30.000 --> 00:24:36.000]   Also müssten wir als Aussage festhalten, dass x größer als null ist, ja?
[00:24:36.000 --> 00:24:41.000]   Oder zumindest größer gleich, weil wenn wir, wenn wir in es gleich null wäre,
[00:24:41.000 --> 00:24:44.000]   dann würde halt der, der Loop nicht ausgeführt.
[00:24:44.000 --> 00:24:51.000]   Und wenn wir jetzt die Summe von, die Summe von i gleich null bis null haben,
[00:24:51.000 --> 00:24:56.000]   dann könnten wir auch sagen, das ist null, ja, das können wir vielleicht auch so definieren, ja?
[00:24:56.000 --> 00:24:59.000]   Das ist ein Thema, eine Lache, die wir nicht haben.
[00:24:59.000 --> 00:25:01.000]   Also, das ist nicht so krisch.
[00:25:01.000 --> 00:25:04.000]   Also wir müssten auf jeden Fall festhalten, dass x größer gleich null ist.
[00:25:04.000 --> 00:25:10.000]   Weil wenn x negativ wäre, dann würde im Normalfall ja dieser Wert nie gleich werden, ja?
[00:25:10.000 --> 00:25:14.000]   Dann würde i immer erhöht werden, i würde größer und größer werden
[00:25:14.000 --> 00:25:18.000]   und das wäre dann nicht ein Weg für uns da hinzukommen.
[00:25:18.000 --> 00:25:25.000]   So, also wenn das x eben größer gleich null ist und das, oder größer als i, wie Ihr Kollege sagte,
[00:25:25.000 --> 00:25:30.000]   dann wird eben halt, während wir durch das Erhöhende i's irgendwie den Punkt erreichen,
[00:25:30.000 --> 00:25:35.000]   dass x gleich i, dass x gleich i ist, ja?
[00:25:35.000 --> 00:25:40.000]   So, und wenn x gleich i ist, oder machen wir hier, machen wir es korrekt,
[00:25:40.000 --> 00:25:44.000]   machen wir es Java in Java Notation mit zwei Gleichheitszeichen, ja?
[00:25:44.000 --> 00:25:49.000]   So, wenn das der Fall ist, dann geht eben der Weihloop zu Ende und dann sind wir hier fertig.
[00:25:49.000 --> 00:25:53.000]   So, jetzt können wir gucken, also was passiert, dass i wird hochgezählt
[00:25:53.000 --> 00:25:57.000]   und jedes Mal wird das i dazugezählt, ja?
[00:25:57.000 --> 00:26:02.000]   Das heißt, da wir hier mit 1 anfangen, weil es ja ergibt, dieses y,
[00:26:02.000 --> 00:26:10.000]   am Ende eben die Summe von eben 1, von j gleich 1 bis n von j, ja?
[00:26:10.000 --> 00:26:12.000]   Irgendwann können wir i nehmen.
[00:26:12.000 --> 00:26:16.000]   Und deswegen, ja, was machen wir jetzt, wenn wir eben hier oben, wenn x gleich null ist,
[00:26:16.000 --> 00:26:19.000]   dann, ja, müssen wir hier was, wollen wir vielleicht definieren,
[00:26:19.000 --> 00:26:26.000]   dass die Summe von 1 bis null über j oder i ist gleich 1, können wir definieren,
[00:26:26.000 --> 00:26:30.000]   dann haben wir das so definiert, oder wollen wir also null definieren,
[00:26:30.000 --> 00:26:34.000]   das spielt für uns, oder null, wahrscheinlich besser null,
[00:26:34.000 --> 00:26:36.000]   das spielt für uns eigentlich keine so große Rolle.
[00:26:36.000 --> 00:26:39.000]   Was ich jetzt eigentlich, worauf ich hinaus möchte, ist folgendes,
[00:26:39.000 --> 00:26:46.000]   wenn wir jetzt hier über diesen Loop reden wollen, was hier, was dieser Loop hier unten macht, ja?
[00:26:46.000 --> 00:26:49.000]   Dann ist das in,
[00:26:49.000 --> 00:26:54.000]   eine Idee, komm ich um, nicht besser.
[00:26:54.000 --> 00:26:59.000]   Wenn ich also das, wenn ich über diesen Loop da, mit diesem Loop da arbeiten will,
[00:26:59.000 --> 00:27:04.000]   dann muss ich halt irgendein Weg finden, den Loop zusammenzufassen, ja?
[00:27:04.000 --> 00:27:10.000]   Es reicht nicht aus, irgendeine Aussage zu machen, die nur ein einzelnes Statement betrifft,
[00:27:10.000 --> 00:27:16.000]   ich muss den Loop zusammenfassen, um eine Aussage am Ende dieses Programmsignments machen zu können, ja?
[00:27:16.000 --> 00:27:18.000]   Und das ist die Idee der Invariante.
[00:27:18.000 --> 00:27:22.000]   Wir fassen zusammen, was dieser Loopbody macht, ja?
[00:27:22.000 --> 00:27:25.000]   Und diese Invariante, so wie wir das hier machen,
[00:27:25.000 --> 00:27:29.000]   die muss an sich abdecken, dass es keine Iterationen gibt, ja?
[00:27:29.000 --> 00:27:32.000]   Also vor der ersten Ausführung muss die Invariante gelten,
[00:27:32.000 --> 00:27:35.000]   und dann gibt es keine Ausführung des Loopbodies,
[00:27:35.000 --> 00:27:37.000]   und trotzdem muss die Invariante gelten,
[00:27:37.000 --> 00:27:41.000]   und sie muss eine beliebige Anzahl von Iterationen abdecken,
[00:27:41.000 --> 00:27:48.000]   um eben halt das eben zu zeigen, dass das eben immer noch gültig ist.
[00:27:48.000 --> 00:27:54.000]   Also die Invariante ist ein Weg für uns, den Loopbody zusammenzufassen, ja?
[00:27:54.000 --> 00:27:56.000]   Also wenn ich das jetzt hier habe, ja?
[00:27:56.000 --> 00:27:59.000]   Was würde sich hier als Invariante anbieten?
[00:27:59.000 --> 00:28:05.000]   Naja, wenn wir anfangen, und wir wollen am Ende die Summe haben, die Summe von 1 bis X, ja?
[00:28:05.000 --> 00:28:09.000]   Und wir benutzen diesen Zähler I, um da durchzugehen,
[00:28:09.000 --> 00:28:11.000]   dann wäre eine Idee für eine Invariante,
[00:28:11.000 --> 00:28:17.000]   wäre zu sagen, dass diese Variable Y immer die Summe von 1 bis I festhält, ja?
[00:28:17.000 --> 00:28:20.000]   Das wäre also unsere Invariante, ja?
[00:28:20.000 --> 00:28:25.000]   So, und das wäre, und da müssten wir jetzt zeigen, dass das stimmt, ja?
[00:28:25.000 --> 00:28:31.000]   Das heißt, diese Zusammenfassung, die gilt eben sowohl zu Beginn des Loop,
[00:28:31.000 --> 00:28:33.000]   beim ersten Mal, ja?
[00:28:33.000 --> 00:28:35.000]   Als auch, müssen wir natürlich noch zeigen, ja?
[00:28:35.000 --> 00:28:39.000]   Das ist der Zähler, nachdem ich den Loopbody einmal ausgeführt habe, ja?
[00:28:39.000 --> 00:28:42.000]   Damit habe ich das eben gezeigt, ja?
[00:28:42.000 --> 00:28:45.000]   Und was wissen wir jetzt noch?
[00:28:45.000 --> 00:28:49.000]   Naja, wir wissen natürlich, was wir hier über I und J gelernt haben.
[00:28:49.000 --> 00:28:55.000]   Das heißt, wir wissen, dass eben Y, wir wissen, dass I eben gleich 0 ist hier,
[00:28:55.000 --> 00:29:00.000]   und wir wissen, dass Y auch gleich 0 ist, ja?
[00:29:00.000 --> 00:29:04.000]   Das haben wir schon, das ergibt sich zu Beginn der Iteration, ja?
[00:29:04.000 --> 00:29:09.000]   Das haben wir als Aussage da bereits sehr, ja?
[00:29:09.000 --> 00:29:13.000]   Das heißt, wir haben können das als Aussage mit dazunehmen, ja?
[00:29:13.000 --> 00:29:18.000]   Also, wenn ich also das habe, da habe ich, also, ich kann das festhalten, ja?
[00:29:18.000 --> 00:29:22.000]   Also, hier zu Beginn weiß ich, dass X ist größer gleich 0,
[00:29:22.000 --> 00:29:25.000]   weil die Zuweisung zu Y und I ändern das ja nicht,
[00:29:25.000 --> 00:29:29.000]   und Y ist gleich 0, und I ist gleich 0, ja?
[00:29:29.000 --> 00:29:33.000]   So, da habe ich, also, das ist sozusagen die Information,
[00:29:33.000 --> 00:29:36.000]   die ich zu Beginn des Loops habe.
[00:29:36.000 --> 00:29:39.000]   Jetzt, also, jetzt kann ich checken, ja?
[00:29:39.000 --> 00:29:43.000]   Gilt das in der Tat, das eben ist die Invariante gültig,
[00:29:43.000 --> 00:29:46.000]   und wenn wir jetzt eben halt entsprechend definieren,
[00:29:46.000 --> 00:29:49.000]   was es heißt, die Summe von 1 bis 0 zu machen, ja?
[00:29:49.000 --> 00:29:52.000]   Wenn wir sagen, das wäre 0, dann ist das erfüllt,
[00:29:52.000 --> 00:29:54.000]   weil das ist der aktuelle Wert von Y.
[00:29:54.000 --> 00:29:57.000]   Aber ein interessanter Fall ist jetzt, können wir zeigen,
[00:29:57.000 --> 00:30:00.000]   dass nach der Ausführung des Loop-Bodies, ja,
[00:30:00.000 --> 00:30:02.000]   die Invariante immer noch gilt,
[00:30:02.000 --> 00:30:05.000]   weil erst dann ist es ja eine richtige Zusammenfassung,
[00:30:05.000 --> 00:30:07.000]   dessen, was in dem Loop passiert.
[00:30:07.000 --> 00:30:09.000]   Jetzt, wann führen wir den Loop denn aus?
[00:30:09.000 --> 00:30:12.000]   Wenn wir den Loop ausführen, dann ist ja hier diese,
[00:30:12.000 --> 00:30:17.000]   muss dieser Test den Wert Tru ergeben haben, ja?
[00:30:17.000 --> 00:30:21.000]   So, jetzt machen wir also hier diese Art Forward-Riesening, ja?
[00:30:21.000 --> 00:30:23.000]   Also, Forward-Schließen, ja?
[00:30:23.000 --> 00:30:26.000]   Wie die Schleife führen wir nur auf, wenn der Test Tru ist?
[00:30:26.000 --> 00:30:28.000]   Das muss als Aussage gelten,
[00:30:28.000 --> 00:30:31.000]   dass eben die Invariante, haben wir gesagt, ist Tru,
[00:30:31.000 --> 00:30:35.000]   und eben halt, wir wissen, dass i ungleich 0 ist, ja?
[00:30:35.000 --> 00:30:37.000]   So, das wissen wir.
[00:30:37.000 --> 00:30:39.000]   Und wenn wir jetzt weiterdenken,
[00:30:39.000 --> 00:30:41.000]   jetzt haben wir hier eine Zuweisung zu i, ja?
[00:30:41.000 --> 00:30:43.000]   Was haben wir danach?
[00:30:43.000 --> 00:30:45.000]   Ja, danach gilt eben das nicht mehr, ja?
[00:30:45.000 --> 00:30:49.000]   Dass diese Aussage, die gilt nur hier, bevor wir i erhöhen.
[00:30:49.000 --> 00:30:51.000]   Danach wissen wir das nicht mehr.
[00:30:51.000 --> 00:30:53.000]   Einzige, was wir wissen ist jetzt,
[00:30:53.000 --> 00:30:57.000]   dass y immer noch die Summe von 1 und jetzt i-1 ist,
[00:30:57.000 --> 00:31:00.000]   weil wir haben ja hier das i um 1 erhöht, ja?
[00:31:00.000 --> 00:31:03.000]   Also, es ist die Summe von 1 bis i-1, ja?
[00:31:03.000 --> 00:31:06.000]   So, und jetzt haben wir hier einen weiteren Schritt.
[00:31:06.000 --> 00:31:09.000]   Was macht das? Was können wir jetzt einlärzen?
[00:31:09.000 --> 00:31:11.000]   Können wir einlärzen und vereinfachen, ja?
[00:31:11.000 --> 00:31:15.000]   Jetzt sehen wir, aha, hier gilt jetzt,
[00:31:15.000 --> 00:31:19.000]   dass y gleich die Summe von 1 bis i-1,
[00:31:19.000 --> 00:31:21.000]   das kommt von oben, ist plus i.
[00:31:21.000 --> 00:31:24.000]   Das haben wir ja gerade dahin zuadiert, ja?
[00:31:24.000 --> 00:31:26.000]   So, und wenn wir das anschauen,
[00:31:26.000 --> 00:31:29.000]   dann sehen wir ja, dass wir das umschreiben könnten,
[00:31:29.000 --> 00:31:34.000]   dass die Summe von 1 bis i-1 plus i ist nichts anderes
[00:31:34.000 --> 00:31:37.000]   als die Summe von 1 bis i, ja?
[00:31:37.000 --> 00:31:39.000]   Und damit haben wir gezeigt,
[00:31:39.000 --> 00:31:43.000]   dass die Invariante auch am Ende des Loops gilt.
[00:31:43.000 --> 00:31:45.000]   Und das handelt sich, das, was wir haben wollen,
[00:31:45.000 --> 00:31:47.000]   das heißt, am Ende der Loop-Ausführung
[00:31:47.000 --> 00:31:52.000]   ist der Loop, gilt die Invariante auch noch, ja?
[00:31:52.000 --> 00:31:56.000]   So, also die Invariante war eine ziemlich praktische Zusammenfassung
[00:31:56.000 --> 00:31:59.000]   dessen, was der Loop da machen würde.
[00:31:59.000 --> 00:32:02.000]   So, und jetzt haben wir, okay,
[00:32:02.000 --> 00:32:07.000]   jetzt haben wir gesehen, dass also hier das erfüllt ist,
[00:32:07.000 --> 00:32:11.000]   also die Invariante, die Invariante, die gilt, ja?
[00:32:11.000 --> 00:32:14.000]   So, jetzt, was ist der nächste Punkt, den wir uns angucken müssen?
[00:32:14.000 --> 00:32:17.000]   Naja, wir wollen zeigen, dass am Ende des Programms
[00:32:17.000 --> 00:32:21.000]   diese Aussage gilt, dass Y gleich die Summe von 1 bis i ist.
[00:32:21.000 --> 00:32:24.000]   Was ist die Definition von Invariante?
[00:32:24.000 --> 00:32:27.000]   Eine Invariante, fast, ist eine logische Aussage,
[00:32:27.000 --> 00:32:30.000]   die Frage war, was ist eine Invariante?
[00:32:30.000 --> 00:32:35.000]   Eine Invariante ist eine Aussage, die eben sich für uns
[00:32:35.000 --> 00:32:38.000]   zu Beginn eines Loop-Bodies gilt
[00:32:38.000 --> 00:32:43.000]   und die nach Ausführung der Statements im Loop-Body immer noch gilt.
[00:32:43.000 --> 00:32:47.000]   Also diese Art von Zusammenfassung, das nennen wir eine
[00:32:47.000 --> 00:32:51.000]   Zusammenfassung der Aktivitäten eines Loops,
[00:32:51.000 --> 00:32:54.000]   das nennen wir eine Invariante.
[00:32:54.000 --> 00:32:57.000]   So, okay, so, und jetzt was haben wir noch zu beachten?
[00:32:57.000 --> 00:33:01.000]   Also um jetzt die Aussage zu machen, was am Ende gilt,
[00:33:01.000 --> 00:33:04.000]   na ja, wenn eben der Test mal false ergibt,
[00:33:04.000 --> 00:33:06.000]   dann geht es ja nach hier.
[00:33:06.000 --> 00:33:09.000]   Also, da wird der Loop nicht mehr aufgeführt
[00:33:09.000 --> 00:33:13.000]   und wir müssen jetzt zeigen, dass dann dieses Statement gilt.
[00:33:13.000 --> 00:33:16.000]   Und na ja, was, wenn wir jetzt diesen Punkt hier erreichen,
[00:33:16.000 --> 00:33:18.000]   was wissen wir, dass es in das gilt?
[00:33:18.000 --> 00:33:20.000]   Na ja, wir wissen, dass die Invariante galt,
[00:33:20.000 --> 00:33:23.000]   weil die Invariante gilt ja hier,
[00:33:23.000 --> 00:33:25.000]   an diesem Punkt vor der Ausführung des Loops,
[00:33:25.000 --> 00:33:30.000]   also wir wissen, dass Y gleich die Summe von 1 bis i ist,
[00:33:30.000 --> 00:33:33.000]   das wissen wir, und was wissen wir noch,
[00:33:33.000 --> 00:33:37.000]   wir wissen, dass der Test da oben false ergeben haben muss.
[00:33:37.000 --> 00:33:43.000]   Also nicht i ungleich x, na ja, das können wir natürlich vereinfachen,
[00:33:43.000 --> 00:33:45.000]   als nicht i ungleich x,
[00:33:45.000 --> 00:33:49.000]   das könnten wir besser schreiben als i gleich x.
[00:33:49.000 --> 00:33:52.000]   So, das weiß ich, wenn ich diesen Punkt hier erreiche,
[00:33:52.000 --> 00:33:57.000]   und kann ich daraus schließen, dass das eben Y,
[00:33:57.000 --> 00:34:00.000]   die Summe von 1 bis x ist, ja,
[00:34:00.000 --> 00:34:03.000]   weil wenn ich jetzt das hier einsetze, das ist ja x,
[00:34:03.000 --> 00:34:06.000]   dann habe ich genau das, was ich haben will.
[00:34:06.000 --> 00:34:08.000]   Und damit habe ich dann im Grunde genommen gezeigt,
[00:34:08.000 --> 00:34:14.000]   dass eben die Invariante nicht nur während der Loop-Iteration gültig ist,
[00:34:14.000 --> 00:34:18.000]   sondern am Ende auch das gewünschte Ergebnis liefert.
[00:34:18.000 --> 00:34:22.000]   So, und wenn jetzt sie von dem i etwas verwirrt sind,
[00:34:22.000 --> 00:34:24.000]   ich habe das hier nochmal neu gezeigt,
[00:34:24.000 --> 00:34:26.000]   wo ich die verschiedenen Varianten,
[00:34:26.000 --> 00:34:30.000]   die verschiedenen Versionen von i mit separaten Namen vergebe.
[00:34:30.000 --> 00:34:31.000]   Also können Sie genauso machen,
[00:34:31.000 --> 00:34:34.000]   sieht für meine Begriffe etwas umständlicher aus als das,
[00:34:34.000 --> 00:34:39.000]   aber natürlich muss wissen, dass dieses i ist ein anderes i als dieses i.
[00:34:39.000 --> 00:34:43.000]   Also, keine deswegen muss man hier eben i minus 1 haben,
[00:34:43.000 --> 00:34:49.000]   genauer, so können wir unterscheiden, was wir da gemacht haben.
[00:34:49.000 --> 00:34:52.000]   So, okay, also, wenn wir uns das angucken,
[00:34:52.000 --> 00:34:54.000]   wenn wir also irgendwelche Aussagen
[00:34:54.000 --> 00:34:56.000]   über Ausführungen von Loops machen wollen,
[00:34:56.000 --> 00:34:58.000]   dann brauchen wir eine Invariante,
[00:34:58.000 --> 00:35:03.000]   um eben über die Zusammenhänge dazu schließen
[00:35:03.000 --> 00:35:07.000]   und zu sagen, oh, das ist ein gültiges,
[00:35:07.000 --> 00:35:10.000]   das ist ein Programm, das wir für richtig halten.
[00:35:10.000 --> 00:35:13.000]   Und wir brauchen dann eben auch wieder so ein Konstrukt, der sagt,
[00:35:13.000 --> 00:35:17.000]   hier ist eine Aussage, ein Loop und eine Pre-Condition,
[00:35:17.000 --> 00:35:19.000]   ein Loop und eine Post-Condition
[00:35:19.000 --> 00:35:21.000]   und die erfüllen bestimmte Bedingungen.
[00:35:21.000 --> 00:35:23.000]   Und das nennen wir dann Gültig.
[00:35:23.000 --> 00:35:28.000]   Also, die Invariante macht Aussagen über die Ausführung des Loops
[00:35:28.000 --> 00:35:32.000]   und wichtig ist, dass die Pre-Condition für die Schleife,
[00:35:32.000 --> 00:35:34.000]   die muss die Invariante implizieren.
[00:35:34.000 --> 00:35:38.000]   Wenn ich den Punkt vor der Ausführung des Loops erreiche,
[00:35:38.000 --> 00:35:40.000]   dann muss die Invariante Gültig sein,
[00:35:40.000 --> 00:35:43.000]   aufgrund dessen, was die Statements davor gemacht haben.
[00:35:43.000 --> 00:35:46.000]   So, und der Schleifentest, wenn er wahr ist,
[00:35:46.000 --> 00:35:51.000]   muss zusammen mit den Statements im Rumpf zeigen
[00:35:51.000 --> 00:35:55.000]   oder sicherstellen, dass danach die Invariante wieder war.
[00:35:55.000 --> 00:35:58.000]   Sonst ist es ja nicht invariant, sonst ändert sie sich.
[00:35:58.000 --> 00:36:01.000]   Also, wenn wir das Rumpf ausgeführt haben,
[00:36:01.000 --> 00:36:03.000]   muss die Invariante wieder Gültig sein.
[00:36:03.000 --> 00:36:06.000]   Und wenn mal der Test im Loop false sein sollte,
[00:36:06.000 --> 00:36:08.000]   also, wenn der Loop nicht ausgeführt wird,
[00:36:08.000 --> 00:36:12.000]   dann muss dieser Information, dass der Test false ist
[00:36:12.000 --> 00:36:14.000]   und die Invariante, das muss ausreichen,
[00:36:14.000 --> 00:36:19.000]   um zu zeigen, dass dann die Post-Condition der Schleife erfüllt ist.
[00:36:19.000 --> 00:36:22.000]   Und das fassen wir jetzt eben in so einem Hortrippel zusammen.
[00:36:22.000 --> 00:36:24.000]   Also, wir haben hier ein, das hier ist unser Loop,
[00:36:24.000 --> 00:36:27.000]   wir haben für dieses Loop eine Pre-Condition,
[00:36:27.000 --> 00:36:29.000]   eine Post-Condition,
[00:36:29.000 --> 00:36:33.000]   und wir sagen, ein solches Trippel ist Gültig.
[00:36:33.000 --> 00:36:36.000]   Wenn es eben eine Invariante i gibt,
[00:36:36.000 --> 00:36:39.000]   da muss es irgendeine Invariante i geben,
[00:36:39.000 --> 00:36:43.000]   so dass eben die Invariante gilt zu beginnen.
[00:36:43.000 --> 00:36:47.000]   Wenn die Invariante gilt und ich den Loop ausführe,
[00:36:47.000 --> 00:36:52.000]   also, sprich, diese Test b, die ich da habe, ist wahr.
[00:36:52.000 --> 00:36:54.000]   Und ich führe dann das Statement s,
[00:36:54.000 --> 00:36:58.000]   oder die Folge von Statements s, die ich habe, aus.
[00:36:58.000 --> 00:37:01.000]   Dann gilt danach wieder die Invariante i.
[00:37:01.000 --> 00:37:04.000]   Und wenn mal der Test b false ergibt,
[00:37:04.000 --> 00:37:07.000]   dann gilt die Invariante ja auch,
[00:37:07.000 --> 00:37:09.000]   weil das ist ja zu Beginn des Loops,
[00:37:09.000 --> 00:37:12.000]   aber dann mit dem Test false bin ich in der Lage,
[00:37:12.000 --> 00:37:15.000]   die Post-Condition q zu zeigen.
[00:37:15.000 --> 00:37:18.000]   Also, die Tatsache, dass ich den Loop verlassen habe
[00:37:18.000 --> 00:37:22.000]   und die Invariante implizieren die Post-Condition.
[00:37:22.000 --> 00:37:24.000]   Wenn wir diese Situation haben,
[00:37:24.000 --> 00:37:27.000]   dann nennen wir das ein gültiges Hortrippel für diesen Weihloop.
[00:37:27.000 --> 00:37:32.000]   Dann haben wir eben einen Weihloop, für den wir sagen würden,
[00:37:32.000 --> 00:37:36.000]   diese Aussagen sind in einem Gültigentrippel zusammengefasst.
[00:37:36.000 --> 00:37:43.000]   Also, das ist halt das gültige Hortrippel für eine Schleife.
[00:37:43.000 --> 00:37:46.000]   Und jetzt natürlich keine Überraschung.
[00:37:46.000 --> 00:37:48.000]   Dieser Schleifentest, der Schleifenrumpf
[00:37:48.000 --> 00:37:52.000]   und die Schleifeninvariante hängen alle eng miteinander zusammen.
[00:37:52.000 --> 00:37:54.000]   Es ist nicht so, dass irgendeine Schleife
[00:37:54.000 --> 00:37:59.000]   für irgendeinen Rumpf geht oder irgendwas funktioniert.
[00:37:59.000 --> 00:38:03.000]   Und natürlich, dass der Statement kann natürlich alles Mögliche enthalten.
[00:38:03.000 --> 00:38:05.000]   Das kann also ein einzelnes Statement sein.
[00:38:05.000 --> 00:38:07.000]   Das kann eine Folge sein.
[00:38:07.000 --> 00:38:09.000]   Das kann wieder ein anderer Loop sein und so weiter.
[00:38:09.000 --> 00:38:13.000]   Das sind aber die einzigen Statements, die wir zur Zeit zulassen.
[00:38:13.000 --> 00:38:17.000]   Und wenn Sie jetzt die Aufgabe haben,
[00:38:17.000 --> 00:38:22.000]   irgendeine Post-Condition q herzustellen oder sicherzustellen,
[00:38:22.000 --> 00:38:24.000]   Sie sollen das und das berechnen.
[00:38:24.000 --> 00:38:26.000]   Also, wenn wir sagen, die Aufgabe ist,
[00:38:26.000 --> 00:38:29.000]   dann schreiben Sie ein Programm für das nach Ausführung,
[00:38:29.000 --> 00:38:31.000]   die Post-Condition so und so gilt.
[00:38:31.000 --> 00:38:33.000]   Da gibt es manchmal verschiedene Schleifen,
[00:38:33.000 --> 00:38:37.000]   die für eine Pre-Condition dasselbe Resultat berechnen.
[00:38:37.000 --> 00:38:40.000]   Aber die Schleifen handeln andere Invarianten
[00:38:40.000 --> 00:38:43.000]   und gegebenenfalls andere Statements im Loop.
[00:38:43.000 --> 00:38:46.000]   Und manchmal gibt es eben auch andere Invarianten,
[00:38:46.000 --> 00:38:48.000]   wenn man andere Pre-Conditions hat.
[00:38:48.000 --> 00:38:51.000]   Also, wie gesagt, diese Definition ist ziemlich allgemein.
[00:38:51.000 --> 00:38:54.000]   Das ist auch ab, wenn der Rumpf gar nicht durchlaufen wird.
[00:38:54.000 --> 00:38:56.000]   Deswegen geht das mit dem Weihloop so gut.
[00:38:56.000 --> 00:38:59.000]   Aber eben halt, es ist wirklich wichtig,
[00:38:59.000 --> 00:39:02.000]   dass wir sehen, dass diese Teile,
[00:39:02.000 --> 00:39:07.000]   Pre-Condition, Post-Condition, Statement, Invariante und Loop-Test,
[00:39:07.000 --> 00:39:09.000]   das die alle miteinander verbunden sind.
[00:39:09.000 --> 00:39:11.000]   Also, das habe ich das Ganze,
[00:39:11.000 --> 00:39:14.000]   das Beispiel, das ich eben zeige Sie nochmal etwas,
[00:39:14.000 --> 00:39:16.000]   Schritt für Schritt, langsamer gemacht.
[00:39:16.000 --> 00:39:19.000]   Also, die Pre-Condition für das Programmsegment muss sein,
[00:39:19.000 --> 00:39:21.000]   dass x größer gleich 0 ist.
[00:39:21.000 --> 00:39:25.000]   Jetzt müssen wir zeigen, dass die Pre-Condition für den Loop
[00:39:25.000 --> 00:39:28.000]   eben den Ausreicht, um das zu zeigen.
[00:39:28.000 --> 00:39:31.000]   Also, die Pre-Condition für den Loop ist das.
[00:39:31.000 --> 00:39:33.000]   Dann haben wir hier die Invariante,
[00:39:33.000 --> 00:39:37.000]   müssen also zeigen, dass die Pre-Condition die Invariante impliziert.
[00:39:37.000 --> 00:39:40.000]   Kann man machen, das habe ich eben so von Hand gemacht.
[00:39:40.000 --> 00:39:42.000]   Geht ganz gut.
[00:39:42.000 --> 00:39:44.000]   Dann müssen wir zeigen, dass wenn die Invariante gilt
[00:39:44.000 --> 00:39:46.000]   und wir den Loop ausführen,
[00:39:46.000 --> 00:39:48.000]   die Statements, das ist der Loop,
[00:39:48.000 --> 00:39:51.000]   dass die dann eben die Invariante gültig lassen,
[00:39:51.000 --> 00:39:53.000]   also die Invariante implizieren.
[00:39:53.000 --> 00:39:57.000]   Nach den Regeln, die wir für Statement Folgen gemacht haben,
[00:39:57.000 --> 00:39:59.000]   geht das auch.
[00:39:59.000 --> 00:40:01.000]   Und dann müssen wir noch zeigen,
[00:40:01.000 --> 00:40:03.000]   dass wenn wir mit dem Loop fertig sind,
[00:40:03.000 --> 00:40:05.000]   also wenn eben der Loop-Test-Force ergibt,
[00:40:05.000 --> 00:40:10.000]   dann reicht diese Information zusammen mit der Invariante aus,
[00:40:10.000 --> 00:40:13.000]   um zu zeigen, dass die Post-Condition gilt.
[00:40:13.000 --> 00:40:16.000]   Und dann habe ich eben auch gezeigt, das geht eben auch.
[00:40:16.000 --> 00:40:20.000]   So, eben Sie müssen sehen,
[00:40:20.000 --> 00:40:22.000]   dass diese Teile genau eng zusammenhängen.
[00:40:22.000 --> 00:40:25.000]   Hier habe ich den anderen Loop, der hat hier,
[00:40:25.000 --> 00:40:28.000]   der initialisiert, dass ihr mit eins,
[00:40:28.000 --> 00:40:30.000]   wenn ich das machen will,
[00:40:30.000 --> 00:40:33.000]   dann muss ich einen anderen Loop-Test verwenden.
[00:40:33.000 --> 00:40:36.000]   Dann muss ich einen anderen Loop-Test verwenden
[00:40:36.000 --> 00:40:39.000]   und ich müsste auch eine andere Invariante verwenden.
[00:40:39.000 --> 00:40:42.000]   Weil eben, klar, am Anfang gilt jetzt eben der,
[00:40:42.000 --> 00:40:45.000]   gilt die Pre-Condition X,
[00:40:45.000 --> 00:40:48.000]   ist größer gleich 0 und Y gleich 0 wie vorher,
[00:40:48.000 --> 00:40:50.000]   aber Y ist jetzt eben gleich 1.
[00:40:50.000 --> 00:40:54.000]   Das heißt, meine Invariante muss sich eben dahingehend ändern,
[00:40:54.000 --> 00:40:58.000]   dass eben meine Y, die Summe nicht mehr von 1 bis Y,
[00:40:58.000 --> 00:41:01.000]   sondern von 1 bis Y minus 1 ist.
[00:41:01.000 --> 00:41:04.000]   Das heißt, das Wort ist auch für sich,
[00:41:04.000 --> 00:41:07.000]   wenn der Loop nicht terminiert?
[00:41:07.000 --> 00:41:10.000]   Nein, Ihr Kollege sagte,
[00:41:10.000 --> 00:41:14.000]   das Hohe-Triple wäre gültig, wenn der Loop nicht terminiert.
[00:41:14.000 --> 00:41:17.000]   Und die Antwort ist, nein, wir gehen immer allgemein,
[00:41:17.000 --> 00:41:20.000]   bei allen Beispielen, tut mir leid, langsam geht ja,
[00:41:20.000 --> 00:41:24.000]   wir gehen immer davon aus, dass wir diesen Punkt hier erreichen.
[00:41:24.000 --> 00:41:27.000]   Wenn wir bei allen Hohe-Trippeln gilt,
[00:41:27.000 --> 00:41:30.000]   dass die Aussage nur dann relevant ist,
[00:41:30.000 --> 00:41:33.000]   wenn wir den Punkt nach dem Statement erreichen.
[00:41:33.000 --> 00:41:36.000]   Und unser Statement ist jetzt eben halt hier der Loop.
[00:41:36.000 --> 00:41:41.000]   Deswegen gilt das dann, wenn wir den Punkt erreichen.
[00:41:41.000 --> 00:41:47.000]   Also, haben wir hier einen anderen Loop für das selbe Problem.
[00:41:47.000 --> 00:41:50.000]   Und dann haben wir eben das halt so gemacht.
[00:41:50.000 --> 00:41:55.000]   Und dann können wir zeigen, am Ende, wenn X plus 1 gleich i ist
[00:41:55.000 --> 00:42:00.000]   und Y gleich die Summe von 1 bis i minus 1,
[00:42:00.000 --> 00:42:02.000]   dann reicht das aus, um zu zeigen,
[00:42:02.000 --> 00:42:06.000]   dass Y gleich die Summe von 1 bis X ist.
[00:42:06.000 --> 00:42:08.000]   Hier müssten zwei Gleichheitszeichen sein,
[00:42:08.000 --> 00:42:10.000]   das werde ich auch noch mal fixen.
[00:42:10.000 --> 00:42:14.000]   Aber wir sind da etwas flexibel in diesen logischen Aussagen.
[00:42:14.000 --> 00:42:17.000]   Ein Gleichheitszeichen war ja zwei, ja gut.
[00:42:17.000 --> 00:42:19.000]   So, warum machen wir das?
[00:42:19.000 --> 00:42:21.000]   So, jetzt haben Sie noch kurz bevor wir heute.
[00:42:21.000 --> 00:42:24.000]   Wir machen das, weil es uns hilft, Bucks back zu finden.
[00:42:24.000 --> 00:42:26.000]   Jetzt gucken wir sich diesen Loop an.
[00:42:26.000 --> 00:42:29.000]   Der ist ähnlich zu dem, den ich Ihnen hier vorher zeigte.
[00:42:29.000 --> 00:42:33.000]   Wir haben wieder Y gleich 0 und i gleich 1.
[00:42:33.000 --> 00:42:38.000]   Aber wir benutzen hier ein Loop-Test, der auf X geht.
[00:42:38.000 --> 00:42:41.000]   Der ist ähnlich, aber der macht halt nicht das, was wir wollen.
[00:42:41.000 --> 00:42:44.000]   Wenn es unser Ziel ist, die Summe da zu berechnen.
[00:42:44.000 --> 00:42:48.000]   In der Tat, das ist die Pre-Condition.
[00:42:48.000 --> 00:42:51.000]   Wir können jetzt sagen, die Invariante ist immer noch,
[00:42:51.000 --> 00:42:54.000]   das ist ja richtig, haben wir eben gezeigt,
[00:42:54.000 --> 00:42:57.000]   Y ist die Summe von 1 bis i minus 1.
[00:42:57.000 --> 00:42:59.000]   Aber wenn ich jetzt mit dem Loop fertig bin
[00:42:59.000 --> 00:43:01.000]   und weiß, dass i ist gleich X
[00:43:01.000 --> 00:43:05.000]   und Y ist die Summe von 1 bis i minus 1,
[00:43:05.000 --> 00:43:09.000]   dann ist das eben nicht die Summe von 1 bis X.
[00:43:09.000 --> 00:43:11.000]   Also, dieser kleine Fehler hier,
[00:43:11.000 --> 00:43:15.000]   dass wir eine andere Terminierung verwendet haben,
[00:43:15.000 --> 00:43:21.000]   der führt dazu, dass das Ergebnis, das wir bekommen, ein anderes ist.
[00:43:21.000 --> 00:43:24.000]   Und wenn es unser Aufgabe war, die Summe zu berechnen,
[00:43:24.000 --> 00:43:27.000]   dann ist das eben nicht richtig.
[00:43:27.000 --> 00:43:30.000]   Oder hier haben wir ein Loop,
[00:43:30.000 --> 00:43:33.000]   der ein ungültiges Hortrippel enthält.
[00:43:33.000 --> 00:43:37.000]   Was ist hier falsch?
[00:43:37.000 --> 00:43:40.000]   Sie sehen, wenn wir das so machen,
[00:43:40.000 --> 00:43:45.000]   addieren wir in das Y nicht den neuen Wert von i,
[00:43:45.000 --> 00:43:47.000]   sondern den alten.
[00:43:47.000 --> 00:43:50.000]   Daher ist das gilt am Ende,
[00:43:50.000 --> 00:43:53.000]   hier am Anfang haben wir wie gehabt,
[00:43:53.000 --> 00:43:56.000]   Pre-Condition und die Invariante.
[00:43:56.000 --> 00:43:59.000]   Aber eben am Ende gilt die Invariante nicht mehr.
[00:43:59.000 --> 00:44:06.000]   Warum? Weil wir eben halt den alten Wert von i hinzuaddiert haben.
[00:44:06.000 --> 00:44:11.000]   Also, Invarianten dürfen weder zu stark noch zu schwach sein.
[00:44:11.000 --> 00:44:14.000]   Wenn sie zu stark ist, sind sie eventuell falsch.
[00:44:14.000 --> 00:44:18.000]   Wir können nicht zeigen, dass die Invariante zu Beginn gültig ist
[00:44:18.000 --> 00:44:23.000]   oder die Invariante ist nicht wahr, nachdem der Loop ausgeführt wurde.
[00:44:23.000 --> 00:44:25.000]   Oder die Invariante ist zu schwach.
[00:44:25.000 --> 00:44:29.000]   Das gilt, dass wir nach dem Loop fertig sind,
[00:44:29.000 --> 00:44:32.000]   wie aus der Invariante und dem falschen Loop Test
[00:44:32.000 --> 00:44:35.000]   nicht die Aussage über die Schleife implizieren können.
[00:44:35.000 --> 00:44:38.000]   Oder es ist unmöglich zu zeigen,
[00:44:38.000 --> 00:44:44.000]   dass die Invariante nach der Ausführung des Rumpfs wieder gilt.
[00:44:44.000 --> 00:44:46.000]   Das ist die andere Situation.
[00:44:46.000 --> 00:44:51.000]   Das ist guter Punkt für die Pause.
[00:44:51.000 --> 00:44:54.000]   Ich starte jetzt mal einen Clicker für Sie.
[00:44:54.000 --> 00:44:56.000]   A. Um zu gucken, ob das funktioniert.
[00:44:56.000 --> 00:45:00.000]   Aber B. Wo Sie mir sagen können, ob Sie hier im Hörsaal sitzen
[00:45:00.000 --> 00:45:02.000]   oder woanders.
[00:45:02.000 --> 00:45:06.000]   Und ob Sie lieber hier wären oder noch ganz woanders.
[00:45:06.000 --> 00:45:10.000]   Also, das starte ich mal.
[00:45:10.000 --> 00:45:12.000]   Das lassen wir über die Pause laufen.
[00:45:12.000 --> 00:45:15.000]   Dann können wir sehen, was für Interessen Sie da haben.
[00:45:15.000 --> 00:45:17.000]   Okay.
[00:45:17.000 --> 00:45:23.000]   Okay, ich mache jetzt den Clicker zu.
[00:45:23.000 --> 00:45:26.000]   Dann können wir mal sehen, was da kommt.
[00:45:26.000 --> 00:45:30.000]   Also, Invarianten dürfen weder zu stark noch zu schwach sein.
[00:45:30.000 --> 00:45:32.000]   Das ist leider auch der Grund,
[00:45:32.000 --> 00:45:36.000]   warum wir Ihnen keinen vollautomatischen Weg zeigen können,
[00:45:36.000 --> 00:45:39.000]   wie Sie eine Loop-Invariante konstruieren.
[00:45:39.000 --> 00:45:42.000]   Da ist halt immer noch Kreativität gefordert.
[00:45:42.000 --> 00:45:45.000]   Weil Sie müssen halt nachdenken
[00:45:45.000 --> 00:45:47.000]   und manchmal eben auch ein bisschen raten,
[00:45:47.000 --> 00:45:49.000]   was das sein könnte.
[00:45:49.000 --> 00:45:52.000]   Aber eben die Invariante und das Programm,
[00:45:52.000 --> 00:45:54.000]   die sind ineinander gekoppelt.
[00:45:54.000 --> 00:45:56.000]   Wenn Sie ihn programmieren
[00:45:56.000 --> 00:45:58.000]   und Sie finden keine Invariante,
[00:45:58.000 --> 00:46:00.000]   dann ist vielleicht nötig,
[00:46:00.000 --> 00:46:03.000]   dass Sie den Code ändern oder die Invariante oder beides.
[00:46:03.000 --> 00:46:06.000]   Es ist eben nicht so, dass Sie einfach sagen können,
[00:46:06.000 --> 00:46:10.000]   für dieses Programm oder für diese gibt es einfach hier nur diese eine
[00:46:10.000 --> 00:46:14.000]   Invariante und damit alles andere ergibt sich.
[00:46:14.000 --> 00:46:16.000]   Und manchmal gibt es auch verschiedene Invarianten,
[00:46:16.000 --> 00:46:18.000]   die alle genügen.
[00:46:18.000 --> 00:46:20.000]   Also, die alle die Anforderungen erfüllen,
[00:46:20.000 --> 00:46:22.000]   die nicht so stark und nicht so schwach sind,
[00:46:22.000 --> 00:46:24.000]   aber sie sind unterschiedlich zweckmäßig.
[00:46:24.000 --> 00:46:26.000]   Und was wir Ihnen bieten können,
[00:46:26.000 --> 00:46:28.000]   ist eine Methodologie.
[00:46:28.000 --> 00:46:30.000]   Das ist ein Ansatz, wie wir eine Schleife
[00:46:30.000 --> 00:46:32.000]   und Invariante zusammenentwickeln.
[00:46:32.000 --> 00:46:35.000]   Das ist kein vollständiges Rezept.
[00:46:35.000 --> 00:46:38.000]   Es ist nicht etwas, was Sie blind verfolgen können.
[00:46:38.000 --> 00:46:41.000]   Für die Preconditions der Assignment Statements
[00:46:41.000 --> 00:46:44.000]   konnte ich Ihnen sagen, wie Sie das genau machen mussten.
[00:46:44.000 --> 00:46:47.000]   Für die Invarianten kann ich Ihnen sagen,
[00:46:47.000 --> 00:46:50.000]   wie Sie das, das funktioniert in vielen Fällen.
[00:46:50.000 --> 00:46:53.000]   Und funktioniert dann gut, aber eben ist nicht unbedingt
[00:46:53.000 --> 00:46:57.000]   in allen Situationen der einzige Weg
[00:46:57.000 --> 00:47:00.000]   oder der richtige Weg, wie Sie da hinkommen.
[00:47:00.000 --> 00:47:06.000]   Also, was ist eine Methodologie?
[00:47:06.000 --> 00:47:10.000]   Das ist ein Ansatz, wie wir eben halt Probleme lösen,
[00:47:10.000 --> 00:47:12.000]   eine Strategie.
[00:47:12.000 --> 00:47:14.000]   Es ist kein Algorithmus,
[00:47:14.000 --> 00:47:18.000]   es ist kein Rezept, das Sie verfolgen können,
[00:47:18.000 --> 00:47:20.000]   sondern es sind eben Ideen,
[00:47:20.000 --> 00:47:22.000]   die Sie selbst einsetzen können,
[00:47:22.000 --> 00:47:25.000]   wie Sie eben weiterkommen können.
[00:47:25.000 --> 00:47:27.000]   Und diese Methodologie zeigt Ihnen eben,
[00:47:27.000 --> 00:47:30.000]   wie Sie schleifen und Invarianten zusammenentwickeln können.
[00:47:30.000 --> 00:47:33.000]   Und das sollen Sie jetzt bitte nicht stur befolgen,
[00:47:33.000 --> 00:47:36.000]   aber das ist manchmal besser als der schnelle Weg,
[00:47:36.000 --> 00:47:38.000]   wo Sie einfach erst den Code schreiben
[00:47:38.000 --> 00:47:42.000]   und dann die Invariante suchen, oder schlimmer noch,
[00:47:42.000 --> 00:47:44.000]   nicht suchen, sondern raten.
[00:47:44.000 --> 00:47:47.000]   Und dann hoffen, dass Sie auf das richtige Ergebnis kommen.
[00:47:47.000 --> 00:47:49.000]   Also, was schlagen wir vor?
[00:47:49.000 --> 00:47:52.000]   Und das funktioniert in erstaunlich vielen Situationen.
[00:47:52.000 --> 00:47:55.000]   Wir bestimmen zuerst die Invariante.
[00:47:55.000 --> 00:47:57.000]   Wir fangen mit der Invariante an
[00:47:57.000 --> 00:48:00.000]   und lassen Sie die anderen Schritte leiten.
[00:48:00.000 --> 00:48:03.000]   Wir eben überlegen uns, was wollen wir denn als Invariante haben,
[00:48:03.000 --> 00:48:06.000]   was will ich als Schlussergebnis haben.
[00:48:06.000 --> 00:48:09.000]   Und daraus überlegen, was die Invariante sein könnte
[00:48:09.000 --> 00:48:11.000]   und die bestimme ich dann.
[00:48:11.000 --> 00:48:13.000]   Und dann überlege ich mir,
[00:48:13.000 --> 00:48:16.000]   wenn das die Invariante ist und das ist mein Schlussergebnis,
[00:48:16.000 --> 00:48:18.000]   was bringt uns der näher ans Ziel?
[00:48:18.000 --> 00:48:21.000]   Was muss ich denn in jeder Loop-Iteration machen,
[00:48:21.000 --> 00:48:24.000]   damit ich mehr an das Ziel herankomme?
[00:48:24.000 --> 00:48:28.000]   Und dann natürlich auch, was muss nach jeder Iteration gelten?
[00:48:28.000 --> 00:48:30.000]   So, nachdem wir das überlegt haben,
[00:48:30.000 --> 00:48:32.000]   dann kann man daraus überlegen,
[00:48:32.000 --> 00:48:35.000]   was für einen Rumpf würde denn erstens
[00:48:35.000 --> 00:48:38.000]   diese uns näher ans Ziel bringen
[00:48:38.000 --> 00:48:42.000]   und zweitens würde dieser Rumpf die Invariante gültig lassen.
[00:48:42.000 --> 00:48:45.000]   Wenn die Invariante nicht gültig bleibt,
[00:48:45.000 --> 00:48:48.000]   dann ist es keine Invariante, dann ist das eben anders.
[00:48:48.000 --> 00:48:50.000]   So, und nachdem wir das haben,
[00:48:50.000 --> 00:48:52.000]   dann können wir uns überlegen,
[00:48:52.000 --> 00:48:54.000]   wie der Loop-Test aussehen müsste.
[00:48:54.000 --> 00:48:56.000]   Dann bestimmen wir den Loop-Test so,
[00:48:56.000 --> 00:49:00.000]   dass das Test ist false, die Post-Condition impliziert.
[00:49:00.000 --> 00:49:02.000]   Also dann haben wir Test ist false.
[00:49:02.000 --> 00:49:05.000]   Das soll ausreichen, um zu zeigen,
[00:49:05.000 --> 00:49:10.000]   was wir für diesen Loop erreichen wollen.
[00:49:10.000 --> 00:49:13.000]   So, und nachdem wir das alles gemacht haben,
[00:49:13.000 --> 00:49:15.000]   gehen wir nochmal zurück
[00:49:15.000 --> 00:49:18.000]   und dann erst schreiben wir die Initialisierung so,
[00:49:18.000 --> 00:49:20.000]   dass der Code die Invariante sicherstellt,
[00:49:20.000 --> 00:49:24.000]   damit die Invariante vor Beginn des der Schleife bereits gültig ist.
[00:49:24.000 --> 00:49:26.000]   Das ist dann, wenn wir das haben,
[00:49:26.000 --> 00:49:29.000]   dann haben wir alle Schritte gecheckt,
[00:49:29.000 --> 00:49:31.000]   die wir machen müssen,
[00:49:31.000 --> 00:49:35.000]   um ein gültiges Hortrippel mit dieser Invariante
[00:49:35.000 --> 00:49:39.000]   und dieser Pre-Condition für die gewünschte Post-Condition zu haben.
[00:49:39.000 --> 00:49:41.000]   Also das sind die vier Schritte,
[00:49:41.000 --> 00:49:46.000]   die wir vorschlagen, dass sie das machen.
[00:49:46.000 --> 00:49:49.000]   So, und wie gesagt,
[00:49:49.000 --> 00:49:51.000]   ist kein vollständiges Rezept,
[00:49:51.000 --> 00:49:55.000]   aber ist etwas, was in vielen Fällen funktioniert.
[00:49:55.000 --> 00:49:57.000]   Und darum ein einfaches Beispiel erstmal,
[00:49:57.000 --> 00:50:01.000]   wir suchen für positive x und y, positiv,
[00:50:01.000 --> 00:50:07.000]   den quotienten q, also q soll eben sein x durch y,
[00:50:07.000 --> 00:50:09.000]   bei ganz Zahlen die Vision.
[00:50:09.000 --> 00:50:12.000]   So, und wir gehen mal davon aus,
[00:50:12.000 --> 00:50:14.000]   wieder alle Variablen sind invariable,
[00:50:14.000 --> 00:50:16.000]   y natürlich um gleich null
[00:50:16.000 --> 00:50:21.000]   und das Ergebnis kann korrekt in einer invariable Gespräche werden.
[00:50:21.000 --> 00:50:23.000]   Also Ergebnis, das Intergebnis.
[00:50:23.000 --> 00:50:25.000]   So, andere Zahlen kennen wir nicht.
[00:50:25.000 --> 00:50:27.000]   So, wir haben also die Schritte, hatten wir,
[00:50:27.000 --> 00:50:29.000]   der erste Schritt war,
[00:50:29.000 --> 00:50:31.000]   bestimmen Sie zuerst die Invariante
[00:50:31.000 --> 00:50:34.000]   und lassen Sie die Invariante die anderen Schritte leiten.
[00:50:34.000 --> 00:50:36.000]   So, naja, jetzt gibt es da mehrere Überlegungen,
[00:50:36.000 --> 00:50:38.000]   aber wenn Sie sich zurückdenken,
[00:50:38.000 --> 00:50:42.000]   wie haben Sie eines am Anfang gelernt zu dividieren,
[00:50:42.000 --> 00:50:46.000]   Ihr könnt noch hingehen und y von x subtrahieren.
[00:50:46.000 --> 00:50:51.000]   Und so finden wir auf, raus, wie oft y in x enthalten ist.
[00:50:51.000 --> 00:50:54.000]   Und unsere Invariante, q, die speichert dann,
[00:50:54.000 --> 00:50:57.000]   wie oft das y subtrahiert wurde.
[00:50:57.000 --> 00:51:02.000]   Das heißt, unser q ist, wie ich hier bereits gehighlightet habe,
[00:51:02.000 --> 00:51:05.000]   q mal y plus r ist gleich x.
[00:51:05.000 --> 00:51:08.000]   Natürlich ist dieser r, also der Rest,
[00:51:08.000 --> 00:51:11.000]   ist möglicherweise größer als y.
[00:51:11.000 --> 00:51:13.000]   Und wie ist die Division definiert?
[00:51:13.000 --> 00:51:15.000]   Die Division ist auch so definiert,
[00:51:15.000 --> 00:51:19.000]   dass wir eben einen q finden,
[00:51:19.000 --> 00:51:24.000]   sodass eben diese Gleichung gilt, q mal y plus r ist x.
[00:51:24.000 --> 00:51:28.000]   Und das eine Bedingung für r gilt.
[00:51:28.000 --> 00:51:31.000]   Nämlich, das r muss kleiner als y sein.
[00:51:31.000 --> 00:51:34.000]   Das ist unsere Bedingung für eine Division.
[00:51:34.000 --> 00:51:39.000]   Da war die Frage eben, warum ist 7 dividiert durch 8?
[00:51:39.000 --> 00:51:42.000]   7 dividiert durch 8 ist eben 0,
[00:51:42.000 --> 00:51:47.000]   weil eben halt wir können die 8 nicht von 7 subtrahieren.
[00:51:47.000 --> 00:51:51.000]   Das ist nicht, weil da irgendein reeller Wert gerechnet wird,
[00:51:51.000 --> 00:51:54.000]   der dann irgendwie in irgendeine Richtung gerundet wird.
[00:51:54.000 --> 00:51:56.000]   Nein, es ist einfach definiert so,
[00:51:56.000 --> 00:51:58.000]   dass eben es gibt ein q,
[00:51:58.000 --> 00:52:02.000]   sodass eben q mal y plus r gleich x ergibt.
[00:52:02.000 --> 00:52:04.000]   So, ich könnte noch andere Invarianten nehmen,
[00:52:04.000 --> 00:52:07.000]   aber von der weiß ich, dass es funktioniert.
[00:52:07.000 --> 00:52:10.000]   Also, jetzt haben wir die Invariante,
[00:52:10.000 --> 00:52:12.000]   hier oben ist unsere Invariante.
[00:52:12.000 --> 00:52:14.000]   Und jetzt wollen wir einen Rumpf schreiben,
[00:52:14.000 --> 00:52:16.000]   dass die Invariante gültig lässt.
[00:52:16.000 --> 00:52:19.000]   Also, was für Möglichkeiten hätten wir da?
[00:52:19.000 --> 00:52:21.000]   Eine Möglichkeit wäre doch,
[00:52:21.000 --> 00:52:25.000]   dass wir ein weiteres Mal y von r subtrahieren.
[00:52:25.000 --> 00:52:27.000]   Das heißt, wir haben ein neues r.
[00:52:27.000 --> 00:52:31.000]   Und dann, natürlich, wenn wir einen erfolgreich abziehen können,
[00:52:31.000 --> 00:52:34.000]   dann müssen wir das q um 1 erhöhen.
[00:52:34.000 --> 00:52:36.000]   Und wenn das der Fall ist,
[00:52:36.000 --> 00:52:39.000]   dann in der Tat gilt die Invariante.
[00:52:39.000 --> 00:52:41.000]   Auch die Invariante gilt hier zu beginnen,
[00:52:41.000 --> 00:52:43.000]   also, die Invariante ist für uns,
[00:52:43.000 --> 00:52:45.000]   für unsere Slups, das müssen wir her sicherstellen,
[00:52:45.000 --> 00:52:47.000]   aber wollen wir haben,
[00:52:47.000 --> 00:52:50.000]   dass wir dann, wenn die Invariante gilt,
[00:52:50.000 --> 00:52:52.000]   und wir das machen,
[00:52:52.000 --> 00:52:56.000]   dann gilt die Invariante auch nach Ende des Slups,
[00:52:56.000 --> 00:52:58.000]   nachdem wir den Rumpf einmal ausgeführt haben,
[00:52:58.000 --> 00:53:00.000]   oder präziser sein.
[00:53:00.000 --> 00:53:02.000]   Also, wenn wir das gemacht haben,
[00:53:02.000 --> 00:53:04.000]   dann gilt das eben,
[00:53:04.000 --> 00:53:06.000]   nachdem wir den Rumpfausbau,
[00:53:06.000 --> 00:53:08.000]   die ausgeführt haben,
[00:53:08.000 --> 00:53:10.000]   nach Ende des Rumpfaus,
[00:53:10.000 --> 00:53:12.000]   nicht nach Ende der Schreife,
[00:53:12.000 --> 00:53:15.000]   nach Ende des Rumpfaus gilt die Invariante aus Neue.
[00:53:15.000 --> 00:53:17.000]   So, jetzt haben wir also einen Loop Body,
[00:53:17.000 --> 00:53:19.000]   und wir haben eine Invariante.
[00:53:19.000 --> 00:53:21.000]   Und jetzt müssen wir überlegen,
[00:53:21.000 --> 00:53:23.000]   was müssen wir für einen Test finden,
[00:53:23.000 --> 00:53:25.000]   sodass nachher,
[00:53:25.000 --> 00:53:28.000]   wenn der Test nicht mehr wahr ist,
[00:53:28.000 --> 00:53:30.000]   also, wenn der Test false ist,
[00:53:30.000 --> 00:53:32.000]   wir eine genügend Information haben,
[00:53:32.000 --> 00:53:34.000]   dass wir dann die Post Condition,
[00:53:34.000 --> 00:53:37.000]   die wir für diesen Loop zeigen wollen, gürtig ist.
[00:53:37.000 --> 00:53:40.000]   Und dann können wir das Y subtrahieren.
[00:53:40.000 --> 00:53:43.000]   Und na ja, die Überlegung ist doch,
[00:53:43.000 --> 00:53:45.000]   dass wir das so oft subtrahieren,
[00:53:45.000 --> 00:53:47.000]   solange es irgendwie geht.
[00:53:47.000 --> 00:53:49.000]   Und wann geht es nicht mehr,
[00:53:49.000 --> 00:53:51.000]   wenn der Rest eben kleiner als Y ist,
[00:53:51.000 --> 00:53:54.000]   dann können wir nicht mehr weiter subtrahieren.
[00:53:54.000 --> 00:53:57.000]   Das heißt, also wir wollen so lange subtrahieren,
[00:53:57.000 --> 00:54:00.000]   solange der Rest größer als 0 ist,
[00:54:00.000 --> 00:54:02.000]   und eben sicherstellen,
[00:54:02.000 --> 00:54:06.000]   dass der Rest kleiner als Y ist.
[00:54:06.000 --> 00:54:09.000]   Und sonst haben wir auch ein Problem.
[00:54:09.000 --> 00:54:11.000]   Also haben wir eben als Bedingungen,
[00:54:11.000 --> 00:54:13.000]   dass wir also einmal festhalten,
[00:54:13.000 --> 00:54:16.000]   dass eben R größer als 0 ist.
[00:54:16.000 --> 00:54:20.000]   Das haben wir hier, und das ist eine Bedingung.
[00:54:20.000 --> 00:54:23.000]   Oder anders ausgedrückt,
[00:54:23.000 --> 00:54:29.000]   ist das eben, dass Y muss kleiner als R werden.
[00:54:29.000 --> 00:54:31.000]   So, also können wir anders schreiben,
[00:54:31.000 --> 00:54:33.000]   als Y kleiner als R.
[00:54:33.000 --> 00:54:36.000]   Also unser R muss eben begrenzt,
[00:54:36.000 --> 00:54:40.000]   so dass das Y eben halt da nicht größer ist.
[00:54:40.000 --> 00:54:42.000]   So, wenn wir das haben,
[00:54:42.000 --> 00:54:44.000]   dann mit dieser Information,
[00:54:44.000 --> 00:54:46.000]   wenn wir das haben,
[00:54:46.000 --> 00:54:51.000]   also wir haben die invariante Q mal Y plus R ergibt X,
[00:54:51.000 --> 00:54:53.000]   und R ist größer als 0,
[00:54:53.000 --> 00:54:55.000]   und R ist kleiner als Y,
[00:54:55.000 --> 00:54:58.000]   oder Y kleiner als R.
[00:54:58.000 --> 00:55:00.000]   Daraus können wir natürlich dann zeigen,
[00:55:00.000 --> 00:55:03.000]   dass das er günste Ergebnis sichergestellt ist.
[00:55:03.000 --> 00:55:05.000]   So, jetzt haben wir also gezeigt,
[00:55:05.000 --> 00:55:08.000]   dass der Loop, wenn er mal richtig ausgeführt wird,
[00:55:08.000 --> 00:55:12.000]   und so weiter, hat die,
[00:55:12.000 --> 00:55:15.000]   liefert das gewünschte Ergebnis.
[00:55:15.000 --> 00:55:17.000]   Aber wir müssen sicherstellen,
[00:55:17.000 --> 00:55:19.000]   dass die Pre-Kondition erfüllt ist.
[00:55:19.000 --> 00:55:21.000]   Also hier, das wollen wir als Pre-Kondition haben.
[00:55:21.000 --> 00:55:23.000]   Wir hatten gesagt, wir wollen,
[00:55:23.000 --> 00:55:25.000]   dass das R größer als 0 ist,
[00:55:25.000 --> 00:55:27.000]   weil sonst läuft das ja unbegrenzt weiter.
[00:55:27.000 --> 00:55:29.000]   Und dann können wir auch sicherstellen,
[00:55:29.000 --> 00:55:31.000]   dass die invariante gilt.
[00:55:31.000 --> 00:55:33.000]   Und wie können wir das sicherstellen?
[00:55:33.000 --> 00:55:37.000]   Naja, wenn wir am Anfang R auf X setzen und Q auf 0,
[00:55:37.000 --> 00:55:41.000]   dann können wir sicherstellen, dass das erfüllt ist.
[00:55:41.000 --> 00:55:47.000]   Und dann haben wir die gewünschte Information für den Loop.
[00:55:47.000 --> 00:55:49.000]   Aber natürlich, wir müssen sicherstellen,
[00:55:49.000 --> 00:55:51.000]   dass X größer als 0 ist,
[00:55:51.000 --> 00:55:53.000]   und Y größer als 0.
[00:55:53.000 --> 00:55:55.000]   Sonst geht das Ganze nachher auch nicht.
[00:55:55.000 --> 00:55:58.000]   Also wir müssen das sicherstellen, dass das am Anfang gilt.
[00:55:58.000 --> 00:56:01.000]   Und das könnte jetzt eben eine Bedingung sein,
[00:56:01.000 --> 00:56:03.000]   die wir verlangen.
[00:56:03.000 --> 00:56:05.000]   Oder wir könnten checken, dass das gilt.
[00:56:05.000 --> 00:56:07.000]   Oder wir könnten die Dokumentation schreiben.
[00:56:07.000 --> 00:56:11.000]   Diese Methode ist nur aufzurufen für positive X
[00:56:11.000 --> 00:56:14.000]   und positive Y, oder sowas.
[00:56:14.000 --> 00:56:17.000]   Das ist also, und da unsere Aufgabenstellung sagte,
[00:56:17.000 --> 00:56:19.000]   dass alles in Zahlen sind,
[00:56:19.000 --> 00:56:21.000]   und Y und X positiv sind,
[00:56:21.000 --> 00:56:23.000]   und Y umgleich 0 ist,
[00:56:23.000 --> 00:56:25.000]   dann gilt das aus dem Grunde.
[00:56:25.000 --> 00:56:28.000]   Und daher sind wir da auf einer sicheren Seite.
[00:56:28.000 --> 00:56:33.000]   Also bei den Hortrippeln gilt allgemein,
[00:56:33.000 --> 00:56:36.000]   wir haben hier eine Pre-Condition,
[00:56:36.000 --> 00:56:39.000]   eine Post-Condition und ein Statement S.
[00:56:39.000 --> 00:56:41.000]   Und das war immer nur gültig,
[00:56:41.000 --> 00:56:45.000]   das war gültig, wenn eben nach der Ausführung S,
[00:56:45.000 --> 00:56:47.000]   die Aussage Q gilt, vorausgesetzt,
[00:56:47.000 --> 00:56:49.000]   dass P davor galt.
[00:56:49.000 --> 00:56:51.000]   Und jetzt bei den Regisseurs,
[00:56:51.000 --> 00:56:53.000]   die Division durch Null gemacht wurde,
[00:56:53.000 --> 00:56:54.000]   haben wir gesagt,
[00:56:54.000 --> 00:56:56.000]   exception können wir nichts machen.
[00:56:56.000 --> 00:57:00.000]   Und darum eben, hatten wir gesagt,
[00:57:00.000 --> 00:57:02.000]   eben ist diese Bedingung,
[00:57:02.000 --> 00:57:03.000]   muss die erfüllt sein,
[00:57:03.000 --> 00:57:07.000]   dass wir den Punkt nach der Ausführung von S erreichen.
[00:57:07.000 --> 00:57:09.000]   Wenn nämlich eine Division stattfindet,
[00:57:09.000 --> 00:57:12.000]   dann wissen wir ja nicht, was da alles passiert.
[00:57:12.000 --> 00:57:15.000]   Und deswegen wollen wir da keine Ausführung,
[00:57:15.000 --> 00:57:17.000]   keine Aussage machen.
[00:57:17.000 --> 00:57:21.000]   Und das hatte uns für die einfachen Statements eigentlich genügt.
[00:57:21.000 --> 00:57:24.000]   Weil wenn das Statement korrekt ausgeführt wird,
[00:57:24.000 --> 00:57:27.000]   dann haben wir eben halt den Punkt,
[00:57:27.000 --> 00:57:29.000]   erreichen wir den Punkt nach S.
[00:57:29.000 --> 00:57:31.000]   Aber jetzt, da wir mit Loops arbeiten,
[00:57:31.000 --> 00:57:33.000]   ist das ein bisschen schwieriger,
[00:57:33.000 --> 00:57:36.000]   weil wir wollen ja mit unserer Invariante abdecken,
[00:57:36.000 --> 00:57:40.000]   beliebig viele Ausführungen des Loop-Bodies.
[00:57:40.000 --> 00:57:46.000]   Und natürlich können der Loop beliebig viele Ausführungen machen
[00:57:46.000 --> 00:57:49.000]   und wir erreichen trotzdem den Punkt nach S nicht,
[00:57:49.000 --> 00:57:51.000]   nach dem Loop nicht, warum?
[00:57:51.000 --> 00:57:53.000]   Weil wir eben einen unendlichen Loop haben,
[00:57:53.000 --> 00:57:55.000]   zumindest konzeptionell unendlich.
[00:57:55.000 --> 00:57:58.000]   Und das heißt, wir müssen also ein bisschen mehr überlegen,
[00:57:58.000 --> 00:58:01.000]   wie wir Korrektheit für definieren,
[00:58:01.000 --> 00:58:05.000]   wenn wir eben mit schleifen, also mit Loops arbeiten wollen.
[00:58:05.000 --> 00:58:10.000]   Und das, was ich Ihnen bisher Korrektheit genannt habe,
[00:58:10.000 --> 00:58:13.000]   wird eigentlich korrekterweise,
[00:58:13.000 --> 00:58:17.000]   alle Korrektheit genannt, korrekt unter der Annahme,
[00:58:17.000 --> 00:58:20.000]   dass dieser Loop terminiert.
[00:58:20.000 --> 00:58:24.000]   Das ist unter der Annahme, dass das Statement terminiert.
[00:58:24.000 --> 00:58:27.000]   Und ein vollständiger Korrektnisbeweis,
[00:58:27.000 --> 00:58:31.000]   der erfordert auch einen Beweis, dass das Statement terminiert.
[00:58:31.000 --> 00:58:33.000]   Wenn da eine Division durch Null ist,
[00:58:33.000 --> 00:58:37.000]   ist das eben etwas außerhalb dessen, was die Division machen will.
[00:58:37.000 --> 00:58:39.000]   Dafür brauchen wir nichts zu zeigen.
[00:58:39.000 --> 00:58:42.000]   Aber jetzt eben halt, wenn wir eine Schleife haben,
[00:58:42.000 --> 00:58:46.000]   dann können wir jetzt auch zeigen, dass diese Schleife terminiert.
[00:58:46.000 --> 00:58:50.000]   Und hat das der eine oder die andere von Ihnen schon mal irgendwo gesehen?
[00:58:50.000 --> 00:58:52.000]   Es gibt einen Weg das zu machen.
[00:58:52.000 --> 00:58:54.000]   Und der Weg geht folgendermaßen,
[00:58:54.000 --> 00:58:56.000]   wir werden das also nicht weiterverfolgen,
[00:58:56.000 --> 00:58:59.000]   das überlasse ich einer späteren Vorlesung.
[00:58:59.000 --> 00:59:04.000]   Die Idee ist, wir bilden den Zustand nach der Ausführung eines Durchlaufs,
[00:59:04.000 --> 00:59:08.000]   also einer Ausführung des Bodys, auf eine ganze Zahl ab.
[00:59:08.000 --> 00:59:11.000]   Und diese ganze Zahl muss größer gleich Null sein.
[00:59:11.000 --> 00:59:16.000]   Und dann muss ich sicherstellen, dass diese Abbildung so ist,
[00:59:16.000 --> 00:59:20.000]   dass jede Ausführung des Loops, das Rumpfes,
[00:59:20.000 --> 00:59:25.000]   also jede Ausführung des Bodys, verkleinert diese Zahl.
[00:59:25.000 --> 00:59:30.000]   Das heißt, diese Zahl wird in jeder Ausführung kleiner, kleiner, kleiner.
[00:59:30.000 --> 00:59:33.000]   Und jetzt muss ich dann, wenn ich jetzt zeigen kann,
[00:59:33.000 --> 00:59:37.000]   dass der Loop-Test vor es ergibt, wenn diese Zahl zu Null wird,
[00:59:37.000 --> 00:59:40.000]   dann habe ich gezeigt, dass dieser Loop terminiert.
[00:59:40.000 --> 00:59:42.000]   Und das muss ich dann machen,
[00:59:42.000 --> 00:59:46.000]   weil wenn ich schrittweise in jeder Ausführung des schleifen Rumpfs
[00:59:46.000 --> 00:59:48.000]   diese Zahl verkleinere,
[00:59:48.000 --> 00:59:51.000]   also muss ich sie mindestens um eins verkleinern,
[00:59:51.000 --> 00:59:54.000]   aber es gibt dann nur eine endliche Anzahl von Schritten,
[00:59:54.000 --> 00:59:58.000]   die ich machen kann, bis dieser Wert Null ergibt.
[00:59:58.000 --> 01:00:01.000]   Weil das ist so eine schöne Sache, die wir mal tick wissen,
[01:00:01.000 --> 01:00:03.000]   dass eben eine Zahl,
[01:00:03.000 --> 01:00:06.000]   eine endliche Anzahl von Subtraktionen ist nötig,
[01:00:06.000 --> 01:00:08.000]   um die auf Null zu bringen.
[01:00:08.000 --> 01:00:10.000]   Und dann haben wir Terminierung gezeigt,
[01:00:10.000 --> 01:00:13.000]   weil wir zeigen, die Ausführung bringt diese Zahl,
[01:00:13.000 --> 01:00:16.000]   die wir da konstruieren auf Null.
[01:00:16.000 --> 01:00:20.000]   Wir haben gezeigt, dass, wenn das Null ist, ergibt der Test false.
[01:00:20.000 --> 01:00:23.000]   Wir wissen, dass, wenn der Wildtest false hat,
[01:00:23.000 --> 01:00:25.000]   dann terminiert die Schleife
[01:00:25.000 --> 01:00:28.000]   und wir erreichen das Statement nach der Schleife.
[01:00:28.000 --> 01:00:31.000]   Dann haben wir also gezeigt, dass der Loop terminiert.
[01:00:31.000 --> 01:00:33.000]   Also die Idee zum Beispiel,
[01:00:33.000 --> 01:00:35.000]   in dem ersten Beispiel,
[01:00:35.000 --> 01:00:40.000]   dass ich hatte, wo wir die Zahlen von 1 bis X aufaddieren wollten,
[01:00:40.000 --> 01:00:42.000]   da kann ich das abbinden,
[01:00:42.000 --> 01:00:45.000]   zum Beispiel auf die Differenz zwischen X und I.
[01:00:45.000 --> 01:00:48.000]   In jedem, in jedem Anfang ist die positiv,
[01:00:48.000 --> 01:00:51.000]   oder zumindest eventuell,
[01:00:51.000 --> 01:00:55.000]   schon jetzt Null, dann wird die Schleife nicht ausgeführt,
[01:00:55.000 --> 01:00:57.000]   aber ist positiv.
[01:00:57.000 --> 01:01:00.000]   Und dann in jeder Interaktion, wo wir I um 1 erhöhen,
[01:01:00.000 --> 01:01:02.000]   wird diese Differenz kleiner.
[01:01:02.000 --> 01:01:05.000]   Wenn ich I um 1, also wenn ich das um 1 erhöhe
[01:01:05.000 --> 01:01:07.000]   und X ist unverändert,
[01:01:07.000 --> 01:01:09.000]   dann wird das in jedem Schritt kleiner.
[01:01:09.000 --> 01:01:13.000]   Und wenn wir den Punkt erreichen, dass X minus I gleich Null ist,
[01:01:13.000 --> 01:01:16.000]   dann wissen wir, dass X gleich I ist,
[01:01:16.000 --> 01:01:19.000]   und dann wissen wir, dass der Loop terminiert.
[01:01:19.000 --> 01:01:21.000]   So kann ich das machen.
[01:01:21.000 --> 01:01:24.000]   Also, das kann ich ein bisschen genauer machen,
[01:01:24.000 --> 01:01:27.000]   aber das ist nur für Sie zur Information.
[01:01:27.000 --> 01:01:29.000]   Das erwarten wir nicht, dass Sie das machen,
[01:01:29.000 --> 01:01:32.000]   werden Sie in der späteren Vorlesung machen.
[01:01:32.000 --> 01:01:36.000]   Oder in diesem Beispiel, wo ich den Quotienten berechnete,
[01:01:36.000 --> 01:01:42.000]   da kann ich eben halt einen Wert R, großes R, finden.
[01:01:42.000 --> 01:01:47.000]   Das ist der Rest, der Rest ist X, divisiert durch Y.
[01:01:47.000 --> 01:01:50.000]   Und wenn ich zeigen kann, dass R minus R,
[01:01:50.000 --> 01:01:52.000]   also kleine, einen großen R,
[01:01:52.000 --> 01:01:54.000]   das das eben, das nehme ich als Abbildung,
[01:01:54.000 --> 01:01:57.000]   und dieser Wert ist am Anfang auch positiv,
[01:01:57.000 --> 01:01:59.000]   aber wird in jeder iteration kleiner,
[01:01:59.000 --> 01:02:07.000]   weil ich eben das kleine R hier immer um Y decrementiere.
[01:02:07.000 --> 01:02:10.000]   Und wenn das Y größer Null ist und so weiter,
[01:02:10.000 --> 01:02:12.000]   dann wird das geht der runter.
[01:02:12.000 --> 01:02:16.000]   Und ich weiß, am Ende, wenn dieser Wert Null hat,
[01:02:16.000 --> 01:02:18.000]   dann gilt eben, dass der Rest,
[01:02:18.000 --> 01:02:22.000]   dass der, dass der in der Berechnung
[01:02:22.000 --> 01:02:24.000]   übrig gebliebene Rest kein R,
[01:02:24.000 --> 01:02:26.000]   genau der Rest ist, den ich bekäme,
[01:02:26.000 --> 01:02:29.000]   wenn ich die eben die Restoperator mache,
[01:02:29.000 --> 01:02:32.000]   und damit weiß ich, dass dann der Loop terminiert.
[01:02:32.000 --> 01:02:34.000]   Und natürlich, wenn diese Funktion
[01:02:34.000 --> 01:02:36.000]   bereits vor Beginn des Loops Null ist,
[01:02:36.000 --> 01:02:39.000]   immer umso besser, dann wird der Loop gar nicht erst ausgeführt.
[01:02:39.000 --> 01:02:41.000]   Also so können Sie das im Prinzip zeigen,
[01:02:41.000 --> 01:02:43.000]   dass Loops terminieren,
[01:02:43.000 --> 01:02:45.000]   für die, die das eben zu langweilig finden,
[01:02:45.000 --> 01:02:47.000]   dass wir das eben ohne Terminierung machen.
[01:02:47.000 --> 01:02:49.000]   So, okay.
[01:02:49.000 --> 01:02:52.000]   Damit habe ich den ersten,
[01:02:52.000 --> 01:02:55.000]   einfach ersten Teil eigentlich erledigt,
[01:02:55.000 --> 01:02:57.000]   und damit können wir jetzt das Gebiet
[01:02:57.000 --> 01:02:59.000]   der einfachen Java-Programme verlassen
[01:02:59.000 --> 01:03:03.000]   und uns etwas komplizierteren Konstrukten beschäftigen,
[01:03:03.000 --> 01:03:07.000]   die vielleicht etwas, die wahrscheinlich Sie auch kennen,
[01:03:07.000 --> 01:03:09.000]   aber die ich trotzdem noch behandeln möchte,
[01:03:09.000 --> 01:03:11.000]   weil die wichtige Voraussetzungen
[01:03:11.000 --> 01:03:13.000]   für die nächsten Schritte sind.
[01:03:13.000 --> 01:03:16.000]   Weil das, was ich Ihnen über Errays erzähle,
[01:03:16.000 --> 01:03:19.000]   ist ganz eng verwandt mit dem, was ich Ihnen danach
[01:03:19.000 --> 01:03:22.000]   über Klassen und Objekte erzähle.
[01:03:22.000 --> 01:03:25.000]   Also Errays sind besondere Arten von Objekten,
[01:03:25.000 --> 01:03:27.000]   und das immer dafür gilt,
[01:03:27.000 --> 01:03:30.000]   gilt in vielen Situationen auch für andere Objekte.
[01:03:30.000 --> 01:03:32.000]   Und deswegen benutzen wir die Errays,
[01:03:32.000 --> 01:03:34.000]   die Sie vielleicht schon kennen,
[01:03:34.000 --> 01:03:36.000]   als Einstieg in diesen Bereich.
[01:03:36.000 --> 01:03:39.000]   Aber natürlich, um Programme interessant zu machen,
[01:03:39.000 --> 01:03:42.000]   müssen wir auch irgendwann mal Input/Output machen.
[01:03:42.000 --> 01:03:44.000]   Also der einfache Input, wo Sie eine Zahl eintippen,
[01:03:44.000 --> 01:03:46.000]   ja, der ist natürlich auch interessant,
[01:03:46.000 --> 01:03:50.000]   und der einfache Output mit dem System.outprint Statement
[01:03:50.000 --> 01:03:53.000]   ist auch interessant, aber natürlich könnte man eigentlich mehr machen,
[01:03:53.000 --> 01:03:55.000]   und das werden wir auch versuchen zu machen.
[01:03:55.000 --> 01:03:59.000]   Also diese Errays und Klassen sind die beiden nächsten Themen.
[01:03:59.000 --> 01:04:03.000]   Und irgendwo, je nachdem, wie viel Zeit ich habe,
[01:04:03.000 --> 01:04:06.000]   abhängig von dem, was die Kollegen in A und D brauchen,
[01:04:06.000 --> 01:04:10.000]   werde ich dann die Input/Output einfügen.
[01:04:10.000 --> 01:04:14.000]   So, ich kenne eigentlich kein gutes deutsches Wort für Errays.
[01:04:14.000 --> 01:04:17.000]   Das beste Wort wäre Reihe.
[01:04:17.000 --> 01:04:19.000]   Es gibt andere Wörter, die sind aber schlecht.
[01:04:19.000 --> 01:04:23.000]   Aber deswegen, denke ich, können wir hier von Errays reden.
[01:04:23.000 --> 01:04:26.000]   Denken, stellen Sie sich vor, ein Errays ist eine Reihe.
[01:04:26.000 --> 01:04:30.000]   Und da fangen wir jetzt an mit einer kleinen Einführung,
[01:04:30.000 --> 01:04:33.000]   und dann werden wir uns, wenn es geht,
[01:04:33.000 --> 01:04:35.000]   heute noch mit dem Thema beschäftigen,
[01:04:35.000 --> 01:04:38.000]   wie wir eigentlich Errays deklarieren und erstellen
[01:04:38.000 --> 01:04:40.000]   und mit denen arbeiten.
[01:04:40.000 --> 01:04:44.000]   Und um zu sehen, warum Errays eine irgendeine Bedeutung haben könnten,
[01:04:44.000 --> 01:04:46.000]   stellen Sie sich vorhin davor Aufgabe vor.
[01:04:46.000 --> 01:04:49.000]   Sie sollen für die Mitglieder eines Sportvereins
[01:04:49.000 --> 01:04:52.000]   oder irgendeine anderen Gruppe irgendwelche Daten analysieren,
[01:04:52.000 --> 01:04:54.000]   zum Beispiel die Durchschnittsgröße.
[01:04:54.000 --> 01:04:58.000]   Und Sie sollen herausfinden, wie viele Spieler oder Spielerinnen
[01:04:58.000 --> 01:05:02.000]   in diesem Verein über, in der Größe, über dem Durchschnitt liegen.
[01:05:02.000 --> 01:05:06.000]   Und das könnte so aussehen, dass eben das Ihr Programm sagt,
[01:05:06.000 --> 01:05:10.000]   wie viele Mitglieder es gibt in diesem Verein oder diesem Team.
[01:05:10.000 --> 01:05:13.000]   Geben Sie doch bitte die Größe für alle ein.
[01:05:13.000 --> 01:05:17.000]   Und dann berechnet das Programm den Durchschnitt und sagt,
[01:05:17.000 --> 01:05:21.000]   okay, in diesem Team sind zwei Personen größer als der Durchschnitt,
[01:05:21.000 --> 01:05:24.000]   und das ist ein Drittel. So was in der Art.
[01:05:24.000 --> 01:05:26.000]   So, das ist eigentlich nicht schwierig.
[01:05:26.000 --> 01:05:30.000]   Im Prinzip haben wir alles gelernt, was wir brauchen,
[01:05:30.000 --> 01:05:33.000]   um so ein Programm zu schreiben.
[01:05:33.000 --> 01:05:38.000]   Was für Schritte wären da nötig für unsere Schleife oder für unser Programm?
[01:05:38.000 --> 01:05:42.000]   Also jeder Wert muss eingegeben werden.
[01:05:42.000 --> 01:05:45.000]   Das müssen wir um den Durchschnitt zu berechnen.
[01:05:45.000 --> 01:05:48.000]   Und dann, wenn wir den Durchschnitt berechnen wollen,
[01:05:48.000 --> 01:05:53.000]   müssen wir eben den Wert eingeben und erstmal die Summe berechnen.
[01:05:53.000 --> 01:05:56.000]   So, und danach, nachdem ich die Summe habe,
[01:05:56.000 --> 01:06:00.000]   kann ich das durch die Anzahl der Mitglieder dividieren.
[01:06:00.000 --> 01:06:04.000]   Das heißt, ich muss eigentlich, wenn ich mir das genau angucke,
[01:06:04.000 --> 01:06:07.000]   diese muss ich zwei Sachen machen.
[01:06:07.000 --> 01:06:11.000]   Ich muss also einmal die Summe berechnen
[01:06:11.000 --> 01:06:17.000]   und ich muss zählen, wie viele Personen nachher größer gleich als der Durchschnitt sind.
[01:06:17.000 --> 01:06:19.000]   Das ist also der Durchschnitt.
[01:06:19.000 --> 01:06:23.000]   Ich muss erzählen, wie viele sind denn jetzt größer oder gleich der Durchschnitt.
[01:06:23.000 --> 01:06:25.000]   Und jetzt sehen Sie das Problem.
[01:06:25.000 --> 01:06:28.000]   Ich muss also erst den Durchschnitt berechnen.
[01:06:28.000 --> 01:06:33.000]   Für den Durchschnitt brauche ich die Summe und die Anzahl der Mitglieder.
[01:06:33.000 --> 01:06:39.000]   Und um herauszufinden, wie viele Personen größer oder gleich der Durchschnitt sind,
[01:06:39.000 --> 01:06:41.000]   brauche ich natürlich den Durchschnitt.
[01:06:41.000 --> 01:06:46.000]   Aber den habe ich ja noch nicht, bis dass ich alle Zahlen gelesen habe.
[01:06:46.000 --> 01:06:50.000]   Ich kann den nicht irgendwie vorher berechnen.
[01:06:50.000 --> 01:06:54.000]   Ich kann einen Vergleich, ob eine Person größer als der Durchschnitt ist.
[01:06:54.000 --> 01:06:58.000]   Die kann ich erst machen, nachdem ich alle Zahlen gelesen habe.
[01:06:58.000 --> 01:07:01.000]   Erst dann kann ich den Durchschnitt berechnen.
[01:07:01.000 --> 01:07:04.000]   Und das heißt, ich muss diese Messwerte bis zum Ende speichern,
[01:07:04.000 --> 01:07:07.000]   um dann festzustellen oder dann zu gucken,
[01:07:07.000 --> 01:07:12.000]   welcher dieser Messwerte oder Eingabewerte eben größer als der Durchschnitt ist.
[01:07:12.000 --> 01:07:16.000]   Und das ist eben problematisch, weil jeder Wert zweimal verwendet werden muss.
[01:07:16.000 --> 01:07:19.000]   Also einmal eben für die Berechnung des Durchschnitts
[01:07:19.000 --> 01:07:23.000]   und zum zweiten, um die Anzahl der Personen, die größer oder gleich,
[01:07:23.000 --> 01:07:25.000]   als der Durchschnitt sind zu berechnen.
[01:07:25.000 --> 01:07:28.000]   Das wäre ja im Prinzip kein Problem.
[01:07:28.000 --> 01:07:33.000]   Wir könnten natürlich jeden Wert einfach in einer variablen Speichern.
[01:07:33.000 --> 01:07:36.000]   Und dann, nachdem wir den Durchschnitt haben, gucken wir uns die Werte an
[01:07:36.000 --> 01:07:40.000]   und zählen, wie viele von denen größer als der Durchschnitt sind.
[01:07:40.000 --> 01:07:43.000]   Aber das Problem ist jetzt, während wir das programmieren,
[01:07:43.000 --> 01:07:49.000]   wir wissen ja nicht, wie viele Personen wir in diesem Programm analysieren müssen.
[01:07:49.000 --> 01:07:52.000]   Das wissen wir erst, wenn das Programm ausgeführt wird.
[01:07:52.000 --> 01:07:55.000]   Wenn jemand sagt, ich möchte das Programm jetzt verwenden.
[01:07:55.000 --> 01:07:59.000]   Das heißt, wir wissen nicht, wie viele Variable wir brauchen.
[01:07:59.000 --> 01:08:02.000]   Und wir können jetzt nicht hingehen und sagen, dann gehen wir mal hin
[01:08:02.000 --> 01:08:06.000]   und machen prophylaktisch 2000 Variable.
[01:08:06.000 --> 01:08:10.000]   Und dann kommt jemand und nimmt als Menge für die Leute,
[01:08:10.000 --> 01:08:14.000]   die das geschickt werden sollen, die Einwohner einer Größe statt.
[01:08:14.000 --> 01:08:16.000]   Und darum geht das nicht.
[01:08:16.000 --> 01:08:23.000]   Also wir brauchen einen Weg, wie wir mehrere Variable auf einmal deklarieren können.
[01:08:23.000 --> 01:08:26.000]   Nicht nur eine Variable, nicht nur zwei,
[01:08:26.000 --> 01:08:31.000]   sondern eben eine im Prinzip unbegrenzte Anzahl von Variablen.
[01:08:31.000 --> 01:08:33.000]   Und das ist die Idee der Erreys.
[01:08:33.000 --> 01:08:38.000]   Ein Erreyerlaub, das uns mehrere Werte des selben Typs zu speichern.
[01:08:38.000 --> 01:08:43.000]   Wir haben eine Variable, die verschiedene Werte des selben Typs speichern kann.
[01:08:43.000 --> 01:08:50.000]   Und jeden Wert in dem Errey, den nennen wir dann eben ein Element des Erreys.
[01:08:50.000 --> 01:08:55.000]   Und wir werden einen Weg brauchen, um uns natürlich auf die unterschiedlichen Werte zu beziehen.
[01:08:55.000 --> 01:09:00.000]   Da wird es dann eben einen Index geben, mit dem wir eben auswählen können,
[01:09:00.000 --> 01:09:02.000]   mit welchem Wert wir da arbeiten wollen.
[01:09:02.000 --> 01:09:06.000]   Und da hat sich eingebürgert, dass wir das erste Element,
[01:09:06.000 --> 01:09:11.000]   das wir dem den Index 0 geben, aber gibt auch andere Programmiersprachen,
[01:09:11.000 --> 01:09:13.000]   in denen das anders gemacht wird.
[01:09:13.000 --> 01:09:15.000]   Aber das ist bei unserem System so üblich.
[01:09:15.000 --> 01:09:19.000]   Also wenn ich so einen Erreyerlaub habe, dann habe ich einen Erreyerinn zum Beispiel für Int-Werte.
[01:09:19.000 --> 01:09:22.000]   Und dieser hat dann eben, hier habe ich 10 Werte.
[01:09:22.000 --> 01:09:26.000]   Und Element mit Index 0 oder Element 0 sagen wir kurz,
[01:09:26.000 --> 01:09:32.000]   er hat eben den Wert 12 und Element mit Index 4 hat den Wert 5 und so weiter.
[01:09:32.000 --> 01:09:38.000]   Also, so ein Errey speichert eben eine ganze Reihe von solchen Werten.
[01:09:38.000 --> 01:09:45.000]   Und eben um damit zu arbeiten, müssen wir natürlich auch wieder die Variable deklarieren.
[01:09:45.000 --> 01:09:47.000]   In Java müssen alle Variable deklariert sein.
[01:09:47.000 --> 01:09:49.000]   Und das gilt auch für Erreys.
[01:09:49.000 --> 01:09:53.000]   Und das kann irgendwo passieren in einer Methode, Main oder wo auch immer.
[01:09:53.000 --> 01:09:57.000]   Und jetzt fangen wir mal an, das erste Beispiel einfach anzugucken,
[01:09:57.000 --> 01:10:00.000]   nämlich wie wir mit so einer Variable arbeiten,
[01:10:00.000 --> 01:10:07.000]   wenn wir die Deklaration und das Erstellen des Erreys kombinieren wollen.
[01:10:07.000 --> 01:10:14.000]   In einem Schritt wollen wir also die Variable deklarieren und zugleich eben erstellen.
[01:10:14.000 --> 01:10:19.000]   Und wenn wir sie erstellen, dann gilt auch, dass sie automatisch initialisiert wird.
[01:10:19.000 --> 01:10:24.000]   Wir wollen keine uninitialisierten Erreys, warum kann ich Ihnen gleich, ja?
[01:10:24.000 --> 01:10:31.000]   Aber wir müssen diese beiden Schritte Deklaration und Erstellen zusammenbringen.
[01:10:31.000 --> 01:10:34.000]   Da gibt es in sich zwei Varianten, das zu machen.
[01:10:34.000 --> 01:10:37.000]   Wir könnten die beiden eben zusammen machen.
[01:10:37.000 --> 01:10:40.000]   Und wenn wir das gesehen haben, wie das geht, dann könnten wir auch sehen,
[01:10:40.000 --> 01:10:44.000]   wie wir eben nur die Deklaration der Variable machen
[01:10:44.000 --> 01:10:49.000]   und dann in einem zweiten Schritt dafür sorgen, dass der Erreys erstellt ist.
[01:10:49.000 --> 01:10:56.000]   Das ist aber der, beide Schritte sind vernünftig, beides Möglichkeiten machen Sinn.
[01:10:56.000 --> 01:10:59.000]   Und wir werden sehen, wann die eine vielleicht interessanter ist als die andere.
[01:10:59.000 --> 01:11:01.000]   Also, wie machen wir das?
[01:11:01.000 --> 01:11:06.000]   Und wie wir halt in Java allgemein eben Variable deklarieren.
[01:11:06.000 --> 01:11:09.000]   Wir haben einen Namen, den Namen der Variable
[01:11:09.000 --> 01:11:15.000]   und da wir den jetzt deklarieren, hat er eben hier Informationen über den Typ.
[01:11:15.000 --> 01:11:20.000]   Und jetzt, da wir hier dieses Gleichheitszeichen sehen, heißt das, das ist eine Zuweisung.
[01:11:20.000 --> 01:11:26.000]   Also, das ist eine Deklaration, die die Initialisierung kombiniert.
[01:11:26.000 --> 01:11:32.000]   Ähnlich wie wir früher gesagt hatten, Integer A wird gesetzt zu zwei.
[01:11:32.000 --> 01:11:37.000]   Da hatten wir die Integer A deklariert und der den gleich den Wert zwei zugewiesen.
[01:11:37.000 --> 01:11:44.000]   Hier deklariere ich einen Reh mit dem Namen "Nehm" und ich weise dem gleich Platz zu.
[01:11:44.000 --> 01:11:49.000]   So, und jetzt am Anfang, haben wir einfaches Beispiel.
[01:11:49.000 --> 01:11:54.000]   Also, wir haben hier diese Name, das ist der Name der Variable
[01:11:54.000 --> 01:12:01.000]   und diese Variable verweist jetzt auf ein Reh mit eben diesen Elementen vom Typ.
[01:12:01.000 --> 01:12:05.000]   Das Typ, den ich hier haben möchte.
[01:12:05.000 --> 01:12:08.000]   Also, diese Variable, die verweist darauf.
[01:12:08.000 --> 01:12:16.000]   Das ist ein Weg für uns, den Speicher zu finden, indem diese ganzen Werte gespeichert werden.
[01:12:16.000 --> 01:12:21.000]   So, jetzt genauer, müsste man das so sehen.
[01:12:21.000 --> 01:12:27.000]   Wir haben hier eine Typdefinition, die in der Deklaration auftritt
[01:12:27.000 --> 01:12:34.000]   und wir haben hier eine andere Typinformation, die in der Initialisierung auftritt.
[01:12:34.000 --> 01:12:40.000]   Jetzt am Anfang, wo wir noch nicht die ganz komplizierten Sachen kennenlernen wollen,
[01:12:40.000 --> 01:12:45.000]   ist es immer so, dass wir denselben Typ auf beiden Seiten verwenden.
[01:12:45.000 --> 01:12:52.000]   Also, wir verlangen zur Zeit für diesen Teil unserer Diskussion,
[01:12:52.000 --> 01:12:56.000]   dass diese beiden Typen identisch sind.
[01:12:56.000 --> 01:13:01.000]   Also, ich kann hier sagen, Int irgendwas braucht dann auch auf der rechten Seite
[01:13:01.000 --> 01:13:04.000]   dieser Zuweisung das Inzeichen.
[01:13:04.000 --> 01:13:09.000]   Das ist einfach die Regel, die wir jetzt zur Zeit mal verlangen,
[01:13:09.000 --> 01:13:12.000]   einfach um das Leben einfacher zu machen.
[01:13:12.000 --> 01:13:20.000]   Ist das Erstellen Initialisieren eines Erreys in Java in der Ordnung N?
[01:13:20.000 --> 01:13:23.000]   Hab ich von der Laufzeitkosten gesprochen?
[01:13:23.000 --> 01:13:26.000]   Nein, also werden wir das später behandeln.
[01:13:26.000 --> 01:13:30.000]   Gucken wir, wer es nachher hier haben.
[01:13:30.000 --> 01:13:34.000]   Also, wir hatten gesagt, der Typ hatten wir gesagt,
[01:13:34.000 --> 01:13:41.000]   das ist der Typ der Elemente und eben, wir haben jetzt eben immer identischen Typ.
[01:13:41.000 --> 01:13:44.000]   Den Namen der Variable, klar, die üblichen Regeln gelten.
[01:13:44.000 --> 01:13:48.000]   Und dann habe ich jetzt hier auf der nächsten Seite, was weiter ist,
[01:13:48.000 --> 01:13:51.000]   also auf der Zuweisungsseite, habe ich hier das New.
[01:13:51.000 --> 01:13:55.000]   Das New ist ein weiterer Operator in Java, was für eine Überraschung.
[01:13:55.000 --> 01:14:00.000]   Das ist ein Operator, der Platz für die Elemente erstellt.
[01:14:00.000 --> 01:14:05.000]   Und längs ist eben ein Ausdruck, das ist ein Ausdruck,
[01:14:05.000 --> 01:14:11.000]   der eben einen Int-Wert liefert und der Int-Wert muss größer gleich 0 sein.
[01:14:11.000 --> 01:14:15.000]   Es macht nicht Sinn zu sagen, wir haben minus zwei Elemente.
[01:14:15.000 --> 01:14:18.000]   Wir haben vielleicht Null-Elemente oder 1 oder 2,
[01:14:18.000 --> 01:14:21.000]   aber wir haben niemals eine negative einzelne Elemente.
[01:14:21.000 --> 01:14:24.000]   Also, legales Beispiel, das ich eben schon zeigte,
[01:14:24.000 --> 01:14:27.000]   ich habe hier eine variable Numbers deklariert,
[01:14:27.000 --> 01:14:31.000]   die sich auf ein Array mit Integers beziehen kann.
[01:14:31.000 --> 01:14:39.000]   Und diese Variable bezieht sich jetzt hier auf einen Array mit 10 Elementen.
[01:14:39.000 --> 01:14:42.000]   Oder ich kann da irgendwelche Variable verwenden,
[01:14:42.000 --> 01:14:45.000]   ich kann da Array mit 10 machen, kommt aufs Gleiche raus.
[01:14:45.000 --> 01:14:50.000]   In diesem Beispiel wieder ist das ein Array mit 10 Elementen.
[01:14:50.000 --> 01:14:55.000]   Also, sowas deklariert die Variable und lässt sie auf ein Array
[01:14:55.000 --> 01:14:59.000]   mit 10 Elementen vom Typ Int verweisen.
[01:14:59.000 --> 01:15:02.000]   Da ist also Platz für diese 10 Int-Werte geschaffen worden.
[01:15:02.000 --> 01:15:09.000]   Und die Frage ist jetzt eben halt, was für, was für Werte sind denn da?
[01:15:09.000 --> 01:15:15.000]   Und wir wollen natürlich nicht, dass wenn ein Programm ein Array erstellt,
[01:15:15.000 --> 01:15:19.000]   dass das Programm lesen kann, was da vielleicht zufälligerweise
[01:15:19.000 --> 01:15:24.000]   in dem Speicher im Prozessor drinsteht.
[01:15:24.000 --> 01:15:26.000]   Wir wollen nicht, dass eben das Programm,
[01:15:26.000 --> 01:15:30.000]   vielleicht die Daten eines anderen Programms illegaler, illegalerweise liest.
[01:15:30.000 --> 01:15:32.000]   Und darum haben wir in Java die Regel,
[01:15:32.000 --> 01:15:37.000]   dass eben die, die, diese Operation des Erstellens
[01:15:37.000 --> 01:15:41.000]   einen wohl definierten Wert erbringen muss.
[01:15:41.000 --> 01:15:45.000]   Also, das schönen Nebeneffekt ist, dass wir wiederholte Ausführung
[01:15:45.000 --> 01:15:47.000]   bekommen, wer dasselbe resultat.
[01:15:47.000 --> 01:15:49.000]   Weil wenn immer ich ein Array erstelle,
[01:15:49.000 --> 01:15:55.000]   wird der eben auf, werden die Elemente auf einen vorher definierten Wert gesetzt.
[01:15:55.000 --> 01:15:58.000]   Und der Wert, den wir dafür nehmen, also nicht wir,
[01:15:58.000 --> 01:16:00.000]   sondern das System dafür nimmt, ist,
[01:16:00.000 --> 01:16:04.000]   der nehmen wir einen Wert, der null entspricht.
[01:16:04.000 --> 01:16:07.000]   Was immer null im entsprechenden Typ sein mag.
[01:16:07.000 --> 01:16:11.000]   Also, wenn es ganze Zahlen sind, wie ins oder longs,
[01:16:11.000 --> 01:16:15.000]   dann ist der null Wert die Zahl null, die bekannte Zahl null.
[01:16:15.000 --> 01:16:21.000]   Wenn es eben doubles sind, dann ist es die reelle Zahl 0.0.
[01:16:21.000 --> 01:16:23.000]   Wenn es Boolean sind, hat man sich entschieden,
[01:16:23.000 --> 01:16:25.000]   dass der null Wert false ist.
[01:16:25.000 --> 01:16:27.000]   Und wenn es ein String ist,
[01:16:27.000 --> 01:16:29.000]   mehr haben wir ja bisher an Typen nicht kennengelernt,
[01:16:29.000 --> 01:16:31.000]   dann ist es ein besonderer Wert,
[01:16:31.000 --> 01:16:33.000]   auf den ich nachher noch zu sprechen kommen werde,
[01:16:33.000 --> 01:16:36.000]   der null heißt, auf den komme ich dann gleich zu sprechen.
[01:16:36.000 --> 01:16:42.000]   Also, so kann ich es also hingehen und einen Array deklarieren
[01:16:42.000 --> 01:16:44.000]   und zugleich erstellen.
[01:16:44.000 --> 01:16:49.000]   Es gibt manchmal Situationen, wo ich den Array erst deklarieren will,
[01:16:49.000 --> 01:16:51.000]   aber noch nicht erstellen will.
[01:16:51.000 --> 01:16:56.000]   Und das passiert ganz einfach, indem wir eben keine rechte Seite haben.
[01:16:56.000 --> 01:17:00.000]   Ich habe also diese Typinformationen mit diesen wichtigen,
[01:17:00.000 --> 01:17:04.000]   eckigen Klammern, die mir sagen, dass es sich um einen Array handelt.
[01:17:04.000 --> 01:17:07.000]   Und das deklariert jetzt eine Variable,
[01:17:07.000 --> 01:17:11.000]   die auf Arrays dieses Typ hier verweisen kann.
[01:17:11.000 --> 01:17:15.000]   Also, ich kann hier zum Beispiel diesen Array,
[01:17:15.000 --> 01:17:18.000]   habe ich hier jetzt nochmal deklariert,
[01:17:18.000 --> 01:17:22.000]   eben das heißt, Numbers kann sich auf irgendwelche Rays
[01:17:22.000 --> 01:17:24.000]   mit Int-Elementen beziehen.
[01:17:24.000 --> 01:17:27.000]   Und ich weiß halt noch nicht, wie viele das sind.
[01:17:27.000 --> 01:17:31.000]   Ich weiß halt nur, dass sich Numbers auf einen Array beziehen wird,
[01:17:31.000 --> 01:17:33.000]   der Int-Werte hat.
[01:17:33.000 --> 01:17:36.000]   Das kann ein Array mit 10 Int-Werten sein,
[01:17:36.000 --> 01:17:39.000]   mit 42, mit 7, irgendwas.
[01:17:39.000 --> 01:17:43.000]   Natürlich, bevor ich da irgendwelche Werte mir angucken kann,
[01:17:43.000 --> 01:17:45.000]   muss es irgendeine Zuweisung geben,
[01:17:45.000 --> 01:17:51.000]   die diese Variable auf einen echten Array verweisen lässt.
[01:17:51.000 --> 01:17:57.000]   Also, Array erlaubt es uns, mehrere Elemente des selben Typs zu speichern.
[01:17:57.000 --> 01:18:01.000]   Elemente sind eben die Werte, die wir in dem Array speichern.
[01:18:01.000 --> 01:18:07.000]   Jedes Element hat einen Index, mit dem wir das Element auswählen können.
[01:18:07.000 --> 01:18:10.000]   Das muss eine Zahl größer, gleich null sein.
[01:18:10.000 --> 01:18:16.000]   Und eben, die erste Element hat den Index null, also Element null,
[01:18:16.000 --> 01:18:18.000]   ist das allererste Element.
[01:18:18.000 --> 01:18:22.000]   Also, wenn ich jetzt eben so ein Array habe
[01:18:22.000 --> 01:18:24.000]   und auf das Element zugreifen will,
[01:18:24.000 --> 01:18:28.000]   dann brauche ich die Variable, die sich auf den Array bezieht.
[01:18:28.000 --> 01:18:31.000]   Und dann brauche ich eben einen Konstrukt,
[01:18:31.000 --> 01:18:34.000]   den mir sagt, welches Element ich auswählen will.
[01:18:34.000 --> 01:18:39.000]   Und das geschieht so, dass ich halt hier den,
[01:18:39.000 --> 01:18:44.000]   ich habe hier den Namen der Variable,
[01:18:44.000 --> 01:18:48.000]   dann habe ich hier wieder die eckigen Klammern,
[01:18:48.000 --> 01:18:51.000]   die werden hier auch verwendet, so, die eckigen Klammern.
[01:18:51.000 --> 01:18:54.000]   Und dann habe ich hier eben einen Ausdruck,
[01:18:54.000 --> 01:18:58.000]   der den Index berechnet und eben auswählt,
[01:18:58.000 --> 01:19:00.000]   welches Element ich haben will.
[01:19:00.000 --> 01:19:02.000]   Ich habe also so einen Konstrukt.
[01:19:02.000 --> 01:19:05.000]   Und dann habe ich hier, wie in allen anderen Zuweisungen,
[01:19:05.000 --> 01:19:07.000]   das ist eine normale Zuweisung,
[01:19:07.000 --> 01:19:10.000]   dann habe ich hier irgendeinen Ausdruck,
[01:19:10.000 --> 01:19:16.000]   der eben einen Wert vom Typ der Elemente des Arrays ergeben muss.
[01:19:16.000 --> 01:19:20.000]   Oder gegebenenfalls nach automatischer Umwandlung,
[01:19:20.000 --> 01:19:24.000]   einen Wert ergibt, den ich dann da speichern kann.
[01:19:24.000 --> 01:19:26.000]   Und diese Zuweisung führt dann dazu,
[01:19:26.000 --> 01:19:30.000]   dass das entsprechende Element dieses Arrays modifiziert wurde
[01:19:30.000 --> 01:19:33.000]   und danach den neuen Wert hat.
[01:19:33.000 --> 01:19:38.000]   So, und das ist eben der Weg, wie ich das da machen kann.
[01:19:38.000 --> 01:19:43.000]   Ja, wenn ich hier diesen Array in Data deklariert habe,
[01:19:43.000 --> 01:19:47.000]   irgendwann setze ich diesen Array auf dahin,
[01:19:47.000 --> 01:19:51.000]   dass er, nehme ich diese Arrayvariable,
[01:19:51.000 --> 01:19:54.000]   um auf einen echten Array zu verweisen.
[01:19:54.000 --> 01:19:57.000]   Also hier den Array mit zehn Elementen.
[01:19:57.000 --> 01:20:00.000]   Und jetzt kann ich zum Beispiel zwei dieser Elemente
[01:20:00.000 --> 01:20:05.000]   auf einen Wert setzen, den ich für dieses Programm brauche.
[01:20:05.000 --> 01:20:07.000]   So, das ist also der Weg,
[01:20:07.000 --> 01:20:10.000]   wie ich die Elemente des Arrays modifiziere.
[01:20:10.000 --> 01:20:13.000]   Und wenn ich jetzt so ein Element lesen will,
[01:20:13.000 --> 01:20:16.000]   dann ist das analog, ja?
[01:20:16.000 --> 01:20:20.000]   Also der gleiche Konstrukt, ich habe den Namen,
[01:20:20.000 --> 01:20:22.000]   ich habe die beiden eckigen Klammern,
[01:20:22.000 --> 01:20:24.000]   ich habe einen Indexaufdruck,
[01:20:24.000 --> 01:20:27.000]   aber das erscheint dann eben auf der rechten Seite.
[01:20:27.000 --> 01:20:30.000]   Also das ist wahrscheinlich hier, auf der rechten Seite
[01:20:30.000 --> 01:20:35.000]   habe ich jetzt die Gelegenheit, das Element mit dem Index 0 zu lesen.
[01:20:35.000 --> 01:20:37.000]   Und hier lese ich Element mit Index 3.
[01:20:37.000 --> 01:20:42.000]   Und dann addiere ich die beiden und dann gibt es das gewünschte Ergebnis.
[01:20:42.000 --> 01:20:45.000]   So geht das auch eine große Schwierigkeit.
[01:20:45.000 --> 01:20:49.000]   Und das funktioniert auch für alle anderen Typen, die wir kennen,
[01:20:49.000 --> 01:20:53.000]   Bullions und so weiter, kann ich das genauso machen.
[01:20:53.000 --> 01:20:57.000]   Natürlich ist, kann ich nicht einen beliebigen Indexwert wählen,
[01:20:57.000 --> 01:21:00.000]   ich kann nur einen Indexwert finden
[01:21:00.000 --> 01:21:06.000]   und mit dem arbeiten der zwischen 0 und der Länge des Arrays minus 1 ist.
[01:21:06.000 --> 01:21:08.000]   Wenn ich diesen Array mit zehn Elementen habe,
[01:21:08.000 --> 01:21:14.000]   dann sind 0 und 9 die beiden Grenzen, also Element 0 existiert,
[01:21:14.000 --> 01:21:18.000]   mit Index 9 existiert, aber alles was weiter draußen ist,
[01:21:18.000 --> 01:21:22.000]   10, 11 oder negative Zahlen existiert nicht
[01:21:22.000 --> 01:21:26.000]   und wird nicht, das System mag das nicht.
[01:21:26.000 --> 01:21:29.000]   Also wenn ich dann hingehen sollte
[01:21:29.000 --> 01:21:34.000]   und eben auf Elemente, wie das Element mit Index 0 und 9 zugreifen,
[01:21:34.000 --> 01:21:36.000]   dann funktioniert das fein.
[01:21:36.000 --> 01:21:40.000]   Aber wenn ich eben auf, versuche auf Element mit Index minus 1
[01:21:40.000 --> 01:21:43.000]   oder Index 10 zuzugreifen, dann gibt es eine Exception
[01:21:43.000 --> 01:21:50.000]   und eine Exception, die bewirkt dann einen Abbruch der Ausführung dieses Programms.
[01:21:50.000 --> 01:21:52.000]   Und da ist die Frage, was mache ich denn,
[01:21:52.000 --> 01:21:56.000]   wenn ich in einem Array Element mit unterschiedlichen Typen speichern möchte,
[01:21:56.000 --> 01:22:00.000]   dann ändern Sie Ihre Wünsche, das können Sie nicht.
[01:22:00.000 --> 01:22:06.000]   In einem Array können Sie nur Werte des selben Typs speichern.
[01:22:06.000 --> 01:22:09.000]   Es gibt weitere Möglichkeiten, das später noch zu erweitern,
[01:22:09.000 --> 01:22:11.000]   aber das ist halt die Regel.
[01:22:11.000 --> 01:22:16.000]   Also, da können Sie, für wen das zu einfach ist und zu langweilig ist,
[01:22:16.000 --> 01:22:22.000]   ist es okay, ich habe hier diesen Array, also ich habe diesen Array erstellt, hier oben,
[01:22:22.000 --> 01:22:26.000]   mit nur 8 Elementen, damit ich Platz habe.
[01:22:26.000 --> 01:22:30.000]   Dann initialisiere ich einzelne diese Elemente,
[01:22:30.000 --> 01:22:33.000]   dann gehe ich hin, wähle ein Element aus,
[01:22:33.000 --> 01:22:38.000]   ich nehme mal ein Element mit Index 1, das hat den Wert 3,
[01:22:38.000 --> 01:22:44.000]   dann benutze ich das Element, um zum Beispiel das Element mit Index 3 zu verändern,
[01:22:44.000 --> 01:22:49.000]   dann benutze ich den Wert des Element mit Index 6,
[01:22:49.000 --> 01:22:54.000]   um ein anderes Element auszuwählen und das habe ich dann geändert.
[01:22:54.000 --> 01:22:59.000]   Also, Sie können da genügend viele Programme sich überlegen,
[01:22:59.000 --> 01:23:01.000]   die genügend interessant sind.
[01:23:01.000 --> 01:23:03.000]   So, jetzt wenn Sie so ein Array haben,
[01:23:03.000 --> 01:23:10.000]   dann wollen Sie im Allgemeinen da nicht nur als Werte eben den voreingestellten Wert 0 haben,
[01:23:10.000 --> 01:23:14.000]   sondern da wollen Sie irgendwelche anderen Werte haben, wollen die ausgeben.
[01:23:14.000 --> 01:23:16.000]   Und das können Sie natürlich gut in der Vorschleife machen,
[01:23:16.000 --> 01:23:21.000]   also Vorschleife und Arrays gehen im Allgemeinen gut miteinander zusammen,
[01:23:21.000 --> 01:23:22.000]   Sie alle drucken wollen,
[01:23:22.000 --> 01:23:26.000]   oder wenn Sie hier die Elemente auf einen bestimmten Wert setzen wollen,
[01:23:26.000 --> 01:23:29.000]   das funktioniert alles gut.
[01:23:29.000 --> 01:23:31.000]   Allerdings, diese beiden Beispiele, die ich Ihnen zeige,
[01:23:31.000 --> 01:23:33.000]   haben einen Schönheitsfehler, ja.
[01:23:33.000 --> 01:23:35.000]   Hier habe ich den Loop so geschrieben,
[01:23:35.000 --> 01:23:38.000]   dass er für acht Elemente arbeitet.
[01:23:38.000 --> 01:23:40.000]   Oder hier habe ich den Loop auch so geschrieben,
[01:23:40.000 --> 01:23:42.000]   dass er für acht Elemente arbeitet.
[01:23:42.000 --> 01:23:45.000]   Und das ist eigentlich unschön,
[01:23:45.000 --> 01:23:47.000]   weil in diesem Beispiel ging das halt glatt,
[01:23:47.000 --> 01:23:53.000]   weil ich eben halt nur ein Array benutze, der acht Elemente hat.
[01:23:53.000 --> 01:23:59.000]   Aber diese variable Numbers kann sich ja auf Arrays beliebiger Größe beziehen.
[01:23:59.000 --> 01:24:01.000]   Und das wollen wir natürlich nicht,
[01:24:01.000 --> 01:24:04.000]   weil wenn ich jetzt einen Array mit Werte, mit Länge zehn hätte,
[01:24:04.000 --> 01:24:06.000]   würden einige Elemente uninitialisiert sein.
[01:24:06.000 --> 01:24:09.000]   Und wenn ich einen Array mit Länge sechs hätte,
[01:24:09.000 --> 01:24:11.000]   dann würde eben halt das zur Folge haben,
[01:24:11.000 --> 01:24:13.000]   dass ich eine Exception bekomme.
[01:24:13.000 --> 01:24:16.000]   Und darum gibt es einen Weg im Programm,
[01:24:16.000 --> 01:24:20.000]   festzustellen, wie viele Elemente ein gegebener Array hat.
[01:24:20.000 --> 01:24:25.000]   Und das ist ein Attribut dieses Arrays, also eine Eigenschaft des Arrays.
[01:24:25.000 --> 01:24:30.000]   Und den finde ich, indem ich eben halt den Namen des Arrays benutze
[01:24:30.000 --> 01:24:33.000]   und dann den berühmten dort, den Punkt,
[01:24:33.000 --> 01:24:36.000]   und dann eben halt längst das Attributabfrage.
[01:24:36.000 --> 01:24:38.000]   So könnte ich den Loop so schreiben,
[01:24:38.000 --> 01:24:42.000]   dass er eben halt für eine beliebige Anzahl
[01:24:42.000 --> 01:24:44.000]   für einen beliebigen Array funktioniert.
[01:24:44.000 --> 01:24:48.000]   Egal, wie lang der Array ist, dieser Loop funktioniert immer
[01:24:48.000 --> 01:24:52.000]   und rückt jedes Element dieses Arrays aus.
[01:24:52.000 --> 01:24:55.000]   Also wichtig ist, das ist ein Attribut.
[01:24:55.000 --> 01:25:00.000]   Und darum eben halt besteht das nur eben aus diesem Namen des Attributs.
[01:25:00.000 --> 01:25:05.000]   Im Gegensatz zu Strings, wo wir eine Methode, eine Operation hatten
[01:25:05.000 --> 01:25:09.000]   und daher Klammern nötig waren, gibt es hier keine Klammern.
[01:25:09.000 --> 01:25:13.000]   Hier ist einfach das Attribut, das wir brauchen können.
[01:25:13.000 --> 01:25:16.000]   So, jetzt wollte ich eigentlich einen Pool machen.
[01:25:16.000 --> 01:25:19.000]   Können wir, wollen Sie das noch machen?
[01:25:19.000 --> 01:25:22.000]   Ja, also machen wir die Pool noch.
[01:25:22.000 --> 01:25:25.000]   Wir haben hier dieses Längsattribut
[01:25:25.000 --> 01:25:28.000]   und Sie sollen jetzt zwei Sachen eingeben.
[01:25:28.000 --> 01:25:31.000]   Nämlich, was für einen Ausdruck würden wir denn benutzen wollen,
[01:25:31.000 --> 01:25:35.000]   wenn wir auf das letzte Element eines Arrays zugreifen wollen.
[01:25:35.000 --> 01:25:38.000]   Und was für einen Ausdruck wollen wir benutzen,
[01:25:38.000 --> 01:25:42.000]   wenn wir auf das Element in der Mitte zugreifen wollen?
[01:25:42.000 --> 01:25:46.000]   Jetzt das Element in der Mitte ist etwas trickiger,
[01:25:46.000 --> 01:25:51.000]   weil wenn natürlich die Anzahl der Elemente ungerade ist,
[01:25:51.000 --> 01:25:53.000]   ist die Mitte klar definiert.
[01:25:53.000 --> 01:25:55.000]   Das ist das Element hier.
[01:25:55.000 --> 01:25:57.000]   Aber wenn die Anzahl der Elemente gerade ist,
[01:25:57.000 --> 01:25:59.000]   dann ja, was ist dann die Mitte?
[01:25:59.000 --> 01:26:02.000]   Könnten wir diesen Wert nehmen oder könnten diesen Wert nehmen?
[01:26:02.000 --> 01:26:04.000]   Und wir haben uns da entschieden,
[01:26:04.000 --> 01:26:06.000]   wir konnten entscheiden,
[01:26:06.000 --> 01:26:12.000]   dass wir als Mitte den Wert nehmen, den wir hier eben ausgewählt haben.
[01:26:12.000 --> 01:26:14.000]   Weil das nicht eindeutig,
[01:26:14.000 --> 01:26:17.000]   sondern man könnte auch genauso gut anders argumentieren.
[01:26:17.000 --> 01:26:21.000]   Aber die Entscheidung von vielen wurde halt so gefällt,
[01:26:21.000 --> 01:26:24.000]   dass man eben halt diesen Wert dafür nimmt.
[01:26:24.000 --> 01:26:28.000]   Also, Sie sollen jetzt eben halt in den Kricker,
[01:26:28.000 --> 01:26:31.000]   wir sagen, was für Ausdrücke sollten hier rein,
[01:26:31.000 --> 01:26:33.000]   damit wir entweder das letzte Element
[01:26:33.000 --> 01:26:37.000]   oder das Element in der Mitte auswählen.
[01:26:37.000 --> 01:26:40.000]   Die Zeit haben wir noch,
[01:26:40.000 --> 01:26:43.000]   weil wir haben ja auch paar Minuten zu Nacht spielen.
[01:26:43.000 --> 01:26:47.000]   Also, vielleicht bekomme ich eine Antwort, habe ich schon.
[01:26:47.000 --> 01:26:52.000]   Ich habe da verschiedene Möglichkeiten zur Auswahl Ihnen gegeben.
[01:26:52.000 --> 01:26:55.000]   Und Sie sollen gucken, ob eine von denen überhaupt richtig ist
[01:26:55.000 --> 01:26:59.000]   und ob eben gegebenenfalls da eine Änderung nötig ist.
[01:26:59.000 --> 01:27:09.000]   Okay, ich mache noch 30 Sekunden.
[01:27:09.000 --> 01:27:16.000]   Und dann, ja, hier haben wir schon viele Anmeldungen.
[01:27:16.000 --> 01:27:18.000]   Okay, sehr gut, super, super.
[01:27:18.000 --> 01:27:25.000]   Also, ich denke, das haben Sie überwiegend richtig gemacht.
[01:27:25.000 --> 01:27:29.000]   Das ist sehr gut, da bin ich beruhigt.
[01:27:29.000 --> 01:27:33.000]   Also, hier das letzte Element ist,
[01:27:33.000 --> 01:27:36.000]   wir nehmen halt das Längsattribut und ziehen eins ab.
[01:27:36.000 --> 01:27:42.000]   Und das Element in der Mitte wäre eben halt die Länge minus 1 dividiert durch 2.
[01:27:42.000 --> 01:27:46.000]   Und noch als letzter Punkt, wenn Sie jetzt ein echtes Programm haben,
[01:27:46.000 --> 01:27:49.000]   dann natürlich würden Sie wahrscheinlich Dateien lesen.
[01:27:49.000 --> 01:27:51.000]   Das haben wir, die Möglichkeit haben wir noch nicht.
[01:27:51.000 --> 01:27:56.000]   Darum gibt es einen einfachen Weg, in Java Arrays zu initialisieren,
[01:27:56.000 --> 01:27:59.000]   indem wir halt einen Array deklarieren
[01:27:59.000 --> 01:28:04.000]   und dann gleich die Werte, die der Array haben soll, angeben.
[01:28:04.000 --> 01:28:08.000]   Und dann wird ein Array der entsprechenden Länge konstruiert.
[01:28:08.000 --> 01:28:11.000]   Und das geht nicht nur für ins, das geht auch für alle anderen Typen.
[01:28:11.000 --> 01:28:14.000]   Und damit haben wir eigentlich jetzt genug Informationen,
[01:28:14.000 --> 01:28:18.000]   um das Programm, das Sie Ihnen am Anfang zeigte, schreiben zu wollen.
[01:28:18.000 --> 01:28:22.000]   Also, das ist das, was wir heute machen wollen.
[01:28:22.000 --> 01:28:28.000]   Nächste Woche machen wir dann weiter, wie wir mit diesen Arrays weiterarbeiten können
[01:28:28.000 --> 01:28:31.000]   und insbesondere, wie wir mit Arrays und Methoden arbeiten können.
[01:28:31.000 --> 01:28:34.000]   Okay, schönes Wochenende, bis Dienstag.
[01:28:34.000 --> 01:28:36.000]   (Beifall)
[01:28:36.000 --> 01:28:38.000]   Video und Video von Downtown Los Angeles.

