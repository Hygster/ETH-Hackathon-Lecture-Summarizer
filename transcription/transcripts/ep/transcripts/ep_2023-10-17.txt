
[00:00:00.000 --> 00:00:08.400]   Wir wollen uns weiter mit dem Thema Errays beschäftigen und verschiedene Aspekte des
[00:00:08.400 --> 00:00:16.240]   Arbeiten mit Errays kennenlernen. Also jetzt zuerst noch mal zur Einleitung oder Erinnerung,
[00:00:16.240 --> 00:00:24.800]   dass eben eine Referenzvariable erlaubt uns den Zugriff auf einen Erray. Also wenn wir eine
[00:00:24.800 --> 00:00:31.000]   Erray Variable deklarieren von der Art zum Beispiel sagen ein Integer Erray wollen wir gerne mit dem
[00:00:31.000 --> 00:00:37.520]   wollen wir arbeiten. Dann ist das X eine Referenzvariable die es uns erlaubt Zugriff auf einen
[00:00:37.520 --> 00:00:43.200]   Erray zu machen. So wie ich es hier unten auch hingeschrieben habe. Also das ist eben eine
[00:00:43.200 --> 00:00:50.680]   nicht der Errays selbst sondern ist eine Variable die auf diesen Errays verweist und in Java ist es
[00:00:50.680 --> 00:00:57.120]   halt so wir müssen angeben was für Elemente in diesem Erray drin sind. Wir können den nicht
[00:00:57.120 --> 00:01:02.560]   für andere Sachen verwenden obwohl einige das gerne wollten und das werden wir hier noch mal sehen
[00:01:02.560 --> 00:01:08.200]   was da genauer Einschränkungen sind. Aber das ist halt die Regel mit der wir leben müssen und
[00:01:08.200 --> 00:01:13.040]   nachdem wir das gemacht haben nachdem wir also so eine Referenzvariable deklariert haben,
[00:01:13.040 --> 00:01:18.880]   da existiert noch kein Erray. Das ist nur wir sagen jetzt hier ist eine Variable mit der wir uns
[00:01:18.880 --> 00:01:25.640]   auf einen Erray beziehen können wenn diese Variable mal später auf einen echten Erray verweist. Also
[00:01:25.640 --> 00:01:31.800]   um auf einen wirklichen Erray zu verweisen müssen wir jetzt erst dafür sorgen dass diese Referenz
[00:01:31.800 --> 00:01:41.160]   Variable eine Referenz zugewiesen wird. Also ein Verweis auf einen echten Erray zugewiesen wird.
[00:01:41.160 --> 00:01:46.200]   So könnte wir sagen hier wir haben diese Variable Mai Erray und die lassen wir jetzt hier auf einen
[00:01:46.200 --> 00:01:54.720]   Erray verweisen der Platz für 10 Integers also Int hat, für 10 ganze Zahlen hat und der New Operator
[00:01:54.720 --> 00:02:01.360]   den wir hier verwenden der New Operator der konstruiert und so einen Erray. Da ist Platz für
[00:02:01.360 --> 00:02:06.360]   diese 10 Ints für diese 10 Zahlen und vielleicht noch ein bisschen mehr ist aber kein Problem für uns.
[00:02:06.360 --> 00:02:12.440]   Also so können wir diese Referenz Variable auf einen richtigen Erray verweisen lassen oder
[00:02:12.440 --> 00:02:19.720]   aber wir deklarieren die Referenz Variables an einem Punkt und dann später gehen wir hin und
[00:02:19.720 --> 00:02:24.920]   weisen diese Referenz Variable jetzt in diesem Beispiel hier wieder die Referenz auf einen Erray
[00:02:24.920 --> 00:02:35.200]   von 10 Elementen zu. Sie sind, warten Sie sich, jemand sagt der könne uns schlecht hören. Ich kann
[00:02:35.200 --> 00:02:43.240]   schlecht lauter reden aber ich sollte in der Lage sein das hier zu erhöhen. So, gucken wir mal. Ich
[00:02:43.240 --> 00:02:49.440]   habe jetzt die Lautstärke ein bisschen rauf gedreht. Ich hoffe sie haben jetzt keine Hörschäden. Ich
[00:02:49.440 --> 00:02:55.360]   weiß, wenn sie mit ihrem Nachbar reden muss ich immer noch lauter reden aber wie gesagt wenn der
[00:02:55.360 --> 00:03:00.880]   oder diejenige die das geschrieben hat bestätigen könnte, dass das jetzt besser ist oder schlechter
[00:03:00.880 --> 00:03:07.120]   oder noch mehr, dann können wir das anpassen, dass es für alle richtig ist. Also ich kann also
[00:03:07.120 --> 00:03:13.520]   diesem Erray hier, dieser Referenz Variable eben den Verweis auf diesen Erray zuweisen oder
[00:03:13.520 --> 00:03:19.280]   ich könnte irgendwann im Verlauf des Programms oder aber ich könnte und das geht aber nur in
[00:03:19.280 --> 00:03:24.000]   der Initialisierung. Ich könnte sofort einen Erray konstruieren lassen. Hier würde ich dann einen
[00:03:24.000 --> 00:03:30.920]   Erray mit vier Zahlen bekommen. Die hätten gerade diese Werte. Das geht aber nur, das kann ich nicht
[00:03:30.920 --> 00:03:39.600]   irgendwie im Programm machen. Das geht nur, wenn eben halt ich den Erray deklariere. Dann kann
[00:03:39.600 --> 00:03:46.080]   ich das machen. Dann kann ich das gleich so machen. Also diese Referenzvariable kann ich verwenden wie
[00:03:46.080 --> 00:03:50.520]   jede andere Variable. Ich kann also auch wiederholte Zuweisungen machen. Also ich kann schon einmal
[00:03:50.520 --> 00:03:56.080]   diese Referenzvariable hier einmal deklarieren und gleich auf diesen Erray zuweisen lassen. Und
[00:03:56.080 --> 00:03:59.820]   dann kann ich sagen, jetzt brauche ich diese Referenzvariable für was anderes. Und jetzt gehe
[00:03:59.820 --> 00:04:04.480]   ich hin und lasse ich sich hier auf einen anderen Erray zuweisen, den ich jetzt gerade an dieser
[00:04:04.480 --> 00:04:10.320]   Stelle konstruiere. Und wenn ich den Konstruiere und nichts anderes mache, dann besteht der aus drei
[00:04:10.320 --> 00:04:16.720]   Elementen, die alle null sind. Und jetzt kommt der interessante Teil oder der Teil, der manchmal
[00:04:16.720 --> 00:04:23.520]   zu nachdenken zwingen muss. Ich kann auch diese Referenzvariable benutzen, um einen anderen,
[00:04:23.520 --> 00:04:30.120]   um sie in einem anderen, eine andere Referenzvariable zu speichern. Also ich habe hier die Referenzvariable
[00:04:30.120 --> 00:04:35.880]   U-Array her und die lasse ich jetzt verweisen, das ist jetzt eine Zuweisung, auf denselben Array,
[00:04:35.880 --> 00:04:42.080]   den ich jetzt hier oben konstruiert habe oder irgendwie verarbeitet habe. Ich habe jetzt hier
[00:04:42.080 --> 00:04:49.360]   zwei Referenzvariable U-Array und Mai-Array, die beide auf denselben Array verweisen. Also so kann
[00:04:49.360 --> 00:04:55.160]   ich eine Referenzvariable nutzen, um auch auf einen anderen Array zu verweisen. Also hier habe ich
[00:04:55.160 --> 00:05:01.240]   in diesem einfachen Beispiel einen Array A, der hat fünf Elemente und dann habe ich einen Array B,
[00:05:01.240 --> 00:05:06.880]   der hat hier vier Elemente. Mit diesen Werten habe ich die mal initialisiert. Und jetzt gehe ich
[00:05:06.880 --> 00:05:14.640]   hin und benutze die Referenz, die in der Referenzvariable B, das ist hier, gespeichert ist, um sie in der
[00:05:14.640 --> 00:05:21.640]   Referenzvariable A zu speichern. Das heißt also jetzt verweist A auf denselben Array wie auf
[00:05:21.640 --> 00:05:27.400]   diesen WB verweist. Also A verweist nicht mehr auf den Array, auf den es am Anfang verwies,
[00:05:27.400 --> 00:05:33.240]   sondern verweist jetzt auch auf diesen Array. Und wenn ich so was machen will, dann muss die rechte
[00:05:33.240 --> 00:05:39.240]   Seite hier auch eine Referenzvariable sein. Und nicht nur irgendeine Referenzvariable, es muss
[00:05:39.240 --> 00:05:44.240]   eine Referenzvariable sein, wo der Typ der Elemente stimmt. Die Anzahl muss nicht stimmen. Sie sehen,
[00:05:44.240 --> 00:05:50.280]   der eine Array hatte vier, der andere hatte fünf Elemente. Die Anzahl der Elemente spielt keine Rolle,
[00:05:50.280 --> 00:05:56.040]   aber der Typ muss stimmen. Also auf der rechten Seite wollen wir immer nur eine Referenzvariable
[00:05:56.040 --> 00:06:04.040]   sehen, dasselben Typs, das richtigen Typs oder natürlich den New Operator, der eben einen neuen
[00:06:04.040 --> 00:06:11.080]   anonymen Array erst mal konstruiert und den wir dann eben halt weiter verwenden können. Also,
[00:06:11.080 --> 00:06:17.000]   wenn ich so was habe, jetzt habe ich jetzt hier die Situation, dass A und B auf denselben Array
[00:06:17.000 --> 00:06:22.760]   verweisen. Und was mache ich denn jetzt, wenn dieses A nicht mehr auf diesen Array verweisen soll? Also
[00:06:22.760 --> 00:06:27.960]   wenn ich praktisch verhindern will, dass das A weiter auf diesen Array verweisen. Naja, jetzt muss
[00:06:27.960 --> 00:06:33.680]   ich dann dieser Referenzvariable A einen besonderen Wert zuweisen. Und dafür benutzen wir diesen
[00:06:33.680 --> 00:06:40.280]   besonderen Wert Null. Das ist ein Wert, der geht für alle Referenzvariablen, der geht für also sowohl
[00:06:40.280 --> 00:06:44.760]   für Arrays, als auch später, wenn wir sehen für Objekte, der geht für andere Objekte, der geht
[00:06:44.760 --> 00:06:50.080]   für alles. Und wenn ich das gemacht habe, weil wenn ich der Referenzvariable A den Wert Null
[00:06:50.080 --> 00:06:56.800]   zugewiesen habe, dann verweist die auf keinen Array, auf gar nichts. Die ist dann einfach da und ich
[00:06:56.800 --> 00:07:02.840]   kann mit der nichts weiter machen. Und auf jeden Fall verweist sie ganz sicher nicht auf den Array.
[00:07:02.840 --> 00:07:10.280]   So, und jetzt haben wir eben nur noch das B, das wieder auf diesen Array verweist. Also das ist,
[00:07:10.280 --> 00:07:16.640]   da können wir mit Referenzvariablen arbeiten und so können wir eben dafür sorgen, dass die immer
[00:07:16.640 --> 00:07:23.080]   auf den richtigen Array verweisen. Also, wenn sie mit diesen Referenzvariablen arbeiten, ja, da gibt's
[00:07:23.080 --> 00:07:28.600]   zwei unterschiedliche Arten mit, wie wir den arbeiten können. Wenn wir also diese Referenzvariablen
[00:07:28.600 --> 00:07:34.680]   zusammennehmen, ja, wenn ich diese habe, dann kann ich den einmal diesen Namen benutzen, um mittels
[00:07:34.680 --> 00:07:41.800]   dieses äckige Klammeroperators ein bestimmtes Element auszuwählen. Also kann ich dann das Element
[00:07:41.800 --> 00:07:48.360]   herausfinden, dass den gegebenen Index hat. Oder aber ich kann diese Referenzvariable benutzen,
[00:07:48.360 --> 00:07:54.520]   um einen anderen Referenzvariable auf den selben Array verweisen zu lassen. Wenn ich also den,
[00:07:54.520 --> 00:08:01.880]   diesen Namen auf die rechte Seite einer Zuweisung schreibe, dann wird diese Variable, die auf der
[00:08:01.880 --> 00:08:09.200]   linken Seite steht, jetzt auf den selben Array verweisen auf die rechte. So, was passiert, wenn
[00:08:09.200 --> 00:08:13.760]   keine Referenzvariablen, ein erregter weiß. Da kommen wir später noch zu sprechen. So, machen wir
[00:08:13.760 --> 00:08:18.440]   erstmal hier, versuchen einfach zu verstehen, was passiert, wenn wir mit diesen Referenzvariablen
[00:08:18.440 --> 00:08:27.120]   arbeiten, ja. Also, Referenzvariable ist eigentlich eine Kurzform, um zu sagen, dies ist eine Java-Variable
[00:08:27.120 --> 00:08:34.480]   des Typs, Referenz auf einen Array. Interessant, das Wort Referenzvariable taucht weder in der
[00:08:34.480 --> 00:08:40.360]   deutschen noch englischen Version in der Java-Sprach-Definition auf, aber viele, viele, viele Mal
[00:08:40.360 --> 00:08:46.440]   im offiziellen Java-Tutorial. Also, es hat sich irgendwie eingebürgert, nachdem die Sprache
[00:08:46.440 --> 00:08:52.080]   entwickelt worden war, dass wir eben sagen, das ist eine Variable, die auf irgendetwas verweist. Also,
[00:08:52.080 --> 00:08:59.840]   hier habe ich eben einen Long Array, der verweist diese Variable, verweist auf einen Arrays von Long
[00:08:59.840 --> 00:09:05.080]   Elementen, ja, oder ist Null, dann ist der verweist auf gar nichts, dann ist nichts, ja. Also, Null ist
[00:09:05.080 --> 00:09:11.920]   natürlich immer noch eine Möglichkeit. Also, Null ist der Wert einer Referenzvariable, die auf
[00:09:11.920 --> 00:09:18.600]   keinen Array verweist. Also, wenn ich hier den Array habe, ja, und jetzt habe ich zehn Elemente dazu,
[00:09:18.600 --> 00:09:24.680]   das setzt sich das erste Element auf eins, das geht bestens, wenn ich die Länge drucke, dann kriege
[00:09:24.680 --> 00:09:31.840]   ich das Länge natürlich zehn heraus, ja. So, wenn ich jetzt hingehe und dieses A auf Null setze, was
[00:09:31.840 --> 00:09:39.040]   passiert dann, dann ist, existiert da kein Array mehr. Und wenn ich jetzt versuchen sollte, auf die
[00:09:39.040 --> 00:09:44.760]   Länge festzuhalten, dann sagt das System, ups, A ist Null, es gibt keinen Array, was soll ich da eine
[00:09:44.760 --> 00:09:49.400]   Länge liefern? Und dann gibt es eben eine entsprechende Fehlermeldung. Oder wenn ich versuchen
[00:09:49.400 --> 00:09:56.160]   sollte, ein Element, irgendein Element auf einen Wert zu setzen, beschwert sich das System auch,
[00:09:56.160 --> 00:10:04.760]   weil es eben kein, kein Array mehr gibt, ja. Also, aber ich kann diese Variable immer noch
[00:10:04.760 --> 00:10:10.280]   ausdrucken, hier, das ist immer noch möglich, ja. Dann kommt halt das Ausgabe Null heraus, aber es ist
[00:10:10.280 --> 00:10:17.120]   immer noch möglich, eben zu gucken, was da, was wir da in dem Array haben. So, was passiert jetzt,
[00:10:17.120 --> 00:10:21.160]   jetzt kommt die Antwort zu der Frage, die jetzt eben im Chat kann, was passiert denn mit diesem
[00:10:21.160 --> 00:10:26.560]   Array auf den niemand mehr verweist, ja. Okay, nachdem also jetzt, wenn wir das Programm so
[00:10:26.560 --> 00:10:33.960]   geschrieben haben, dass eben halt hier erst setzen wir A, so dass es auf B verweist und danach gehen
[00:10:33.960 --> 00:10:41.040]   wir hin und setzen A zu Null, also A Null verweist nichts mehr. Jetzt, wenn es keine weiteren
[00:10:41.040 --> 00:10:46.000]   Referenzvariabeln gibt, die auf diesen Array verweisen, ja, es könnte ja noch irgendeine Variable C
[00:10:46.000 --> 00:10:51.560]   geben, aber die nehmen wir jetzt mal an, existiert nicht, ja. Dann ist dieser Array unerreichbar,
[00:10:51.560 --> 00:11:00.120]   ja. So, der, der, niemand kann diesen Array erreichen in einer ersten vernünftigen Apoximation
[00:11:00.120 --> 00:11:05.120]   eines vernünftig geschriebenen Programms, ja. So, was, was für Auswirkungen hat denn jetzt
[00:11:05.120 --> 00:11:11.600]   dieser Array auf das Programm? Also, im Prinzip hat der keine direkte Auswirkung, ja. Wenn der
[00:11:11.600 --> 00:11:16.440]   Risik ist und deswegen unseren Speicherplatz wegnimmt, ist eine andere Sache, ja, aber und
[00:11:16.440 --> 00:11:22.400]   deswegen alles langsamer läuft. Aber für das Programm, so wie wir uns mit unterhalten haben
[00:11:22.400 --> 00:11:28.000]   über die, mit den Horschen-Trippeln und so, da existiert dieser Array nicht mehr, ja. Und der
[00:11:28.000 --> 00:11:33.800]   Schöne ist jetzt irgendwann, ja, nicht einmal die Woche, sondern eben irgendwann, ja, kommt da die
[00:11:33.800 --> 00:11:41.720]   Müllabfuhr, ja. Und das Java-System geht hin und entfernt den, ja. Und das Gute ist, das ist nicht
[00:11:41.720 --> 00:11:48.160]   unser Thema, ja. Wir machen hier Programmieren langweilig, ja. Wir lassen Sie das nicht machen.
[00:11:48.160 --> 00:11:52.600]   Sie brauchen nicht Stunden damit zubringen, rauszufinden, wo denn da irgendwelche Daten
[00:11:52.600 --> 00:11:57.800]   verschwunden sind. Sie können sich darauf beschränken, ein korrektes Programm zu schreiben, ja.
[00:11:57.800 --> 00:12:02.320]   Es gibt Programmiersprachen, die sind etwas interessanter vielleicht, ja. Da können Sie auch
[00:12:02.320 --> 00:12:07.880]   noch solche Fehler finden, ja. Aber machen wir doch erst mal hier im ersten Semester einfache Sachen
[00:12:07.880 --> 00:12:12.560]   und beschränken uns auf korrekte Programme, die wir selbst entwickeln. Also, das Schöne ist,
[00:12:12.560 --> 00:12:19.160]   nicht unser Problem, ja. Wird irgendwann vom System eingesammelt, hat natürlich eventuelle
[00:12:19.160 --> 00:12:24.800]   Auswirkungen auf die Laufzeit und so weiter. Aber das ist nicht etwas, was wir hier im ersten
[00:12:24.800 --> 00:12:31.440]   Semester gründlichst diskutieren werden. Und daher ist das für uns kein Thema. So, also,
[00:12:31.440 --> 00:12:40.120]   das ist das, was wir hier Referenzsementics nennen, ja. Wenn eine Referenzvariable als operant
[00:12:40.120 --> 00:12:46.920]   einer Zuweisung auftritt. Also, hier haben wir zwei Referenzvariablen x und y, ja. Und y ist
[00:12:46.920 --> 00:12:53.400]   der operant auf der rechten Seite, ja. Das ist der operant y. Dieser Array wird nicht kopiert,
[00:12:53.400 --> 00:12:59.280]   sondern beide Variablen beziehen sich nun auf den selben Array. Wie wir eben gesehen haben,
[00:12:59.280 --> 00:13:08.080]   a und b, beide zeigen jetzt auf a und b, ja. a und b zeigen jetzt beide auf den selben Array, ja. Und
[00:13:08.080 --> 00:13:14.000]   das nennen wir Eliasing. Und das werden wir sehen, ist auch tricky. Das wird uns auch genug,
[00:13:14.000 --> 00:13:22.200]   wird genug uns verlangen, ja. Wenn zwei oder mehr Referenzvariable auf den selben Array verweisen,
[00:13:22.200 --> 00:13:28.200]   ja, dann sprechen wir von Eliasing, ja. Es könnten also zwei sein, mehr, je mehr, das ist
[00:13:28.200 --> 00:13:33.360]   so schwieriger, ja. Das sind die Referenzsementics, ist, dass wir eben die Arrays nicht kopieren,
[00:13:33.360 --> 00:13:49.440]   im Gegensatz zu den anderen Werten, also den Values, mit denen wir zu tun hatten, ja. So, ja. Also,
[00:13:49.440 --> 00:13:57.560]   das ist wichtig, dass sie diesen Ausdruck immer wieder verstehen, was mit dem zusammenhängt, ja.
[00:13:57.560 --> 00:14:04.040]   Also, jetzt warum verwenden die Arrays-Refahrenzsementics? Warum? Wenn wir eine Integer a haben, ja,
[00:14:04.040 --> 00:14:10.400]   und eine Integer b und ich habe die Zuweisung a wird gesetzt zu b, dann wird ja der Wert
[00:14:10.400 --> 00:14:15.360]   kopiert, ja. Warum machen wir das denn nicht auch für Arrays? Und der Hauptgrund ist eben
[00:14:15.360 --> 00:14:21.160]   Effizienz, ja. Weil das Kopieren großer Arrays kostet doch recht viel Zeit. Sie sehen, also,
[00:14:21.160 --> 00:14:28.480]   wir können diese Effizienzüberlegung nicht ganz unter den, nicht ganz wegbringen, ja. Und zum
[00:14:28.480 --> 00:14:32.760]   zweiten sehr oft kann man gut ein Programm Datastrukturieren, dass man sagt, es gibt hier
[00:14:32.760 --> 00:14:38.960]   ein großes Datenset und jetzt arbeiten verschiedene Methoden daran, ja. Die eine Methode, die andere
[00:14:38.960 --> 00:14:45.720]   und so weiter, die arbeiten alle mit diesem Dataset, ja. Und das hat dann den großen Vorteil,
[00:14:45.720 --> 00:14:50.000]   dass die eben alle, dass wir da nichts kopieren müssen. Aber das werden wir jetzt noch mal genauer
[00:14:50.000 --> 00:14:57.920]   angucken, warum eben Referenzsementics so eine gute Idee sind, ja. Nur bevor wir dazu kommen,
[00:14:57.920 --> 00:15:05.040]   viele Operatoren sind für Objekte nicht definiert und damit auch nicht für Arrays, ja. Die einzige
[00:15:05.040 --> 00:15:10.440]   Ausnahme ist dieser Plus-Operator, der für Strings definiert ist. Da geht das, aber wenn
[00:15:10.440 --> 00:15:15.760]   sie zwei Scanner haben, ja, und sie versuchen, die beiden Scanner mit dem Plus-Operator zu
[00:15:15.760 --> 00:15:20.520]   verknüpfen, da wird sich das beschweren. Oder auch wenn sie versuchen sollten, bei Strings den
[00:15:20.520 --> 00:15:27.920]   Multiplikations-Operator zu verwenden, ja, dann kriegen sie auch eine Federmeldung, weil das System
[00:15:27.920 --> 00:15:36.400]   weiß nicht, was wir, was wir da machen können, ja. Und auch Output funktioniert nicht ganz so, wie
[00:15:36.400 --> 00:15:39.960]   wir das wollen. Ja, manchmal wünschen wir es vielleicht, aber haben wir hier einen Array und
[00:15:39.960 --> 00:15:44.440]   einen anderen Array und jetzt wollen wir die Summe dieser beiden Arrays bilden. Oder wir wollen
[00:15:44.440 --> 00:15:53.160]   halt raussehen, wollen sehen, ob die Elemente des einen Arrays größer als dieses anderen sind,
[00:15:53.160 --> 00:15:58.120]   oder so was. Aber Java unterstützt dies nicht direkt. Natürlich können wir das irgendwie auch
[00:15:58.120 --> 00:16:05.280]   checken, aber wir können das eben halt nicht direkt checken, ja. So. Und unter anderem, was sehr
[00:16:05.280 --> 00:16:10.680]   bedauernswert ist, gibt es kein Equals für Arrays. Wir hatten gesehen, wir zwei Strings hatten und
[00:16:10.680 --> 00:16:15.200]   wir wollten gucken, ob die gleich sind oder nicht, ja. Dann hatten wir gesagt hier der eine String
[00:16:15.200 --> 00:16:21.480]   und dann eben halt der andere String und dann haben wir diese Equals-Methode oder Operation
[00:16:21.480 --> 00:16:27.000]   verwendet, um zu checken, ob diese beiden Strings gleich sind oder nicht, ja. Und das geht nicht,
[00:16:27.000 --> 00:16:32.040]   ja. Wir können das weder mit diesem Gleichheitszeichen noch, mit diesem doppelten Gleichheitszeichen,
[00:16:32.040 --> 00:16:36.880]   noch mit Equals vergleichen, ja. Das geht nicht, das System unterstützt das nicht. Wenn wir das
[00:16:36.880 --> 00:16:42.880]   versuchen sollten, ja, dann ist das incorrect. Es gibt nicht das, was wir wollen. Wir werden
[00:16:42.880 --> 00:16:46.880]   später mal sehen, was das genau ergibt, ja. Aber das ist incorrect und wenn wir so was
[00:16:46.880 --> 00:16:55.360]   versuchen sollten, dann gibt sofort eine Fehlermeldung, weil es gibt für Arrays keine Equals-Operation, ja.
[00:16:55.360 --> 00:17:01.960]   Also das ist nicht da. So. Jetzt müssen wir gucken, wie wir damit zurechtkommen. Da gibt es
[00:17:01.960 --> 00:17:06.000]   auch noch Wege, wie wir daraus kommen. Aber bevor wir das jetzt weitermachen, wollen wir
[00:17:06.000 --> 00:17:11.160]   gucken, genauer gucken, warum und wie funktioniert eigentlich Errays und Methoden, weil das ist
[00:17:11.160 --> 00:17:17.800]   immer wieder ein Thema, das immer wieder Fragen aufwirft. Und da möchte ich zwei Aspekte
[00:17:17.800 --> 00:17:24.600]   angucken, nämlich, wie wir Errays als Parameter übergeben und wie wir mit Errays mit Rückgabewerten
[00:17:24.600 --> 00:17:29.760]   arbeiten können, was da die Vor- und Nachteile sind und was die Folgen sind. Und darum habe
[00:17:29.760 --> 00:17:35.000]   ich so ein künstliches Programmproblem. Sie sollen Programm schreiben oder Programmsegment
[00:17:35.000 --> 00:17:41.080]   schreiben, das in einem Array alle Elemente, die stricke kleiner als 0 sind, auf 0 setzt.
[00:17:41.080 --> 00:17:46.080]   Also wenn sie so einen Array haben, wo hier zwei Werte sind, die kleiner als 0 sind, dann
[00:17:46.080 --> 00:17:51.360]   sollen die auf diesem Array, wollen wir einen neuen Array haben, der gefiltert wurde und
[00:17:51.360 --> 00:17:57.960]   in dem gefilterten Array haben wir alle diese Elemente auf 0 gesetzt. So. Und dieses Programm,
[00:17:57.960 --> 00:18:03.360]   die einzige leichte Komplikation, sollte für eben Interrays, müssen wir schon sagen für
[00:18:03.360 --> 00:18:09.320]   was, aber Interrays, jeder Größe funktioniert. Und das Programm selber schreiben, das ist
[00:18:09.320 --> 00:18:14.320]   einfach, das haben sie jetzt ganz sicher schon drin, ja. Also wir haben hier einen Loop, wir
[00:18:14.320 --> 00:18:19.720]   haben einen Loop, wo wir kontrollieren wollen, wie viel, dass wir durch alle Elemente einmal
[00:18:19.720 --> 00:18:24.040]   durchgehen und angucken, ob die Größe oder kleiner sind und wie machen wir das, wenn der
[00:18:24.040 --> 00:18:29.280]   Array Numbers heißt, dann nehmen wir das Längsattribut dieses Arrays und gucken nach, wie lang ist
[00:18:29.280 --> 00:18:34.680]   dieser Array heute und dann arbeiten wir, gehen wir durch und wenn das Element kleiner als 0 ist,
[00:18:34.680 --> 00:18:44.840]   dann setzen wir es auf 0. Das ist also, als die Arbeit, die wir da machen müssen, ist überhaupt,
[00:18:44.840 --> 00:18:52.000]   ist gar kein Problem, ist ganz leicht. So. Also, jetzt haben wir das gemacht, jetzt haben wir also
[00:18:52.000 --> 00:18:56.120]   dieses Programmsegmenten, jetzt wollen wir eine Methode entwickeln, weil wir wissen, die haben
[00:18:56.120 --> 00:19:01.680]   wir gelernt, dass Methoden der Weg sind, wie wir Arbeit und wieder verwenden können, wenn wir
[00:19:01.680 --> 00:19:06.160]   was in eine Methode stecken können, die Methode einen Weitrissmal verwenden und so weiter. Also
[00:19:06.160 --> 00:19:11.560]   wollen wir eine Methode haben, die den Array, dessen Werte zu filtern sind, als Parameter
[00:19:11.560 --> 00:19:16.000]   entgegen nimmt. Also wir haben hier diesen Array Numbers und jetzt wollen wir irgendwie dieser
[00:19:16.000 --> 00:19:21.400]   Methode hier sagen, hier der Methode filter, sie möge doch bitte hingehen und irgendwie diese
[00:19:21.400 --> 00:19:28.600]   Zahlen da nummerieren und werde ich nummerieren, überarbeiten und eben auf ihre Größe kontrollieren.
[00:19:28.600 --> 00:19:35.720]   Und wenn wir das angucken, da gibt es zwei Fragen, wie schreiben wir eine Methode, die einen Array
[00:19:35.720 --> 00:19:42.560]   als Parameter übernimmt und zweitens, wie können wir den Inhalt des geänderten Arrays nach der
[00:19:42.560 --> 00:19:47.560]   Verarbeitung zurückgeben? Wie können wir das Ergebnis zurückgeben, weil das, was wir bisher gesehen
[00:19:47.560 --> 00:19:58.680]   haben, reicht eigentlich nicht dafür aus, um sowas zu machen. Also es ist relativ einfach eine Methode
[00:19:58.680 --> 00:20:04.240]   zu deklarieren, die einen Array als Parameter hat. Es geht genauso, wie wir andere Parameter
[00:20:04.240 --> 00:20:11.360]   deklariert hatten. Jetzt ist eben halt der Typ des Arrays, ist eben ein Array. Array von einem bestimmten
[00:20:11.360 --> 00:20:18.760]   Typ. Da haben wir also hier eine Parameter nehmen mit irgendeiner Methode und wir haben, wir verlangen,
[00:20:18.760 --> 00:20:27.200]   dass diese Methode als Parameter einen Array eines bestimmten Typs bekommt. So und dann, wenn wir
[00:20:27.200 --> 00:20:32.800]   einmal das so gemacht haben, dann nimmt die Methode einen Parameter entgegen, das ist gut, aber sie
[00:20:32.800 --> 00:20:38.920]   verlangt es auch. Also wenn wir jetzt diese Methode definiert haben, dann muss da, da muss
[00:20:38.920 --> 00:20:49.080]   ein Parameter kommen. Natürlich kann diese Methode einen beliebigen Wert zurückgeben und eben
[00:20:49.080 --> 00:20:56.320]   wichtig ist, Typ ist der Typ der Elemente dieses Arrays. Also wenn wir das jetzt hier haben, dann
[00:20:56.320 --> 00:21:02.880]   würden wir jetzt also unsere Methode so schreiben. Das erste Mal habe ich dir hier den, gebe ich einen
[00:21:02.880 --> 00:21:09.960]   Int zurück, um eine Summe hier zu machen, das ist so, nicht das genannte, also das geht ja noch. Ich habe
[00:21:09.960 --> 00:21:15.680]   hier den Array, also hier habe ich einen Array von Int, den nenne ich Numbers, in dieser Methode und
[00:21:15.680 --> 00:21:24.000]   jetzt gehe ich hin und summiere zum Beispiel die Elemente dieses Arrays auf. Ich habe also hier den Array,
[00:21:24.000 --> 00:21:30.680]   ich habe hier den Loop, der guckt sich alle Elemente an und addiert die, das ist heißt, das gleiche
[00:21:30.680 --> 00:21:38.680]   wie Sum ist gleich Sum plus, was immer da auf der rechten Seite steht, ja, so summieren wir die auf und am
[00:21:38.680 --> 00:21:45.800]   Ende dividieren wir die Summe durch die Anzahl der Elemente und so gibt es dann den Intwert, den wir
[00:21:45.800 --> 00:21:51.800]   als Ergebnis zurück bekommen. Also können wir den Durchschnitt für die Elemente eines Arrays
[00:21:51.800 --> 00:22:01.000]   berechnen, ja, so, also jetzt, jetzt eben haben wir die, angegeben, dass dann ein Arrayparameter
[00:22:01.000 --> 00:22:07.440]   gebraucht wird, ja, wichtig ist, dass wir brauchen keine Angabe der Größe machen, ja, das Einzige,
[00:22:07.440 --> 00:22:14.200]   was wir wirklich angeben müssen, ist der Typ, ja, der Typ der Elemente, der muss angeben sein, ja,
[00:22:14.200 --> 00:22:19.760]   trotzdem können wir unser Programm, wie Sie ja auch hier gesehen haben, so schreiben, dass das
[00:22:19.760 --> 00:22:25.560]   Programm immer noch rausfindet, wie lang der Array ist, ja, Nambers ist der Parameter und das
[00:22:25.560 --> 00:22:34.880]   Längsattribut kann ich immer benutzen, um diesen, um herauszufinden, wie viele Elemente der gegebenen
[00:22:34.880 --> 00:22:40.960]   Array hat, ja, unter der Annahme, dass dieser Array nicht nahe ist, wenn da nahe wäre, das wäre,
[00:22:40.960 --> 00:22:45.520]   gucken wir später nochmal, dass wir nicht so gut, aber gehen wir davon aus, dass ein Richter
[00:22:45.520 --> 00:22:52.360]   Array übergeben wird, dann können wir über das Längsattribut herausfinden, wie der, können wir
[00:22:52.360 --> 00:22:58.000]   herausfinden, wie viele Elemente in dem Array sind. So, jetzt haben wir also diese, so die Methode
[00:22:58.000 --> 00:23:03.880]   deklariert, jetzt müssen wir die aufrufen, ja, müssen wir irgendwie aufrufen und das geht genauso
[00:23:03.880 --> 00:23:10.120]   wie der Aufruf einer Methode mit dem Basis, mit Basisypparameter, ja, wir haben den Namen der
[00:23:10.120 --> 00:23:18.200]   Methode, die wir aufrufen und wir geben hier den Namen der Referenzvariable an, mit der wir uns auf
[00:23:18.200 --> 00:23:24.840]   den Array beziehen, ja, also hier habe ich eine Methode, die, diese Durchschnittsmethode, die ich
[00:23:24.840 --> 00:23:32.800]   eben zeigte, ja, die benutzen wir hier, um für diese, für diesen Array den Durchschnitt zu berechnen, ja,
[00:23:32.800 --> 00:23:41.720]   und da sehen Sie, dass ich hier keine, ich wähle nicht irgendwelche Elemente aus, sondern ich wähle,
[00:23:41.720 --> 00:23:49.200]   oder ich gebe die Referenzvariable direkt selber an, ja, das ist das, was ich angebe als Parameter,
[00:23:49.200 --> 00:23:55.040]   wenn ich die Methode aufrufe, ja, und die gibt dann uns das Ergebnis zurück, so wie wir das gesehen
[00:23:55.040 --> 00:24:02.080]   haben, ja, also das, das Argument oder der Argument Ausdruck ist hier in diesem Fall ein einfacher
[00:24:02.080 --> 00:24:10.320]   Referenzvariable und die wird hier eben als benutzt, um den richtigen, den Verweis auf den richtigen
[00:24:10.320 --> 00:24:17.800]   Array an diese Methode average weiter zu reichen, so, okay, jetzt haben wir also gesehen die erste
[00:24:17.800 --> 00:24:24.840]   Frage geklärt, ja, es wissen wir also, wie wir die Methode schreiben müssten, damit wir eben ein
[00:24:24.840 --> 00:24:30.760]   Array als Parameter übergeben können, jetzt kommt noch die Frage, die nächste Frage, wie können wir
[00:24:30.760 --> 00:24:37.360]   eventuell das Ergebnis zurückbekommen und natürlich können Methoden auch Arrays zurückgeben und das
[00:24:37.360 --> 00:24:42.640]   sieht dann in der Deklaration genauso aus wie wir das wahrscheinlich erwarten, als Return Type
[00:24:42.640 --> 00:24:49.600]   gebe ich dann eben zu, an irgendein Typ für die Elemente und eben ein Zeichen, diese beiden
[00:24:49.600 --> 00:24:55.000]   Ecken klammern, um anzuzeigen, dass sich ein Array von diesen Elementen haben will, ja, ich habe also
[00:24:55.000 --> 00:25:02.680]   diese, ich dekariere die Methode mit irgendwelchen Parametern und diese gibt einen Array von Elementen
[00:25:02.680 --> 00:25:08.920]   dieses Return Types zurück, ja, und um das natürlich richtig zu machen, brauchen wir im Programm
[00:25:08.920 --> 00:25:16.040]   ein Return Statement, dass diese Art von Array dann eben auch wirklich zurückgibt, ja, sonst funktioniert
[00:25:16.040 --> 00:25:24.960]   das Ganze nicht, ja, so, also hier habe ich eine Methode, die für jedes Element das eingereicht,
[00:25:24.960 --> 00:25:31.160]   dass im Array, im Input Array ist, werden davon zwei Kopien gemacht, ja, also wenn ich hier den Input
[00:25:31.160 --> 00:25:40.680]   Array 1407 einreiche, dann gibt das 11440077, also nicht gerade sehr, wie gesagt, nicht konzeptionär,
[00:25:40.680 --> 00:25:46.520]   recht einfach, ja, und wie mache ich das, ja, ich habe hier den Parameter Numbers, das ist mein
[00:25:46.520 --> 00:25:54.000]   Parameter, den ich eben in dieser Methode verwende, ja, als Rückgabe wert, gebe ich einen Array von
[00:25:54.000 --> 00:26:00.800]   Integers zurück, weil ich nehme hier nur Integerays entgegen, ja, so, und was mache ich jetzt, ich
[00:26:00.800 --> 00:26:06.720]   gehe hin in meinem Array, in meiner Methode und konstruiere einen neuen Array, ja, ich konstruiere
[00:26:06.720 --> 00:26:11.600]   einen neuen Array, den ich resalt und wie groß ist der, na ja, wenn ich zwei Kopien von jedem
[00:26:11.600 --> 00:26:16.720]   Element haben will, dann muss der doppelt so lang sein, ja, also habe ich hier einen Array, der ist
[00:26:16.720 --> 00:26:22.880]   doppelt so lang wie der Ursprungs Array, auch natürlich vom Typ Int und natürlich gehe ich hin
[00:26:22.880 --> 00:26:29.280]   und benutzt den Nu-Operator, um den zu erstellen, so, und dann habe ich jetzt hier diesen Array
[00:26:29.280 --> 00:26:36.240]   erstellt und jetzt gehe ich, habe ich einen Loop, indem ich eben die Anzahl der Elemente dieses
[00:26:36.240 --> 00:26:43.880]   Ein-Input-Arrays abfrage und das zur Loop-Kontrolle benutze und dann eben in den neuen Array, jeweils
[00:26:43.880 --> 00:26:51.600]   an der Position 2 mal i und 2 mal i plus 1, das gewünschte Element ablege, ja, so, und dann bin
[00:26:51.600 --> 00:26:59.840]   ich mit diesem Loop fertig, dann habe ich eben die Werte da kopiert und das Ganze ist hier
[00:26:59.840 --> 00:27:06.640]   fertig und ich schicke das Resultat zurück eben und mache hier Return Statement, das Resalt ist
[00:27:06.640 --> 00:27:13.040]   hier dieser Array und daher kommt der richtige Array zurück. Jetzt fragt mich eben jemand,
[00:27:13.040 --> 00:27:21.920]   eine gute vernünftige Frage, warum ist das hier längs und warum nicht längs mit offener Klammer?
[00:27:21.920 --> 00:27:29.520]   Sehen Sie, mit dem Eröffner und schließender Klammer, sehen Sie, das hier ist ein Attribut,
[00:27:29.520 --> 00:27:38.080]   ja, das ist ein Attribut, das ist etwas, was eben mit dem Array existiert, das hier ist eine
[00:27:38.080 --> 00:27:47.120]   Methode, eine Operation, können Sie so sagen, ja, eine Methode oder eine Operation und die ist nicht
[00:27:47.120 --> 00:27:55.640]   für Arrays definiert, ja, ist aber nicht definiert, ja, hat sich nicht die Mühe gemacht, ja, die ist
[00:27:55.640 --> 00:28:00.160]   für Strings definiert, wir werden sehen, dass die auch vielleicht für andere Sachen noch definiert ist,
[00:28:00.160 --> 00:28:05.720]   ja, aber für Arrays ist sie hat nicht definiert, das ist eine Entscheidung, die die Sprachentwickler
[00:28:05.720 --> 00:28:10.760]   gemacht haben, die haben entschieden, dass wir eben die länger als ein Attribut, wir werden noch mehr
[00:28:10.760 --> 00:28:17.520]   über Attribute im Laufe der Woche hören, ja, als Attribut gemanagt wird und nicht als Methode,
[00:28:17.520 --> 00:28:21.240]   man hätte auch genauso gut sagen können, wir wollen, dass das eine Methode ist, aber es gibt
[00:28:21.240 --> 00:28:27.200]   gute Gründe, warum das keine Methode sein wird, aber die ganz guten, die vollen Gründe kann ich Ihnen
[00:28:27.200 --> 00:28:35.160]   erst gegen Ende des Semesters erklären, ja, so, aber die für Arrays hat man sich entschieden,
[00:28:35.160 --> 00:28:40.960]   ist ein Attribut und für Strings hat man gesagt, da wollen wir eine Methode haben, eine Operation und
[00:28:40.960 --> 00:28:46.920]   daher, weil es eine Operation ist, ja, weil es eine Operation ist, kommen dann eben halt hier ist
[00:28:46.920 --> 00:28:51.960]   eine Methode, die aufgerufen wird und daher kommen diese beiden Klammern, gibt keine Parameter,
[00:28:51.960 --> 00:28:58.920]   sinnvollerweise und deswegen ist das eben die Methode längst für den Strings mit eröffnender und
[00:28:58.920 --> 00:29:03.800]   schließender Klammer und sagt, nix dabei, wirkt sich das stark auf den Speicherplatz aus,
[00:29:03.800 --> 00:29:09.320]   wenn man einen neuen Array macht, ja, die beiden sind dann halt weg, nicht wahr? Also ja, das mögt
[00:29:09.320 --> 00:29:14.000]   sich natürlich schon, aushängt von der Größe des Arrays aus, ja, also je nachdem was für ein
[00:29:14.000 --> 00:29:19.920]   System sie haben, kann das verschiedenste Folgen für die Laufzeit haben, aber das Gute ist,
[00:29:19.920 --> 00:29:25.600]   damit darüber, das diskutieren wir später im dritten Semester, ja, also machen sich jetzt
[00:29:25.600 --> 00:29:32.200]   nicht zu viel Gedanken, ja, machen sich darüber nicht Gedanken, ja, die Arrays, die wir Ihnen geben,
[00:29:32.200 --> 00:29:40.880]   sind im Allgemeinen einer Größe, dass sie kein großes, kein Problem damit haben werden, ja, Sie
[00:29:40.880 --> 00:29:46.760]   können gerne ein Array mit einer Million Elemente machen, das sollte auf einem konventionellen
[00:29:46.760 --> 00:29:52.600]   Computer machbar sein. Trotzdem müssen wir daran denken, dass das nicht unendlich Zeit bauern darf,
[00:29:52.600 --> 00:29:58.440]   aber das ist eigentlich etwas, was wir erst diskutieren, nachdem wir all die ganzen Aspekte
[00:29:58.440 --> 00:30:06.600]   gesehen haben, okay? Also, jetzt kann diese Methode ein Array zurückgeben und das macht
[00:30:06.600 --> 00:30:11.720]   die auch, aber natürlich muss da jemand sein, der den Rückgabewert entgegennimmt, ja, wenn ich
[00:30:11.720 --> 00:30:17.240]   einfach nur die Methode aufrufe, die gibt ein Array zurück und der zurückgegebene Array, der fällt
[00:30:17.240 --> 00:30:21.720]   dann auf den Fußboden und ja, weg ist er nicht wahr. Also wenn ich den, zum Beispiel, diese Methode
[00:30:21.720 --> 00:30:28.360]   Duplicate Elements verwenden wollte, ja, und bekomme da jetzt eben diesen Array zurück, dann muss ich hier
[00:30:28.360 --> 00:30:34.440]   auf der rechten Seite irgendeiner Zuweisung eine Referenzvariable haben, die diesen Array
[00:30:34.440 --> 00:30:41.080]   entgegennimmt. Das könnte eine neue Deklaration sein, das könnte ein Alter, könnte eine existierende
[00:30:41.080 --> 00:30:52.600]   Referenzvariable sein, das ist jetzt nicht so kritisch, aber die, die Variable muss halt den
[00:30:52.600 --> 00:30:58.280]   richtigen Typ haben, ja, es muss eine Variable sein, die auf einen Int Array verweisen kann,
[00:30:58.280 --> 00:31:04.760]   sonst beschwert sich das System. Okay, also, jetzt haben wir also gesehen, wie wir eine Methode haben,
[00:31:04.760 --> 00:31:09.720]   die einen Array als Parameter entgegennimmt und müssen überlegen, wie genau wollen wir jetzt den
[00:31:09.720 --> 00:31:15.720]   Inhalt des geänderten Arrays zu uns zurückgeben. Die erste Frage haben wir abgehakt, ja, und
[00:31:15.720 --> 00:31:20.840]   jetzt sagt ihr, ihr könnt ja so hingehen und wir können eben diese Methode Filter so deklarieren,
[00:31:20.840 --> 00:31:27.080]   dass sie auch wieder einen Int Array gibt, ja, und dann wird eben in dieser Methode ein Array
[00:31:27.080 --> 00:31:34.280]   Filter bearbeitet und der wird dann mit das Return Statement zurückgegeben und dann können wir hier
[00:31:34.280 --> 00:31:40.120]   in unserem Programm, wo wir die, wo wir das haben, wir haben diese Filter Methode und das Ergebnis
[00:31:40.120 --> 00:31:45.640]   speichern wir hier in einer Referenzvariable, sagen wir Filter Numbers, die dann den gefilterten
[00:31:45.640 --> 00:31:53.160]   Werte da speichert, ja. So, brauchen wir kein Wort für Methoden ohne Return, ja, wo ist eine Methode
[00:31:53.160 --> 00:31:57.560]   ohne Return? Ich habe jetzt hoffentlich hier keine Methode ohne Return gehabt, oder? Hab ich ja eine
[00:31:57.560 --> 00:32:03.000]   ohne, ja, alle Return gehabt, okay? Also, wenn sie, wenn sie Wort haben, brauchen sie kein Return,
[00:32:03.000 --> 00:32:08.760]   aber zurzeit haben wir ja hier als Return einen Interay und darum haben wir hier auch als Return
[00:32:08.760 --> 00:32:15.640]   Wert geben wir einen Interay zurück und daher haben wir hier einen Return, ja. So, also, hier
[00:32:15.640 --> 00:32:21.800]   haben wir das Programm, gucken wir uns das mal an, also wir haben hier oben die Methode Filter,
[00:32:21.800 --> 00:32:29.080]   diese Methode Filter, die nimmt entgegen eine Referenz auf einen Interay, wir benutzen die Länge
[00:32:29.080 --> 00:32:36.280]   dieses Errays, um einen neuen Erray zu erstellen, den nennen wir hier in unserer Methode Filter
[00:32:36.280 --> 00:32:42.760]   und jetzt gehen wir hin und gucken uns alle Elemente an und wenn der Wert kleiner als null ist,
[00:32:42.760 --> 00:32:49.640]   dann setzen wir den gefilterten Wert auf null, ja, und dann sind wir, na ja, doch nicht ganz fertig,
[00:32:49.640 --> 00:32:59.320]   ja, ja, alle heute morgen wach, ja, ja, ja, ja, ja, ja, ja, ja, nee, nicht wirklich, okay, also,
[00:32:59.320 --> 00:33:05.240]   das sieht gut und schön aus, hat aber einen kleinen Nachteil, was passiert denn, wenn wir hier oben einen
[00:33:05.240 --> 00:33:11.480]   neuen Erray erstellen, bekommen wir einen Erray von nullen, ja, und jetzt gehen wir hin und ersetzen
[00:33:11.480 --> 00:33:16.440]   noch zwei dieser Elemente mit was, mit nullen, na ja, also da haben wir immer noch null, also dieser
[00:33:16.440 --> 00:33:23.080]   Erray vergisst, oder diese Methode vergisst leider alle die Werte, die größer als null sind, ja, und
[00:33:23.080 --> 00:33:29.880]   das können wir natürlich leicht fixen, wenn also der Wert kleiner als null ist, dann setzen wir den
[00:33:29.880 --> 00:33:36.680]   auf null und anderfalls kopieren wir den Wert aus dem Input-Erray, ja, so, so haben wir ein Programm,
[00:33:36.680 --> 00:33:43.720]   das ist zumindest korrekt, ja, das ist schon mal ein großer Vorteil, ja, das ist das Programm,
[00:33:43.720 --> 00:33:49.960]   erfüllt unsere Anforderungen, ist korrekt, gibt keine Laufzeitfehler und so weiter, ja, ist immer
[00:33:49.960 --> 00:33:54.920]   gut so was zu haben, ja, jetzt können wir noch besser machen, aber das ist zumindest mal eine gute
[00:33:54.920 --> 00:34:04.840]   Basis, ja, so, so, jetzt eben was ist an dem, an der Lösung nicht ganz so gut, ja, weil die gibt
[00:34:04.840 --> 00:34:10.360]   uns ja den gewünschten Erray, na ja, stellen Sie sich vor, Sie hätten jetzt diesen Erray, diesen
[00:34:10.360 --> 00:34:16.280]   Input-Erray mit acht Millionen, acht Millionen Einträgen, ja, und 20 von denen wären auch grund
[00:34:16.280 --> 00:34:22.520]   irgendwelcher Messfehler kleiner als null. Wie viele Zuweisungen würden Sie hier ausführen, ja, wenn
[00:34:22.520 --> 00:34:33.560]   Sie sich dieses Programm angucken, wir haben hier acht Millionen, 499,980 Zuweisungen hier und
[00:34:33.560 --> 00:34:40.600]   20 Zuweisungen da, ja, also 20 mal ist die Zahl kleiner als null, dann wird diese Anweisung ausgefüllt
[00:34:40.600 --> 00:34:48.280]   und die anderen acht Millionen, 499,000 und so weiter, Male wird diese Anweisung ausgeführt, ja,
[00:34:48.280 --> 00:34:55.640]   und das ist vielleicht okay, aber wirklich notwendig sind nur die 20 für die Elemente, die null sind,
[00:34:55.640 --> 00:35:02.200]   ja, und deswegen eben der Wunsch, dass man das so aufsetzen kann, dass die Elemente des Errays
[00:35:02.200 --> 00:35:09.480]   modifiziert werden können, ja, ohne dass wir diese alle kopieren müssen, ja, dass wir also ohne diese
[00:35:09.480 --> 00:35:15.520]   Elemente kopieren zu müssen, dass wir trotzdem mit denen arbeiten können und das ist die Motivation
[00:35:15.520 --> 00:35:22.960]   für die Referenz-Semitics, ja, wenn Sie also eben mit großen Datenmengen arbeiten, sparen und eben
[00:35:22.960 --> 00:35:29.760]   nicht alle Elemente verändert werden müssen, dann helfen Ihnen die Referenz-Semitics, ja, also
[00:35:29.760 --> 00:35:37.880]   deswegen, wenn Sie eben eine Methode ein erlauben, den Erray oder später auch ein Objekt als Parameter
[00:35:37.880 --> 00:35:43.440]   zu bekommen und dann zu modifizieren zu können, ja, ohne dass wir das kopieren müssen, dann können
[00:35:43.440 --> 00:35:50.520]   wir Zeit und Platz sparen und wir können diese Updates oder die Veränderungen direkt im, direkt
[00:35:50.520 --> 00:35:57.040]   machen, aber eben das große Problem ist jetzt eben haben wir die Situation, dass sowohl die eine
[00:35:57.040 --> 00:36:02.440]   Methode als auch eine andere Methode, also ist ja Aufrufer oder irgendeine andere Methode, die
[00:36:02.440 --> 00:36:07.600]   aufgerufen wird, dass die alle diese Errays modifizieren können, das heißt wir müssen dann viel
[00:36:07.600 --> 00:36:14.240]   mehr aufpassen, was für Modifikationen das gemacht werden, ja, also das ist eben die Hauptmotivation
[00:36:14.240 --> 00:36:19.880]   für diese Referenz-Semitics, ja, wenn die Variable eben eine Referenz auf einen Erray enthält und wir
[00:36:19.880 --> 00:36:26.040]   übergeben jetzt diese Referenz, dann kann die Methode, die die Referenz bekommen hat, mit dieser
[00:36:26.040 --> 00:36:33.720]   mit diesem Erray arbeiten, die kann modifizieren, die kann alles Mögliche mit den Elementen machen,
[00:36:33.720 --> 00:36:41.000]   ja, denn das der Erray wird nicht kopiert, sondern wird übergeben, ja, so, also wenn sie so wollen,
[00:36:41.000 --> 00:36:46.600]   wenn der eine Methode die Elemente änderte, dann eben bekommt die andere Methode oder der
[00:36:46.600 --> 00:36:51.600]   Aufrufer bekommt diese Endungen mit, ja, und wie funktioniert das, sehen Sie, wir haben also
[00:36:51.600 --> 00:36:59.560]   hier ein Programm, also zwei Referenzvariable hat, lässt diese Referenzvariable A auf den
[00:36:59.560 --> 00:37:06.040]   selben Erray verweisen, wie diese Referenzvariable B, die verweisen beide auf den selben Erray, ja,
[00:37:06.040 --> 00:37:11.600]   und jetzt habe ich, irgendwo habe ich eine Methode, die nenne ich mal method, ja, und die nimmt einen
[00:37:11.600 --> 00:37:19.920]   Int-Parameter, einen Int-Erray als eine Referenz auf einen Int-Erray als Parameter entgegen, ja,
[00:37:19.920 --> 00:37:26.920]   und wenn ich jetzt hier diese Methode aufrufe und diese Referenz übergebe, das ist ja der Verweis
[00:37:26.920 --> 00:37:33.640]   auf dieses Element, ja, was passiert dann, das ist dann so, als ob ich dieser lokalen Variable P A,
[00:37:33.640 --> 00:37:39.640]   das ist ja der Parameter, das ist ja eine lokale Variable in dieser Methode, als ob ich der die
[00:37:39.640 --> 00:37:46.560]   Referenz auf den Erray zugewiesen hätte, die ich in meinem Erray, in meiner Referenzvariable
[00:37:46.560 --> 00:37:52.800]   lokal A gespeichert habe, ja, also wenn die Methode hier aufgerufen wird, dann wird diese
[00:37:52.800 --> 00:38:00.720]   Referenzvariable P A, dieser Parametervariable, die wird jetzt so aufgesetzt, dass sie auf den
[00:38:00.720 --> 00:38:09.720]   selben Erray verweist, auf den das Programm hier mit lokal A und lokal B eben halt verwiesen hat, ja,
[00:38:09.720 --> 00:38:20.760]   so funktioniert das ja und daher eben werden durch die, wenn ein Erray mit oder ein Erray-Parameter
[00:38:20.760 --> 00:38:27.040]   da ist, dann werden die Werte eben nie kopiert, sondern es findet nur so eine Operation statt,
[00:38:27.040 --> 00:38:33.480]   in der eben wie, als ob ich hier oben lokal das machen würde, ja, also lokal heißt in der Methode
[00:38:33.480 --> 00:38:40.080]   das machen würde, wird die entsprechende Referenzvariable benutzt, um diese Referenzvariable
[00:38:40.080 --> 00:38:47.480]   richtig zu initialisieren, ja, also wenn diese Methode so eine Referenzvariable bekommen hat,
[00:38:47.480 --> 00:38:54.200]   dann kann sie den Erray verändern und die Veränderungen sind für den Aufrufer sichtbar, ja, und das war
[00:38:54.200 --> 00:39:00.480]   eben anders bei den Variablen der Basestypen, ja, da hatten wir gesehen, dass die Methode machen
[00:39:00.480 --> 00:39:06.400]   können, was sie wollen, der Aufrufer ist davon nicht betroffen, ja, so, also damit jetzt zurück
[00:39:06.400 --> 00:39:14.000]   zu dem Problem, das wir hatten, ja, also wir können jetzt die Elemente hier in der Methode
[00:39:14.000 --> 00:39:21.360]   selber verändern, also hier habe ich die Zuweisung, wo ich das entsprechende Element auf Null setze,
[00:39:21.360 --> 00:39:28.000]   wenn eben das Element kleiner als Null ist, ja, und alle anderen Elemente sind davon nicht betroffen
[00:39:28.000 --> 00:39:33.560]   und deswegen brauche ich auch keinen Return-Typ hier und deswegen fehlt auch hier ein Return, ja,
[00:39:33.560 --> 00:39:41.080]   weil eben halt diese Methode erledigt die ganze Arbeit eben durch die Modifikation des Parameters,
[00:39:41.080 --> 00:39:47.400]   ja, der Parameter wird hereingegeben, wird bearbeitet und wird dann eben halt am Ende von
[00:39:47.400 --> 00:39:53.800]   der Aufrufermethode wieder angesehen und kann dann damit weiterarbeiten, das ist der Sinn der Sache,
[00:39:53.800 --> 00:39:59.200]   ja, also hier habe ich das Programm, ja, hier nicht diesen Räh dann eingebe und danach das
[00:39:59.200 --> 00:40:04.760]   Ausdruck, dann ist in der Tat das so, dass die Elemente, die kleiner als Null waren, die wurden
[00:40:04.760 --> 00:40:09.960]   auf Null gesetzt, ja, also da müssen sie immer wieder im Kopf haben, wenn ein Räh als Argument
[00:40:09.960 --> 00:40:15.000]   übergeben wird, dann wird der Räh nicht kopiert, sondern der Parameter verweist auf den
[00:40:15.000 --> 00:40:22.160]   selben ursprünglichen Räh, ja, und wenn es irgendwelche Modifikationen gibt, dann eben halt werden
[00:40:22.160 --> 00:40:29.200]   diese Modifikationen sichtbar sein, die sind dann so wie für alle sichtbar, ja, so, also deswegen
[00:40:29.200 --> 00:40:34.760]   sagt man auch in manchen Texten lesen sie vielleicht, dass die Rähparameter by reference
[00:40:34.760 --> 00:40:41.040]   übergeben werden, das ist so der, um darauf hinzuweisen, dass dieser, dass dieser Parameter eben
[00:40:41.040 --> 00:40:49.360]   nicht kopiert wird, sondern dass wir eben die Referenz sehen, ja, so, also das immer wieder, ach,
[00:40:49.360 --> 00:40:54.520]   denken sie da, ja, nochmal als Beispiel und dann können wir die Pause haben, ja, also ich habe
[00:40:54.520 --> 00:41:01.680]   hier diesen Int Räh Z, den ich mit Z erreiche, ja, das heißt irgendwo habe ich hier in meinem System
[00:41:01.680 --> 00:41:10.160]   den einen Räh mit drei Elementen, die so initialisiert wurden und ich habe das, können
[00:41:10.160 --> 00:41:15.160]   sich vorstellen wie ich den Drucker, ja, und jetzt habe ich eine Methode, die ich aufrufen werde und
[00:41:15.160 --> 00:41:24.200]   der ich diesen Parameter Z, die Referenz auf den Räh, auf den Z verweist als Parameter übergeben
[00:41:24.200 --> 00:41:29.440]   werde, ja, also das erste, das erste Print ergibt natürlich hier oben sehen Sie das Output, ja,
[00:41:29.440 --> 00:41:35.880]   gibt natürlich 1, 3, 5, ja, so, jetzt habe ich die Methode, habe ich irgendwo in meinem Programm
[00:41:35.880 --> 00:41:42.560]   diese Methode geschrieben, ja, die nimmt eine Referenz variable x entgegen, die ein Int auf
[00:41:42.560 --> 00:41:49.760]   einen Int Räh verweisen muss, ja, und dann setze ich das Element, das letzte Element setze ich auf
[00:41:49.760 --> 00:41:56.200]   diese, auf den Wert 9, ja, ich finde das letzte Element, indem ich eben das Längstattributes
[00:41:56.200 --> 00:42:01.840]   erregt mir an, gucke einen davon abziehe und dann das als Index benutze für x und das auf 9
[00:42:01.840 --> 00:42:05.720]   setze, ja, so, und jetzt gehe ich, mach also ruf ich dich ja auf, das ist was passiert,
[00:42:05.720 --> 00:42:11.600]   was passiert ist, dass diese variable x, ja, die verweist jetzt auf den selben Räh da, ja, so,
[00:42:11.600 --> 00:42:19.880]   und jetzt macht ihre Arbeit und jetzt drückt sie eben aus, hier wie die Print in, ja, drückt sie aus
[00:42:19.880 --> 00:42:26.760]   diese variable, diesen Räh x und was wird die da ausdrucken, da drückt sie aus eben 1, 3, 9,
[00:42:26.760 --> 00:42:33.240]   weil diese Zuweisung hier hat diese 5 in einen 9 geändert, ja, so, und jetzt sind wir hier fertig
[00:42:33.240 --> 00:42:37.720]   und wenn wir hier fertig sind, geht es hier weiter und was drückt diese Methode jetzt,
[00:42:37.720 --> 00:42:42.840]   die drückt das selber, ja, weil die Veränderung, die wir da gemacht haben, ist auch im anderen
[00:42:42.840 --> 00:42:51.320]   sichtbar, ja, so bekommen wir das, bekommt der das einfach mit, ja, so, und eben jetzt vielleicht
[00:42:51.320 --> 00:42:59.080]   noch kurz so zum als kleiner Hinweis, jetzt, wenn wir diese Rays da so haben, ja, hier drücken wir
[00:42:59.080 --> 00:43:04.440]   dir, wenn ich in der J-Share bin, dann drückt der, der ist ziemlich elegant, aber in meinen Programmen
[00:43:04.440 --> 00:43:09.640]   drückt er sie nicht so elegant, ja, wenn ich hier das machen sollte, wenn ich sagen würde, hier
[00:43:09.640 --> 00:43:14.840]   drücken sie den Räh, was gibt es dann das Output, dann gibt es irgend sowas komische, sowas,
[00:43:14.840 --> 00:43:21.400]   solche komischen Stringe da, i und dann irgendwas, ja, das ist zwar richtig, ja, aber das hilft
[00:43:21.400 --> 00:43:27.640]   uns auch nicht weiter, ja, und jetzt gibt es dafür eine Serviceklasse, die heißt Rays, ja, so, und
[00:43:27.640 --> 00:43:34.760]   das ist eine Bibliothek, in der verschiedene Methoden sind, mit der ich Operationen machen kann,
[00:43:34.760 --> 00:43:40.800]   und unter anderem gibt es da die Methode Thustring, ja, die geht nämlich hin und nimmt den Räh und
[00:43:40.800 --> 00:43:46.800]   gibt mir dafür einen String zurück, ja, so, also wenn ich mit der arbeiten will, dann muss ich sie
[00:43:46.800 --> 00:43:52.240]   importieren, sonst kennt das System die nicht, ja, aber wenn ich die einmal importiert habe,
[00:43:52.240 --> 00:43:57.440]   dann kann ich mit der arbeiten, ja, und es gibt da auch eine Equals Methode, ja, mit der kann ich
[00:43:57.440 --> 00:44:03.160]   jetzt checken, ob zwei Rays equal sind, egal was für Arten von Rays das sind, ja, wenn ich zwei
[00:44:03.160 --> 00:44:09.400]   Rays habe, diese Equals Methode gibt Trut zurück, wenn sie dieselben Werte haben und falls
[00:44:09.400 --> 00:44:15.960]   anderenfalls, ja, und eben auch dieses Thustring ist sehr praktisch, ja, weil das drückt halt den Räh,
[00:44:15.960 --> 00:44:22.720]   drückt den Räh aus, ja, wenn ich das eben dahin gebe, dann drückt das mit den Räh auf einer
[00:44:22.720 --> 00:44:27.160]   diese Weise aus und für die die jetzt aufgepasst haben, hier gibt es noch eine andere schöne
[00:44:27.160 --> 00:44:33.440]   Methode, Binary Search, falls sie mal sowas brauchen sollten und zuverherweise ihren eigenen
[00:44:33.440 --> 00:44:39.200]   Code nicht dabei haben, ja, in der Klasse Rays, in der Service Klasse ist der bereits verfügbar,
[00:44:39.200 --> 00:44:44.000]   gibt eine Reihe anderer auch sort, ja, das ist auch mit der Grund warum wir in einigen anderen
[00:44:44.000 --> 00:44:49.160]   Vorlesungen sie nicht alles importieren dürfen, ja, aber bei uns dürfen sie, wir sind großzügig,
[00:44:49.160 --> 00:44:53.960]   wir lassen sie importieren was sie wollen, okay, so, jetzt haben wir zehn Minuten Pause und dann
[00:44:53.960 --> 00:45:07.520]   geht es weiter mit eben Invarianten, okay, hatten ja gesehen, dass wir Aussagen über Programme
[00:45:07.520 --> 00:45:13.120]   machen, die Schleifen haben und so weiter und ich hatte ihnen da diese Methodologie vorgestellt,
[00:45:13.120 --> 00:45:19.800]   wie wir Schleife und Invarianten zusammen entwickeln können und hatte auch schon damals darauf
[00:45:19.800 --> 00:45:24.960]   hingewiesen, dass das kein Kochrezept ist, aber ich habe jetzt auch ein Beispiel, wie wir das mit
[00:45:24.960 --> 00:45:31.440]   Rays machen können, ja, das ist also der gleiche Ansatz eben, diese vier Schritte, Invariante
[00:45:31.440 --> 00:45:38.600]   bestimmen, den Rumpf bestimmen, dann den Loop Test so auswählen, dass am Ende die Aussagen
[00:45:38.600 --> 00:45:45.720]   ausreichen, um zu zeigen, was der Loop machen soll oder das Programm machen soll und dann gegeben
[00:45:45.720 --> 00:45:51.800]   falls Initialisierung, dass das die Invarianten am Anfang sicher sind, so, also wir hätten hier einen
[00:45:51.800 --> 00:46:02.840]   Rays und ein Rays von Intwerten, den nennen wir items und wir wollen das größte Element da finden,
[00:46:02.840 --> 00:46:08.160]   wir wollen das größte Element finden, das in diesem Rays auftritt, so, und das erste Schritt ist,
[00:46:08.160 --> 00:46:13.440]   wir versuchen die Invariante zu bestimmen, wir müssen natürlich alle Elemente des Rays uns
[00:46:13.440 --> 00:46:17.920]   angucken, um das größte Element zu finden, da gibt es nicht viel mehr zu machen können, ja,
[00:46:17.920 --> 00:46:24.320]   also wenn wir das Invariante nehmen, dass der Rays hat irgendeine Anzahl N Elemente und wir fangen
[00:46:24.320 --> 00:46:30.760]   da an von 0 bis k minus 1 mal durch zu gehen und wir machen das so, dass diese, die Invariante soll
[00:46:30.760 --> 00:46:37.520]   ausdrücken, dass diese Zahl Max oder dieser Variable Max den größten Wert der Elemente in
[00:46:37.520 --> 00:46:43.360]   diesem Bereich speichert, ja, und natürlich macht das nur dann Sinn oder ist das nur dann sinnvoll,
[00:46:43.360 --> 00:46:50.000]   wenn wir sicher sind, dass die Anzahl der Elemente größer ist als k und größer ist als null,
[00:46:50.000 --> 00:46:54.920]   weil sonst haben wir natürlich ein Problem damit, ja, so, und um das etwas einfacher zu machen,
[00:46:54.920 --> 00:46:59.680]   da kürzen wir das manchmal einfach ab, ja, so, und es wäre eine mögliche Invariante,
[00:46:59.680 --> 00:47:03.520]   die wir haben könnten, könnten viele andere finden, je nachdem wie viel Zeit ich habe,
[00:47:03.520 --> 00:47:07.960]   werde ich Ihnen noch ein paar andere Erwarten im Lauf des Semesters zeigen, also andere Beispiele
[00:47:07.960 --> 00:47:14.040]   für Situationen, wo andere cleverere Invarianten nötig sind, aber hier ist eine einfache Invariante,
[00:47:14.040 --> 00:47:20.400]   die hilft uns eigentlich ziemlich gut weiter, so, also nehmen wir das also Invariante, ja, also
[00:47:20.400 --> 00:47:29.280]   unsere Invariante sagt eben, dass Max den größten Wert in diesem Bereich enthält und eben, dass
[00:47:29.280 --> 00:47:37.200]   natürlich die Länge größer gleich k sein muss und größer gleich null sein muss. Wenn wir solche
[00:47:37.200 --> 00:47:44.320]   Aussagen, Sachen schreiben, da sind wir ein bisschen sloppy, ja, es ist nicht korrektes Java, das ist
[00:47:44.320 --> 00:47:50.160]   halt einfach eine Aussage, die wir mal so machen. Klar ist für alle, um was es geht, das ist wichtig,
[00:47:50.160 --> 00:47:57.000]   ja, so, also jetzt haben wir das Invariante und jetzt wollen wir den Rumpf so schreiben, dass die
[00:47:57.000 --> 00:48:02.920]   Invariante gültig bleibt, ja, das heißt, dass wir jetzt also uns das nächste Element angucken
[00:48:02.920 --> 00:48:09.680]   müssen, das wäre das Element in der Position k, ja, wir wissen ja, dass die Länge ist größer
[00:48:09.680 --> 00:48:18.880]   gleich k, ja, gehen wir also hin und gucken, ob dieses nächste Element kleiner ist als Max oder
[00:48:18.880 --> 00:48:23.800]   größer und wenn es größer ist, dann haben wir ein neues größeres Element gefunden und dann
[00:48:23.800 --> 00:48:31.400]   müssten wir hier eine Zuweisung machen, in der wir jetzt in Max diesen Wert speichern, ja, und das hat
[00:48:31.400 --> 00:48:35.480]   natürlich zur Folge, dass unsere Invariante jetzt erstmal gar nicht gültig ist und wenn eben das
[00:48:35.480 --> 00:48:42.160]   kleiner ist, dann brauchen wir nichts zu machen, da ist nichts zu erledigen, ja, so und jetzt am
[00:48:42.160 --> 00:48:48.440]   Ende, nachdem wir das gemacht haben, erhöhen wir das k um eins, ja, dann wissen wir, ah, jetzt
[00:48:48.440 --> 00:48:53.320]   können wir hier weitermachen und jetzt gilt die Invariante wieder, ja, das können wir leicht
[00:48:53.320 --> 00:48:59.480]   überlegen, dass das in der Tat der Fall ist, weil jetzt entweder war dieses Element kleiner als
[00:48:59.480 --> 00:49:04.680]   das alte Element von Max, dann ist nichts passiert, dann ist Max noch immer das größte Element oder
[00:49:04.680 --> 00:49:12.280]   das Item in dieser Position war größer, das Element in dem Rät, den wir mit Items erreichen, war
[00:49:12.280 --> 00:49:18.400]   größer als Max, dann haben wir Max da gespeichert und damit ist, haben wir diesen Wert in Max gespeichert,
[00:49:18.400 --> 00:49:24.280]   und damit gilt die Invariante immer noch, so, jetzt der nächste Schritt ist, wir wollen versorgen,
[00:49:24.280 --> 00:49:31.080]   dass wenn der Loop mal aufhört, dass dann, wenn dieses Test falls, die Post Condition, die wir
[00:49:31.080 --> 00:49:36.240]   gerne hätten, impliziert, jetzt was wäre ein guter Weg, das zu machen, na ja, wir wollen
[00:49:36.240 --> 00:49:42.480]   halt sicher sein, dass eben dieses k nicht gleich der Länge ist, wenn k gleich der Länge wäre,
[00:49:42.480 --> 00:49:49.200]   wenn das mal je gleich der Länge wäre, dann hätten wir hier potenziell ein Problem, so lange
[00:49:49.200 --> 00:49:56.040]   das k echt kleiner gleich, kleiner, kleiner als die Länge ist, greife ich damit nur auf ein
[00:49:56.040 --> 00:50:02.440]   legales Rähelement zu, und wie Sie sehen, wir haben hier sichergestellt, dass das k größer
[00:50:02.440 --> 00:50:09.680]   gleich null ist, also das heißt wir durch das Erhöhung k, also wir sind sicher, dass es mindestens
[00:50:09.680 --> 00:50:14.760]   null ist, das heißt wir haben keine negativen Zahlen, das heißt wird auch so immer ein gültiges
[00:50:14.760 --> 00:50:23.920]   indexwert sein, so, und wenn wir das haben, dann können wir sicher sein, dass danach eben halt die,
[00:50:23.920 --> 00:50:32.240]   das gewünschte, die gewünschte Aussage gilt, ja, danach gilt eben halt k ist gleich der Länge,
[00:50:32.240 --> 00:50:39.160]   ja, das haben wir hier oben, das war unsere Bedingung, die wir gehabt haben, ja, und weiterhin gilt Max
[00:50:39.160 --> 00:50:48.080]   ist das größte Element im Bereich von null bis k minus eins, ja, also da k jetzt die gleich der Länge
[00:50:48.080 --> 00:50:55.440]   ist, ist das Max das größte Element in diesem Räheitems insgesamt, weil das geht jetzt ja eben
[00:50:55.440 --> 00:51:06.640]   halt bis zur Länge minus eins, das ist das letzte Element, ja, so, ja, so, also damit habe ich also
[00:51:06.640 --> 00:51:12.560]   erreicht, dass ich nach Ende des Loops das gewünschte Ergebnis zeigen kann, so, und jetzt müssen wir uns
[00:51:12.560 --> 00:51:18.760]   sicherstellen, dass die Initialisierung so ist, dass der Kot, den wir da schreiben, die Invariante
[00:51:18.760 --> 00:51:24.000]   sicherstellt, ja, unsere Invariante war das hier, ja, wir wollen sicher sein, dass das Max den
[00:51:24.000 --> 00:51:33.760]   größten Wert in dem Bereich hält, ja, und die Länge, also Max, items dort längs, ja, größer als
[00:51:33.760 --> 00:51:39.400]   größer gleich k ist, dass auch größer gleich null sein muss, und wie machen wir das? Naja, ein
[00:51:39.400 --> 00:51:45.880]   Weg, das zu machen ist, indem wir k mit eins initialisieren und Max auch mit den Wert geben,
[00:51:45.880 --> 00:51:50.800]   den wir im ersten Element, im Element mit index null finden, ja, damit haben wir eine, das ist
[00:51:50.800 --> 00:51:56.440]   zumindest der größte Wert im Bereich von null bis null, ja, klar, da ist ja nur ein Element und
[00:51:56.440 --> 00:52:02.920]   danach haben wir gesehen, macht der Loop das, was wir wollen, ja, so habe ich dann sichergestellt,
[00:52:02.920 --> 00:52:10.360]   dass das funktioniert. So, jetzt wäre ich eigentlich fast fertig, aber da ich eben mit arrays arbeite,
[00:52:10.360 --> 00:52:16.160]   muss ich noch paar Sachen mir überlegen, ja, nämlich ich muss sicherstellen, dass wirklich die,
[00:52:16.160 --> 00:52:23.360]   dieser array eine Länge hat, die größer als null ist, ja, wenn der array eine Länge von null hat,
[00:52:23.360 --> 00:52:28.440]   also keine Elemente hätte, dann könnte ich nicht auf dieses Element zugreifen, ja, also muss ich
[00:52:28.440 --> 00:52:35.560]   sicherstellen, als eben zusätzliche Voraussetzung, ja, dass dieser array mindestens ein Element hat,
[00:52:35.560 --> 00:52:41.160]   mindestens das Element mit dem index null, ja, das wird hier, muss ich auch noch verlangen, ja,
[00:52:41.160 --> 00:52:47.240]   und das ist dann die Pre-Condition, die ich für das ganze Programm brauche, damit das eben funktioniert,
[00:52:47.240 --> 00:52:52.560]   ja, so, unsere Pre-Condition eben entweder wird die in der Aufgabenstellung bereits vorgegeben,
[00:52:52.560 --> 00:52:59.360]   das ist sehr schön, ja, manchmal eben ist das nicht, dann müssten sie sie eben angeben, damit
[00:52:59.360 --> 00:53:05.560]   eben ein Klient, also jemand, der ihr Programm später oder ihre Methode später bearbeitet,
[00:53:05.560 --> 00:53:11.000]   benutzen möchte, weiß, was für eine Bedingung erfüllt sein muss, ja, das heißt also,
[00:53:11.000 --> 00:53:17.840]   dann kann man das nur dann machen, wenn der array wirklich Elemente hat, ja, und außerdem müssten
[00:53:17.840 --> 00:53:23.640]   wir eventuell noch feststellen, ob die Referenz, die wir bekommen, eben null ist, das müssten wir
[00:53:23.640 --> 00:53:28.920]   auch noch vielleicht ausschließen, ja, wenn ich sage hier, dass die, dass die Länge mindestens
[00:53:28.920 --> 00:53:35.000]   eins ist, dann weiß ich, da muss etwas sein, da kann das, kann das keine Null-Referenz sein, ja,
[00:53:35.000 --> 00:53:40.720]   also da kann keine Referenz auf Null sein, ja, das müssten wir auch noch festhalten, oder sie müssten
[00:53:40.720 --> 00:53:46.440]   eben eventuell eine if-Statement einführen, das testet, dass das der Fall ist oder nicht, so,
[00:53:46.440 --> 00:53:54.080]   also, wie gesagt, das Gute ist, wenn wir das genau festhalten, können wir nicht später in die
[00:53:54.080 --> 00:53:59.600]   Belangt werden, wenn jemand unsere Methode aufruft und sich nicht an die Pricondition
[00:53:59.600 --> 00:54:04.160]   gehalten hat, ja, wenn jemand dann irgendwas versucht, dahin zu rufen, dann reinzustecken,
[00:54:04.160 --> 00:54:10.800]   dann beschwert sich das System, oder wir sind zumindest nicht verantwortlich, ja, so, also,
[00:54:10.800 --> 00:54:16.880]   Erre ist nochmal kurze Zusammenfassung, so, was heißt das hier, ja, wenn ich hier das sehe, ja,
[00:54:16.880 --> 00:54:23.720]   Sie müssen dieses klammer, diese eckigen Klammern sehen, als ich habe hier ein Erre von, ja, mein
[00:54:23.720 --> 00:54:30.000]   X verweist auf ein Erre von Intz, immer ist kein gutes Deutsch, aber Sie wissen, was ich meine, ja,
[00:54:30.000 --> 00:54:39.920]   ja, Intz, ja, oder was heißt das hier, ja, das heißt, Y verweist auf einen Erre von Strings, ja,
[00:54:39.920 --> 00:54:47.480]   also von String-Elementen, ja, so, und was heißt denn das jetzt, überlegen Sie, was heißt denn das
[00:54:47.480 --> 00:54:58.600]   jetzt, das heißt, ich habe hier einen Verweis auf einen, auf was, ich habe einen Verweis auf
[00:54:58.600 --> 00:55:09.840]   Verweise auf Erre, ich habe einen Verweis auf einen Erre von Erre von Intz, ja, das ist so, so kann
[00:55:09.840 --> 00:55:16.600]   ich ein mehrdimensionales Erre in Java konstruieren, ganz logisch, ja, also was heißt das hier,
[00:55:16.600 --> 00:55:24.840]   gucken wir es an, ja, wenn ich hier ein Erre von Erre verweisen, ja, ich habe hier einen Erre,
[00:55:24.840 --> 00:55:34.440]   hatten wir hier schon mal, ja, der blaue Teil, ja, das ist der Teil hier, auf den sich dieser
[00:55:34.440 --> 00:55:42.440]   Erre hier verweist, ja, so, der verweist hier auf diesen Erre von Intz, ja, und hier jeder von denen,
[00:55:42.440 --> 00:55:49.800]   ja, ist eben ein Erre, also hier ein Erre von Intwerten, ja, hier habe ich jetzt also einen Erre,
[00:55:49.800 --> 00:55:58.800]   der Länge 5, also mit 5 Elementen, ja, und hier habe ich eben gesagt, ich möchte davon Erre von 10
[00:55:58.800 --> 00:56:08.280]   Elementen haben, ja, also habe ich hier einen Erre mit 5, wenn Sie wollen, Zeilen, ja, von je 10
[00:56:08.280 --> 00:56:12.600]   Elementen, und wir werden alle, wenn ich das so mache, mit 0 initialisiert, also hier habe ich
[00:56:12.600 --> 00:56:19.960]   ein paar weggelassen, aber da sehen Sie schon, wie das geht, ja, so geht das, ja, so, ja, und so was,
[00:56:19.960 --> 00:56:29.280]   also experimentieren Sie mit so was, ja, dass das eben richtig für Sie funktioniert, ja, wenn ich jetzt,
[00:56:29.280 --> 00:56:33.080]   jetzt können Sie in Java etwas machen, was Sie auch in anderen Programmiersprachen können, ja,
[00:56:33.080 --> 00:56:43.960]   dieser Erre hier, der ist ja nur ein Erre von Verweisen, der sagt jetzt nicht, ja, hier wo ich
[00:56:43.960 --> 00:56:50.000]   das deklariert habe, der sagt nicht, wie lang diese Zeilen sein müssen, ja, Sie könnten, wenn Sie
[00:56:50.000 --> 00:56:57.520]   wollten, ein System haben, in dem vielleicht diese, erst diese Zeile, eine andere Anzahl Elemente hat,
[00:56:57.520 --> 00:57:02.560]   das System lässt das zu, dann würde das nicht funktionieren, aber Sie können das machen, ja,
[00:57:02.560 --> 00:57:07.800]   wie würden Sie das machen? Nehmen wir an, wir hätten jetzt mit dem eben deklarierten Rezett, wir
[00:57:07.800 --> 00:57:16.320]   würden den Element mit Index 1 einen neuen Indere zuweisen, ja, also hier Index 1, da würde ich hier
[00:57:16.320 --> 00:57:27.600]   das wegnehmen, und dann hätte ich jetzt hier einen neuen Erre mit Index, mit Index 012, also drei
[00:57:27.600 --> 00:57:35.720]   Elemente, ja, und die hätten alle die Initialisierung, den Wert 0, ja, das könnte ich machen, ja, da ist
[00:57:35.720 --> 00:57:40.800]   also für die, die das schon mal benutzt haben, die J-Share sehr praktisch, ja, wenn Sie das also
[00:57:40.800 --> 00:57:47.160]   so in der J-Share machen, und Sie geben jetzt das Z aus, dann sagt, aha, wir haben hier einen Erre mit
[00:57:47.160 --> 00:57:55.320]   fünf Elementen, die Verweise auf einen Erre sind, ja, und was sind diese fünf? Der erste ist ein Erre
[00:57:55.320 --> 00:58:01.040]   mit zehn Elementen, der zweite verweist, also auf einen Erre mit zehn Elementen, der zweite verweist
[00:58:01.040 --> 00:58:06.560]   auf einen Erre mit drei Elementen, das ist, was ich eben dazu gewiesen habe, und danach habe ich
[00:58:06.560 --> 00:58:14.160]   wieder Verweise auf Erre mit zehn Elementen, ja, also damit, ich meine nicht, dass das, was ist, was wir
[00:58:14.160 --> 00:58:21.400]   jetzt jeden Tag benutzen wollen, aber so können Sie eben, wenn Sie wollten, Erre, Erre konstruieren,
[00:58:21.400 --> 00:58:30.120]   in denen die unterschiedliche Zeilen unterschiedlich lang sind, ja, so, also für Erre es gilt in Java
[00:58:30.120 --> 00:58:36.520]   Referenz Semantics, andere Programmiersprachen, andere Regeln, ja, wenn ich also eine Zuweisung habe,
[00:58:36.520 --> 00:58:43.640]   wo für zwei Referenzvariable A und B, ich die Zuweisung A wird gesetzt zu B machen, ja, dann
[00:58:43.640 --> 00:58:50.920]   verweist A, danach auf den selben Erre wie B, und die werden nicht kopiert, ja, und dasselbe gilt,
[00:58:50.920 --> 00:58:56.800]   wenn eine Referenzvariable als Parameter übergeben wird, ja, die aufgerufene Methode hat eine
[00:58:56.800 --> 00:59:04.960]   Referenz auf den selben Erre, kann diesen selben Erre modifizieren und kann so Ergebnisse,
[00:59:04.960 --> 00:59:11.520]   das Ergebnis an den Aufrufer zurückgeben, ja, und das war bei Ver.io Semantics eben anders, ja,
[00:59:11.520 --> 00:59:19.880]   bei den Basestypen ging das anders, ja, da werden die Werte kopiert, ja, ja, und das heißt, wenn immer
[00:59:19.880 --> 00:59:24.840]   wir einen Basestyp haben, ja, also wenn ich immer hier, jemand fragte mich auch im Chat, ja, wenn ich
[00:59:24.840 --> 00:59:31.400]   hier ein Integer A habe und ich setze das, nehmen wir an, wir haben diesen Erre Numbers, ja, wir Numbers
[00:59:31.400 --> 00:59:38.120]   von 3 oder irgendwas, ja, was heißt das, das geht, wir gehen jetzt nur hin, wir nehmen das Element und
[00:59:38.120 --> 00:59:44.680]   speichern es hier in dieser Variable des Basestyp, dann gibt es keine Referenzen mehr, die Referenz,
[00:59:44.680 --> 00:59:51.680]   die hatten wir hier in dem Numbers, das Numbers verwies auf den Erre und dann haben wir uns da
[00:59:51.680 --> 01:00:00.520]   das Element mit dem Index 3 genommen und haben das dann entsprechend gespeichert, so, ja, also wenn
[01:00:00.520 --> 01:00:05.760]   ich Basestypen habe, dann werden die eben immer kopiert und das gilt auch, wenn sie als Parameter
[01:00:05.760 --> 01:00:12.480]   übergeben werden und deswegen sprechen wir da von Ver.io Semantics, ja, ich habe hier diese Variable A,
[01:00:12.480 --> 01:00:18.320]   die wird die Richtung Wert 1, ich habe irgendwo eine Methode, nennen wir diese Methode MyMesset,
[01:00:18.320 --> 01:00:26.800]   die erwartet einen Parameter x, die geht jetzt hin, ein Int, ein Intwert, ja, und dupliziert das und
[01:00:26.800 --> 01:00:33.640]   speichert das in der Variable x, ja, das macht die so und dann druckt sie dieses x auch nochmal aus, ja.
[01:00:33.640 --> 01:00:39.760]   Und was passiert jetzt hier bei der Ausführung, ja, wenn wir das Programm laufen lassen, wir haben
[01:00:39.760 --> 01:00:49.880]   hier A auf 1 initialisiert, wir rufen die Methode MyMesset auf, ja, x bekommt den Wert 1, wir berechnen
[01:00:49.880 --> 01:00:57.680]   hier 2 mal 1 ist 2, wir speichern den Wert 2 und wenn wir das drucken, gibt das hier als Output 2, ja,
[01:00:57.680 --> 01:01:03.520]   und danach sind wir hier fertig und jetzt geht es hier weiter und was macht diese Anweisung,
[01:01:03.520 --> 01:01:08.920]   wo wir jetzt diese Variable A drucken, die gibt uns natürlich wieder die 1 auf, weil was immer hier
[01:01:08.920 --> 01:01:15.400]   in der Methode mit dem Basiswert passiert, in dem Basistypwert passierte, hat keinen Einfluss auf
[01:01:15.400 --> 01:01:25.600]   die aufrufende Methode, das A hat immer noch den Wert 1 und ist unverändert, ja, das ist, ja, so.
[01:01:25.600 --> 01:01:31.480]   Also, da hier war die Frage, sind alle Variable, Referenzvariable, die Antwort ist, nein, ja,
[01:01:31.480 --> 01:01:37.440]   sehen Sie, dieses ist eine Basistypvariable, das ist der Wert, der wird gespeichert, übergeben,
[01:01:37.440 --> 01:01:43.520]   die Methode kann machen, was sie will, was immer in der Methode passiert, bleibt in der Methode und
[01:01:43.520 --> 01:01:51.120]   am Ende wird eben halt hier der Wert gedruckt, in diese Variable, in dieser anderen aufrufenden
[01:01:51.120 --> 01:02:00.320]   Methode hat, ja, bei Referenz Semantics, ja, da werden die eben die Variable, die Re-Referenzvariable,
[01:02:00.320 --> 01:02:06.880]   die werden da als mit Referenz übergeben, ja, das heißt die Parametervariable verweist auf
[01:02:06.880 --> 01:02:14.160]   den selben Re, wie, oder später, wenn wir sehen, dasselbe Objekt, das gilt da genauso, ja, wie die
[01:02:14.160 --> 01:02:22.720]   Variable im Aufrufer, ja, da haben hier den Re, haben hier den Int-Re initialisiert mit 1 und 2
[01:02:22.720 --> 01:02:29.160]   und wenn wir jetzt das, da haben wir hier eine Methode, die nennen wir wieder mal Methode,
[01:02:29.160 --> 01:02:38.040]   und die erwartet jetzt eben einen Int-Re-Referenz, ja, die erwartet hier eine Referenz auf einen
[01:02:38.040 --> 01:02:43.640]   Int-Re, habe ich immer noch X genannt, um zu zeigen, dass die, dass der Name der Variable
[01:02:43.640 --> 01:02:49.120]   überhaupt keine Rolle spielt, so, wenn ich jetzt also hingehe und das zum ersten Mal hier drucke, ja,
[01:02:49.120 --> 01:02:54.960]   was bekomme ich daraus, bekomme ich 1 und 2 heraus, ja, bekomme ich hier als Ergebnis, ja,
[01:02:54.960 --> 01:03:00.440]   dann druckte ich hier, habe ich den Re, da bekomme ich hier eben als Ergebnis 1 und 2, je nachdem,
[01:03:00.440 --> 01:03:05.320]   wie der das gedruckt hat, ja, so, jetzt rufe ich diese Methode MyMesset auf, was macht die,
[01:03:05.320 --> 01:03:11.520]   die setzt das Element mit Index 0 auf 9, ja, und danach druckt sie das wieder aus, und was gibt
[01:03:11.520 --> 01:03:18.240]   die jetzt ja als nächstes aus, die gibt aus 9 und 2, ja, weil das Element mit Index 0 habe ich auf 9
[01:03:18.240 --> 01:03:23.240]   gesetzt, ja, danach bin ich fertig und mache ich hier weiter, und jetzt ducke ich nochmal diesen
[01:03:23.240 --> 01:03:28.280]   Re A aus, ja, und was ergibt das, na ja, das hat sich ja nichts mehr geändert, das ergibt wieder
[01:03:28.280 --> 01:03:35.880]   9 und 2, ja, so, das ist das, was ich hier bekomme, wenn ich dieses einfache Beispiel durchrechne, ja,
[01:03:35.880 --> 01:03:41.520]   so, jetzt weiß ich nicht, finden Sie das langweilig? Wer findet das langweilig, sagen Sie ehrlich,
[01:03:41.520 --> 01:03:51.760]   okay, wer findet das eine Herausforderung, wer ist überhaupt hier, also wer findet das, okay,
[01:03:51.760 --> 01:04:00.200]   wer findet das interessant, aber möchte nicht mehr davon hören, okay, und wer möchte noch mehr
[01:04:00.200 --> 01:04:06.480]   davon hören? Okay, ein paar Leute, okay, ja, aber ganz wenige, jetzt sage ich, soll ich mich an, also,
[01:04:06.480 --> 01:04:11.480]   also, mach mal paar Quizzes habe ich, die restlichen Quizzes, die können Sie dann in der Übung
[01:04:11.480 --> 01:04:20.760]   uns grob vermachen, also haben wir hier eine Methode plus 1, die nimmt einen Parameter vom Typ
[01:04:20.760 --> 01:04:29.160]   int entgegen, verändert, erhöht ihn um 1, gibt den Wert zurück, und ich habe hier, möchte danach
[01:04:29.160 --> 01:04:36.600]   wissen, was ist der Output von, wenn ich j und k ducke, denken Sie, grunde nach, während ich die
[01:04:36.600 --> 01:04:41.360]   Tür wieder mal zu mache, und überlegen Sie, was für Zahlen da gedruckt werden müssten,
[01:04:41.360 --> 01:04:50.240]   der kam wieder rein, also der kam aber rein, ja, kam aber rein, bin ich ziemlich sicher,
[01:04:50.240 --> 01:04:58.760]   wenn ich würde da klopfen, also ist so die Klimaanlage flippt aus, die Klimaanlage flippt aus, wenn die
[01:04:58.760 --> 01:05:04.480]   Tür offen ist, und dann wird es hier, vielleicht wollen wir es jetzt alle warm haben, aber okay,
[01:05:04.480 --> 01:05:11.280]   was klar, die Antwort ist, es wird 3 und 4 gedruckt, ja, warum die Methode gibt hier,
[01:05:11.280 --> 01:05:17.680]   die kriegt die als Parameter 3, das ergibt den Wert 4, wir geben 4 zurück, das heißt,
[01:05:17.680 --> 01:05:24.120]   wir speichern 4 hier und geben das raus, aber die variable j natürlich ist davon nicht betroffen,
[01:05:24.120 --> 01:05:33.840]   ja, so, jetzt haben wir hier eine andere Methode, die einen, die haben wir oben,
[01:05:33.840 --> 01:05:41.280]   re x und wir geben den, das Element mit index 0 als Parameter, und hier haben wir wieder die
[01:05:41.280 --> 01:05:48.080]   gleiche Methode, Plastvan, die wir davor hatten, und jetzt drucken wir aus diesen re x, nachdem
[01:05:48.080 --> 01:05:57.360]   diese Methode ausgeführt wurde, oder wir könnten die auch einfach so separat austrucken, ja, so,
[01:05:57.360 --> 01:06:10.320]   was, was gibt es denn hier als Aufgabe? Sollte wahrscheinlich M sein, es ist dann leichter zu
[01:06:10.320 --> 01:06:22.360]   sehen, so, was gibt es hier, ja, also, wenn ich hier eben die Methode Plastvan habe, die das
[01:06:22.360 --> 01:06:32.040]   erste Element erhöht, ja, die nimmt dieses Element, das hat den Wert 2, ja, dem Wert,
[01:06:32.040 --> 01:06:39.840]   hier kommt, hier kommt der, hier ist der Wert 2, hier kommt der Wert 2 hin, das wird auf 3 erhöht,
[01:06:39.840 --> 01:06:47.200]   daher gibt es als Rückgabe den Wert 3, das heißt M bekommt den Wert 3, aber der re x ist unverändert,
[01:06:47.200 --> 01:06:55.760]   weil wir machen keine Änderungen bei x, ja, so, ja, das ist also, daher ist das eben die Ausgabe,
[01:06:55.760 --> 01:07:00.360]   die wir haben wollen, wir haben wahrscheinlich falsch gedruckt, so, okay, hier haben wir noch einen,
[01:07:00.360 --> 01:07:07.200]   nehmen wir hier einen Methode Plastvan, die erwartet eine Referenz auf einen int re, so,
[01:07:07.200 --> 01:07:14.160]   hier oben haben wir wieder unseren re x und was macht diese Methode jetzt, die geht hin über alle
[01:07:14.160 --> 01:07:21.880]   Elemente oder zumindest alle die da verfügbar sind, erhöht sie den Wert um 1, ja, so, was passiert
[01:07:21.880 --> 01:07:29.400]   denn jetzt, wenn wir nach Ausführung dieser Methode jetzt hier den, diesen re x drucken,
[01:07:29.400 --> 01:07:35.480]   ja, was macht ihr, kommen wir hier hin, ja, wir haben hier e y, bezieht sich hier auf diesen re,
[01:07:35.480 --> 01:07:42.800]   ja, denselben re wie x, ja, jetzt gehen wir hin, erhöhen alle Elemente um 1, das ist 3, 5 und so
[01:07:42.800 --> 01:07:49.800]   weiter, ja, und wenn wir das dann drucken, bekommen wir genau das heraus, ja, so, also, wer fand das jetzt,
[01:07:49.800 --> 01:07:59.200]   wer hat Frage dazu oder wer, ja, genau, hier gibt es keinen Return, weil ich habe die Methode auch
[01:07:59.200 --> 01:08:05.280]   mit "w" deklariert, die hat keinen Return Wert, ja, ich muss keinen Return Wert ist nicht zwingend,
[01:08:05.280 --> 01:08:10.120]   wenn ich das nicht will, dann mache ich Return Typ "w" und das sagt dann, es ist kein Return Typ,
[01:08:10.120 --> 01:08:17.960]   okay, dann nehmen Sie mal Ihre, Ihre Device raus, wir haben noch ein paar mehr von denen, aber ich
[01:08:17.960 --> 01:08:27.480]   habe hier einen, die bisschen, so, nehmen wir doch den, ja, und sie sollen mir jetzt sagen, was für Output
[01:08:27.480 --> 01:08:39.520]   da herauskommt, ja, so, und das schicken Sie mir, also, das schreiben Sie als Antwort rein, aber bitte mit
[01:08:39.520 --> 01:08:46.120]   diesen eckigen Klammern und mit den Komma wie nötig, ja, Lehrzeichen können Sie nach eigenem
[01:08:46.120 --> 01:08:54.160]   Gusto machen, aber eben die Kommas und die eckigen Klammern, die brauche ich halt, so, hier haben wir
[01:08:54.160 --> 01:09:05.320]   also eine Methode plus ohne Frage, ja, so, und wir rufen das hier auf, erwarten einen Parameter Y,
[01:09:05.320 --> 01:09:12.680]   das ist ein Int, eine Referenzvariable, die auf ein Int erhebeziehen kann und ja, da arbeiten wir ein
[01:09:12.680 --> 01:09:20.440]   bisschen was und dann ist die Frage, nachdem wir das für die, nachdem wir das mit dem Parameter G,
[01:09:20.440 --> 01:09:27.320]   den wir hier oben initialisiert haben, aufgerufen haben, was ist die Ausgabe, wenn ich danach diesen
[01:09:27.320 --> 01:09:43.280]   Array mittels, so, Pretty Print mache, ja, so, und bitte schicken Sie, ich freue mich immer für
[01:09:43.280 --> 01:09:55.280]   Antworten. So, wer fand denn diese Aufgabe leicht trivial, langweilig oder irgend sowas? Wer fand
[01:09:55.280 --> 01:10:02.400]   denn, okay, heben Sie sich an, wer fand die leicht trivial, langweilig? Okay, okay, was sind die richtige
[01:10:02.400 --> 01:10:12.920]   Antwort, ja, die richtige Antwort ist 2, 4, 6, 8, ja, so, jetzt warum? Ich meine, so, warum ist das
[01:10:12.920 --> 01:10:24.920]   die richtige Antwort? Sehen Sie, wir haben hier diesen Array, ja, haben diesen Array, wir haben hier
[01:10:24.920 --> 01:10:31.680]   den, diesen Array G, ja, der Rays G, der ist, hier wird hier erstellt und G bezieht sich auf
[01:10:31.680 --> 01:10:38.520]   diesen Array jetzt hier, ja, und jetzt rufen wir die Methode auf mit G als Parameter, woraufhin das
[01:10:38.520 --> 01:10:46.480]   Y sich auch auf diesen Array bezieht, ja, so, jetzt als nächstes geht aber das Programm hin und
[01:10:46.480 --> 01:10:52.240]   erstellt ein Array T mit Referenzvariable T und das ist auch wieder ein Array, gleiche Länge, damit
[01:10:52.240 --> 01:10:58.760]   es auf das Leid passt und dieser Array wird jetzt entsprechend verändert, was immer der Loop da sagt,
[01:10:58.760 --> 01:11:06.200]   ja, und wenn der fertig ist, dann lassen wir dieses, also kriegen da neue Zahlen rein, ja, jetzt lassen
[01:11:06.200 --> 01:11:12.280]   wir danach die Referenzvariable Y, die bisher auf den Array da oben verwies, jetzt auf diesen
[01:11:12.280 --> 01:11:18.640]   Array verweisen, ja, so, und danach sind wir fertig, ja, und wenn wir jetzt hingehen und danach drucken,
[01:11:18.640 --> 01:11:26.120]   was dieser, was dieser Array, was in dem Array G ist, bekommen wir genau das raus, was sie davor
[01:11:26.120 --> 01:11:32.160]   auch hatten, ja, jetzt, ich kann Ihnen jetzt nicht auf die Schnelle sagen, wie das, wie das,
[01:11:32.160 --> 01:11:40.440]   wie das diesmal ausging, aber hier zeige ich Ihnen das Ergebnis aus dem letzten Jahre, ja, also wenn
[01:11:40.440 --> 01:11:47.520]   Sie es nicht richtig hinbekommen haben, ja, also eben 37, 38% haben es letztes Jahr richtig hinbekommen
[01:11:47.520 --> 01:11:54.000]   und dann gab es diverse andere Vorschläge, ja, also wie gesagt, wenn Sie es nicht richtig hinbekommen
[01:11:54.000 --> 01:12:00.160]   haben, ist das kein, soll das nicht entmutigen, ja, aber Sie müssen wirklich da genau gucken, Sie
[01:12:00.160 --> 01:12:06.280]   müssen genau sehen, was in so einem Programm gemacht wird, paar Leute haben wir das hier in den Chat
[01:12:06.280 --> 01:12:13.040]   geschrieben, das ist für mich nicht ganz so einfach zu auszuarbeiten, wie wenn ich es eben mit,
[01:12:13.040 --> 01:12:19.160]   mit dem, mit der Edu App bekommen, da kann ich das dann nach bearbeiten, so, also wie gesagt,
[01:12:19.160 --> 01:12:25.760]   das ist ein einfaches Beispiel, was einem da alles passieren kann, so, und damit sind wir eigentlich
[01:12:25.760 --> 01:12:33.600]   mit Errace fürs erste Mal fertig und wir kommen jetzt dazu uns etwas mehr, wie ich sagte, die mit
[01:12:33.600 --> 01:12:38.960]   den Klassen zu beschäftigen, weil die beiden hängen ja ganz dicht mit den Errace zusammen,
[01:12:38.960 --> 01:12:46.040]   das ist ja alles Errace und Klassen-Objekte sind verwandte Themen und darum wollen wir jetzt da
[01:12:46.040 --> 01:12:51.560]   weitermachen. Und da haben wir verschiedene Sachen, die wir uns angucken wollen, ja, und jetzt gucken
[01:12:51.560 --> 01:12:55.880]   wir mal allgemein an und vielleicht können wir dann am Freitag sehen, wie wir Klassen selber
[01:12:55.880 --> 01:13:07.160]   entwickeln. Also, also Klassen können in Java für verschiedene Zwecke verwendet werden. Einen
[01:13:07.160 --> 01:13:14.200]   Zweck haben wir bereits in der ersten Teil dieser Folie gesehen, ja, wir implementieren einen Algorithmus
[01:13:14.200 --> 01:13:22.560]   oder eine Applikation, ja, und diese Service wird dann von der, wird dann zur Verfügung gestellt
[01:13:22.560 --> 01:13:27.920]   und wenn immer wir das Programm ausführen, dann führen wir eben diesen einen Algorithmus auf,
[01:13:27.920 --> 01:13:32.680]   wobei Algorithmus für einige der Probleme, die wir jetzt hier hatten, ein ziemlich hochtrabender
[01:13:32.680 --> 01:13:38.560]   Begriff ist, ja. Dann gibt es die Möglichkeit, das haben wir jetzt gesehen, dieser Klasse Errace,
[01:13:38.560 --> 01:13:44.920]   wo jemand eben so eine Bibliothek zusammenstellt. Diese Klasse oder dieser Bibliothek lieferte
[01:13:44.920 --> 01:13:50.920]   uns verschiedene Methoden, wie zum Beispiel die Möglichkeit zwei Errähreferenzen zu vergleichen,
[01:13:50.920 --> 01:13:57.080]   ob sie auf Errace verweisen, die dieselben Elemente haben oder wir konnten einen Erräh besonders
[01:13:57.080 --> 01:14:05.840]   gut drucken, ja. Es gibt eine andere, die heißt MES, die enthält diverse MES-Routinen, ja. Und dann
[01:14:05.840 --> 01:14:12.440]   können wir Klasse benutzen, um irgendwelche Services für Objekte zu realisieren. Und das
[01:14:12.440 --> 01:14:17.600]   hatten wir so ein bisschen gesehen, wir hatten das gesehen im Scanner und in dem Zufahrt-Zahlen-Generator,
[01:14:17.600 --> 01:14:22.160]   ja. Wir haben ein Objekt erstellt für den Scanner und dann hat der Scanner uns die Zahlen
[01:14:22.160 --> 01:14:27.200]   geliefert, ja, oder wir hatten einen Zufahrt-Zahlen-Generator erstellt und dann gab es die Möglichkeit,
[01:14:27.200 --> 01:14:32.960]   da nächst eben die nächste Integer zu bekommen. Und das haben wir, da haben wir eben diesen
[01:14:32.960 --> 01:14:37.520]   New-Operator verwendet, um die zu erstellen und wir haben auch ein paar Mal das benutzt, ohne den
[01:14:37.520 --> 01:14:43.720]   New-Operator zu verwenden, warum? Weil die bereits existierten, ja. Also wie System.out oder System.in,
[01:14:43.720 --> 01:14:51.760]   das sind zwei weitere Objekte im System, die wir für Ein- und Ausgabe verwenden konnten, ja. So,
[01:14:51.760 --> 01:14:59.280]   also und das ist der gleiche Ansatz, den wir benutzen werden, wenn wir jetzt selber Services,
[01:14:59.280 --> 01:15:05.120]   Objekte implementieren, die Services anbieten, oder wenn wir irgendetwas realisieren wollen, ja. Und
[01:15:05.120 --> 01:15:10.640]   das ist der Ansatz, den wir benutzen werden, um selbst entwickelte Klassen eben in dieses System
[01:15:10.640 --> 01:15:19.040]   einzubauen und damit eben etwas zu machen, ja. So, also diese Trennung ist nicht so strikt, ob
[01:15:19.040 --> 01:15:24.080]   sie jetzt hier einen Algorithmus haben oder ob sie da aufgrund irgendwelcher Eingaben zwischen
[01:15:24.080 --> 01:15:31.200]   mehreren Auswählen oder sowas, ja. Das ist alles letztlich Einschätzungssache. Aber im Prinzip
[01:15:31.200 --> 01:15:36.920]   sollten Sie sehen, dass es eben halt diese drei Möglichkeiten gibt, Klassen einzusetzen. Einmal
[01:15:36.920 --> 01:15:42.440]   so als eine Stand-alone-Applikation, das der erste Fall eine Bibliothek mit verschiedenen
[01:15:42.440 --> 01:15:49.960]   Services oder eben Objekte, die wir selber realisieren, um Services zur Verfügung zu stellen, ja. Und
[01:15:49.960 --> 01:15:54.880]   natürlich, wenn wir sagen Algorithmus, gibt es eventuell Teilprobleme, die durch Teilalgorithmen
[01:15:54.880 --> 01:16:02.880]   behandelt werden, ja. Also, in dem ersten Fall, ja, wo wir eben einen Algorithmus da implementierten,
[01:16:02.880 --> 01:16:08.800]   wie ging das? Wir haben diese Methode Main benutzt, die hat dann eventuell andere Methoden
[01:16:08.800 --> 01:16:14.440]   aufgerufen, aber diese Methode Main wurde automatisch ausgeführt und der Name des
[01:16:14.440 --> 01:16:19.480]   Programms war quasi der Name des Services oder der Applikation, die wir entwickelt haben.
[01:16:19.480 --> 01:16:24.160]   Wenn immer wir diese Anwendung ausgeführt haben, wurde Main ausgeführt und das machte dann
[01:16:24.160 --> 01:16:29.600]   was Last Eventual, etwas vom Input oder so, aber das machte das so. Und dann haben wir gesehen,
[01:16:29.600 --> 01:16:34.640]   für den zweiten, dass wir so Klassen eine Bibliothek gefunden haben, wie diese Race Bibliothek oder
[01:16:34.640 --> 01:16:41.200]   die Scanner Bibliothek, mit der wir eben dann eben Input erledigen können oder eine bessere
[01:16:41.200 --> 01:16:46.120]   Ausgabe haben, ja. Und jetzt eben kommen wir dazu, dass wir die Klassen selber entwickeln,
[01:16:46.120 --> 01:16:50.880]   wenn wir anfangen, werden die noch sehr einfach sein und es geht da mehr ums Prinzip, aber später
[01:16:50.880 --> 01:16:55.600]   werden wir eben andere Klassen entwickeln, die dann etwas komplizierter Aufgaben für uns erledigen
[01:16:55.600 --> 01:17:04.000]   können, ja. Also, und so eine Klasse wird eben dadurch implementiert, dass wir eben diesen
[01:17:04.000 --> 01:17:10.920]   Glaskonstrakt verwenden, ja. Dadurch sagen wir, hier ist eine Klasse, ja, und das hatten wir eben
[01:17:10.920 --> 01:17:15.920]   auch an sich bisher gemacht, ohne genauer zu sehen, was das hieß, weil wir hatten eben da am
[01:17:15.920 --> 01:17:22.160]   Anfang nur mit dieser Methode Main gearbeitet, gegebenenfalls mit Untermethoden, ja. Und das
[01:17:22.160 --> 01:17:28.840]   Keyword Public ist da wichtig, weil das erlaubt ist im System diesen Service auch zu finden, ja. Und
[01:17:28.840 --> 01:17:35.280]   diese Klasse enthielt letztlich das Programm, das dann in dieser Methode Main untergebracht wurde,
[01:17:35.280 --> 01:17:42.320]   ja. So, also das war so der Ansatz, den wir bisher gewählt haben, ja. Und wenn wir jetzt eben so
[01:17:42.320 --> 01:17:46.680]   ein Programm dafür diese geschrieben haben, dann hatte das Programm eigentlich keinen
[01:17:46.680 --> 01:17:52.240]   richtigen Namen, ja. Wir haben halt diesen den Namen der Klasse genommen, der war in einer
[01:17:52.240 --> 01:17:57.600]   bestimmten Datei und das war dann der Service, den wir aufgerufen haben. Aber der Service selber
[01:17:57.600 --> 01:18:03.040]   hatte eigentlich keinen Namen und deswegen sprechen wir da von einem namenlosen Dienst, ja. Also,
[01:18:03.040 --> 01:18:08.280]   der, die Klasse, die wir hatten, stellte den Dienst zur Verfügung und die Klasse war der
[01:18:08.280 --> 01:18:14.040]   Programmname und der Dienst hatte keinen weiteren eigenen Namen und das lief dann entweder in der
[01:18:14.040 --> 01:18:20.280]   Eclipse oder in der, in der Shell ganz gut, weil dieses Main automatisch aufgerufen wurde, ja. So.
[01:18:20.280 --> 01:18:26.200]   Und das ist praktisch, wenn Sie eine Anwendung haben, die Sie da überall verwenden wollen. Aber
[01:18:26.200 --> 01:18:31.280]   das ist nicht der Weg, den wir haben wollen, wenn wir eben etwas kompliziertere Sachen selber
[01:18:31.280 --> 01:18:36.000]   kontrollieren wollen. Und dann hatten wir in dem zweiten Fall, wo wir eben mit diesen Service-Klassen
[01:18:36.000 --> 01:18:42.640]   arbeiten, ja. Da brauchten wir ein Objekt oder den Klassennamen, ja. Also, Erreys war der Name
[01:18:42.640 --> 01:18:48.640]   der Klasse und dann hatten wir die Methode Tustring, die es uns erlaubte, einen Erreys zu
[01:18:48.640 --> 01:18:55.080]   konstruieren, ja. Oder wir hatten hier ein Objekt, die Konsole, die wir gebaut hatten oder erstellt
[01:18:55.080 --> 01:19:00.880]   hatten, indem wir den New-Operator mit dem Scanner verwendet haben und dann konnten wir da die
[01:19:00.880 --> 01:19:08.080]   Methode Tustring aufrufen, sorry, und die Methode Next-Int aufrufen, um den nächsten Wert vom
[01:19:08.080 --> 01:19:15.680]   Terminal zu bekommen, ja. Also, da geben uns diese Klassen eben Dienste, die wir entweder namenlos
[01:19:15.680 --> 01:19:24.200]   oder durch aufrufen bekommen können, ja. So. Jetzt ein etwas anderer Gesichtspunkt wäre doch, dass
[01:19:24.200 --> 01:19:30.680]   wir sagen, egal, was wir da haben, alles stellt uns irgendeinen Dienst zur Verfügung, ja. Das
[01:19:30.680 --> 01:19:36.280]   Scanner stellt den Dienst zur Verfügung, nachdem wir ihn erstellt haben, mit dem wir den Next,
[01:19:36.280 --> 01:19:41.480]   also, dass wir die nächste ganze Zahl bekommen können, ja. Und das ist so der Diensteblick. Aber
[01:19:41.480 --> 01:19:48.760]   der andere Blick wäre doch zu sagen, ha, wir arbeiten hier mit Daten, ja. Und diese Daten sind
[01:19:48.760 --> 01:19:56.520]   zum Beispiel Scannerobjekte. Und für diese Scannerobjekte, da gibt's Operationen, ja. Ein Scannerobjekt,
[01:19:56.520 --> 01:20:06.560]   das den System.out als Parameter bekam. Für das ist dann irgendeine Operation, oder System.in als
[01:20:06.560 --> 01:20:12.440]   Parameter kam, sind dann Operationen definiert, ja. Oder ich kann eben System.out benutzen,
[01:20:12.440 --> 01:20:19.440]   um PrintLine zu machen. Aber das geht alles immer nur, wenn diese Objekte in einem bestimmten
[01:20:19.440 --> 01:20:25.400]   Zustand sind. Ich muss das vorher organisiert haben, ja, sodass dann der Scanner, wenn er von
[01:20:25.400 --> 01:20:32.680]   System.out inlesen will, oder der Drucker, wenn er eben halt etwas ausgeben will, der muss in
[01:20:32.680 --> 01:20:37.640]   den bestimmten Zustand sein. Der muss zumindest wissen, wo ist das Fenster, von dem ich lese und
[01:20:37.640 --> 01:20:43.600]   wie bekomme ich dadurch Daten, ja. Und wenn ich diesen Datenblick habe, dann sind die Dienst
[01:20:43.600 --> 01:20:50.520]   da eigentlich, sagen wir, sekundär. Wichtig ist, dass ich meine Objekte in einen bestimmten
[01:20:50.520 --> 01:20:57.120]   Zustand bekomme, in dem ich dann bestimmte Schritte machen kann, ja. Und das ist so eine der Grundideen,
[01:20:57.120 --> 01:21:03.320]   mit der wir uns jetzt mehr beschäftigen werden, ja. Also ein Typ besteht letztlich aus einem oder
[01:21:03.320 --> 01:21:10.160]   mehreren Zuständen und die eben ein Objekt annehmen kann und verschiedenen Operationen,
[01:21:10.160 --> 01:21:16.240]   die mit diesem Objekt gemacht werden können, ja. So ein Datentyp beschreibt letztlich, und das gilt
[01:21:16.240 --> 01:21:24.160]   unabhängig von, wie ich meine Dat, was für Typ mich habe, ja. Der Datentyp beschreibt Operationen und
[01:21:24.160 --> 01:21:31.320]   zulässige Werte und das gilt auch für die einfachen, Basistypen, die wir vorher hatten, nur gab es da
[01:21:31.320 --> 01:21:37.120]   keine Klassen, ja. Da gab es einfach aräthmetische Operatoren, die waren vom System vorgeschrieben,
[01:21:37.120 --> 01:21:42.000]   ja. Und es gab eine Methode, mit der wir das in Strings umwandeln können, aber es gab auch
[01:21:42.000 --> 01:21:48.600]   Einschränkungen, zum Beispiel dürfen wir nicht durch Null dividieren, ja. Oder beim String, das war
[01:21:48.600 --> 01:21:53.440]   auch so ein, den wir kennengelernt hatten, da gab es den Plus-Operator und wir wussten, dass wir,
[01:21:53.440 --> 01:21:58.200]   wenn wir die Tor-Upper-Case-Methode, Operation verwenden, oder die Tor-Upper-Case-Methode ausführen,
[01:21:58.200 --> 01:22:02.840]   dann gibt es irgendein neuen String. Und jetzt hatten wir heute Vormittag oder letzten Woche gesehen,
[01:22:02.840 --> 01:22:09.880]   ja, mit, wir haben hier Rays für ganze Zahlen und da gibt es dann auch vorgeschriebene Operatoren,
[01:22:09.880 --> 01:22:17.520]   ja, die vorher bereits definiert sind, wie diese eckigen Klammern, mit denen wir auf die, auf
[01:22:17.520 --> 01:22:23.000]   einzelne Elemente zugreifen können, oder wir können auf das Längsattribut zugreifen und so
[01:22:23.000 --> 01:22:32.040]   die Länge dieses, dieses Rays herausbekommen, ja. So, also diese allgemeine Idee, was ein Typ ist,
[01:22:32.040 --> 01:22:38.760]   ja, die wird jetzt auch für die Klassen angewendet, ja. Klassen beschreiben auch einen Typ, das heißt,
[01:22:38.760 --> 01:22:44.760]   sie beschreiben auch wieder Eigenschaften von Daten, Zustände, die das System annehmen kann, ja.
[01:22:44.760 --> 01:22:50.520]   Mathematisch könnte man sagen, der Typ beschreibt eine Menge oder eine Kategorie von Datenwerten,
[01:22:50.520 --> 01:22:56.600]   ja. Der sagt dann, was für Datenwerten, werte legal sind. Wenn wir jetzt die Konsole angucken,
[01:22:56.600 --> 01:23:02.160]   ist das wahrscheinlich schwer zu visualisieren, wie diese Datenwerte aussehen, aber in anderen
[01:23:02.160 --> 01:23:07.520]   Situationen könnten wir uns auch ein leichter vorstellen, ja. Und dieser Typ schränkt dann auch
[01:23:07.520 --> 01:23:13.240]   die Operationen ein, die wir mit diesen Datentypen machen können. Also auch wenn ich den Scanner
[01:23:13.240 --> 01:23:18.320]   habe, kann ich die eine ganze Zahl lesen oder eine reelle Zahl lesen, aber ich kann nichts
[01:23:18.320 --> 01:23:25.640]   was Scanner miteinander erdieren. Und die Basitypen, ja, die sind eben so die Ausnahme,
[01:23:25.640 --> 01:23:32.240]   das sind eben Typen ohne Klasse, ja. Die sind eingebaut mit den üblichen Operatoren und Operationen
[01:23:32.240 --> 01:23:37.360]   und in Java können wir da keine neuen hinzufügen, ja. Da sind eben halt, die sind auch ein Typ
[01:23:37.360 --> 01:23:43.960]   aber eben ein Typ ohne Klasse, ja. So. Und den Begriff Objekt verwenden wir jetzt als Sammelbegriff
[01:23:43.960 --> 01:23:51.400]   für alle Datenwerte, die durch irgendeine Klasse beschrieben werden können oder durch oder errasseln
[01:23:51.400 --> 01:23:57.880]   oder aus errasseln, ja. Also Scanner ist ein Objekt, also ein konkreter Scanner, den wir erstellt haben.
[01:23:57.880 --> 01:24:03.880]   Ein konkreter Zufallszahlengenerator ist ein Objekt, ein stringes ein Objekt, ein erhees ein
[01:24:03.880 --> 01:24:10.160]   Objekt, ja. Das sind die Regeln, das sind die Sachen mit denen unsere Programme erarbeiten.
[01:24:10.160 --> 01:24:15.800]   Und wenn wir uns auf ein Exemplar, auf ein Objekt beziehen wollen, also auf ein konkretes Objekt
[01:24:15.800 --> 01:24:21.760]   beziehen wollen, dann sagen wir manchmal, das ist ein Objektexemplar oder wenn wir Zeit sparen wollen,
[01:24:21.760 --> 01:24:28.000]   dann sagen wir ein Exemplar. Aber bevor ich mich auf, genauso wie mich auf ein erhees arbeiten kann,
[01:24:28.000 --> 01:24:35.000]   nachdem der existiert, ich muss diesen erhees erschaffen oder erstellen. Und manche Leute benutzen
[01:24:35.000 --> 01:24:42.040]   im Deutschen das Wort "instanzieren", was aber nicht sehr gut ist, weil es auch verschiedene andere
[01:24:42.040 --> 01:24:48.640]   Nebenbedeutungen haben könnte, ja. So. Und wir erstellen wir Objekte, naja, wir erstellen Objekte
[01:24:48.640 --> 01:24:53.600]   mit dem New-Operator. Das haben wir schon gesehen. So haben wir einen neuen Scanner bekommen oder so
[01:24:53.600 --> 01:24:58.680]   haben wir einen neuen Zufallszahlen-Generator bekommen. Wir können manchmal, es gibt auch ja,
[01:24:58.680 --> 01:25:04.920]   manchmal können wir das durch eine Initialisierung machen, ja. Wir können für den String, den
[01:25:04.920 --> 01:25:10.160]   können wir eben ein anonymes Objekt erstellen und dann eben so eine Initialisierung machen. Oder
[01:25:10.160 --> 01:25:16.280]   wir können das so für die Integer-Errace machen, ja, für die Errace machen, ja. Jetzt kommt vielleicht
[01:25:16.280 --> 01:25:22.120]   schon die Frage, aber könnten wir dann auch Strings mit dem New-Operator erstellen? Und die Antwort
[01:25:22.120 --> 01:25:30.240]   ist im Prinzip ja, aber das ist nicht empfohlen. Und die kurze Antwort ist, weil Strings sind
[01:25:30.240 --> 01:25:39.160]   besonders optimiert und dann ist das eben halt nicht, können das System etwas ärgern, wenn das
[01:25:39.160 --> 01:25:46.040]   eben halt nicht anders, wenn wir sowas machen, es ist erlaubt, ja, aber machen sie es nicht, ja. So.
[01:25:46.040 --> 01:25:51.560]   Und wenn ich jetzt auf irgendein Objekt zugreifen will, ja, wie bei den Erraces, ich brauche einen
[01:25:51.560 --> 01:25:57.320]   Namen, der Name muss deklariert sein, der Name verweist auf das Objekt, ist also eine
[01:25:57.320 --> 01:26:03.640]   Referenzvariable, ist nicht das Objekt selber, sondern eine Referenzvariable und dann gibt es eben
[01:26:03.640 --> 01:26:11.080]   die Möglichkeit mehr Informationen eventuell über diesen Errace zu bekommen, ja. Und dann mit
[01:26:11.080 --> 01:26:16.840]   der Einliste, die einzige Ausnahme, die ist Strings, da können sie auch mit Objekten arbeiten,
[01:26:16.840 --> 01:26:22.640]   ohne dass sie eine Referenzvariable haben. Also Referenzvariable beziehen sich entweder auf
[01:26:22.640 --> 01:26:28.800]   ein Array oder einen Strings oder einen Scanner oder irgendwas, beziehen sich immer auf ein Objekt
[01:26:28.800 --> 01:26:35.280]   und sie brauchen so eine, um entweder eine Methode auszuführen, auf ein Element zuzugreifen, für
[01:26:35.280 --> 01:26:42.000]   die Errace gibt es diesen Operator, für andere gibt es einen anderen Weg, das zu machen oder um mit dem zu arbeiten.
[01:26:42.000 --> 01:26:49.320]   Ja, so, das also ist das, womit wir uns im nächsten, der nächsten Folgen um Beschäftigung
[01:26:49.320 --> 01:26:51.840]   werden. Das wäre es für heute. Schönen Tag noch.
[01:26:51.960 --> 01:26:53.960]   [Applaus]
[01:26:53.960 --> 01:26:55.960]   [Beifall]
[01:26:55.960 --> 01:26:57.620]   [Beifall]

