
[00:00:00.000 --> 00:00:05.680]   So, wir wollen jetzt noch weitermachen mit dem Thema, das wir gestern schon angefangen
[00:00:05.680 --> 00:00:12.840]   hatten, nämlich einfache Java-Programme und eben Typen und Variable und Operationen,
[00:00:12.840 --> 00:00:14.160]   die damit gemacht werden können.
[00:00:14.160 --> 00:00:19.120]   Wir haben angefangen mit diesen Primitive-Types, diesen eingebauten oder Basestypen, hatten
[00:00:19.120 --> 00:00:21.920]   gesehen, wie Deklarationen und Definitionen funktioniert.
[00:00:21.920 --> 00:00:26.720]   Da ist eben irgend so ein Ausdruck auf der rechten Seite und wir hatten angefangen zu
[00:00:26.720 --> 00:00:29.840]   diskutieren, was die Regeln für solche Ausdrücke sind.
[00:00:29.840 --> 00:00:34.760]   Und wie Sie sich denken können, gibt es dafür eine EBNF-Beschreibung, die hatte ich Ihnen
[00:00:34.760 --> 00:00:40.400]   auch gestern gezeigt, es sind keine Überraschungen, es sind so, wie Sie Ausdrücke aus der Mathematik
[00:00:40.400 --> 00:00:45.400]   oder Schule gewohnt sind und eben Number ist das, was eben weder eine ganze Zahl oder
[00:00:45.400 --> 00:00:49.320]   eine reale Zahl in zwei verschiedenen Formaten sein kann.
[00:00:49.320 --> 00:00:51.320]   Es gibt noch mehr Formate, ja.
[00:00:51.320 --> 00:00:56.040]   Das sind die Little Worlds, die im Text selbst auftretenden Symbole.
[00:00:56.040 --> 00:01:02.200]   Und natürlich diese Beschreibung, die gibt uns nur die Sintags, die sagt uns nur, wie
[00:01:02.200 --> 00:01:05.760]   ein Ausdruck geformt wird, aber sagt nicht, was die Bedeutung ist.
[00:01:05.760 --> 00:01:11.360]   Und das heißt, wenn wir also irgendeine Operation haben mit einem Operator, mit zwei Integers
[00:01:11.360 --> 00:01:18.080]   A und B, dann müssen wir wissen oder diskutieren, was ist das Ergebnis und da wir ja immer Typen
[00:01:18.080 --> 00:01:20.720]   haben, was für einen Typ hat das Ergebnis.
[00:01:20.720 --> 00:01:25.920]   Und da fangen wir eben mit den einfachen arithmetischen Operationen an und fangen mit INS an, weil
[00:01:25.920 --> 00:01:28.440]   das ist für jeden Typ eventuell anders.
[00:01:28.440 --> 00:01:31.760]   Also und jede Operation hat einen festgelegten Typ.
[00:01:31.760 --> 00:01:38.160]   Ich hatte schon gesagt, wir haben die Regel hier, dass wenn wir zwei Operanten des selben
[00:01:38.160 --> 00:01:44.160]   Typs irgendwie verknüpfen, dann ergibt das auch wieder ein Ergebnis in dem selben Typ.
[00:01:44.160 --> 00:01:48.320]   Das gilt für die arithmetischen Operatoren, eben Plus-, Minus und so weiter.
[00:01:48.320 --> 00:01:51.880]   Andere Operatoren lernen was später mal kennen, da geht das nicht.
[00:01:51.880 --> 00:01:56.120]   Und die Frage, die dann in der Pause kam oder auch im Chat, was passiert denn, wenn wir
[00:01:56.120 --> 00:01:58.200]   Typ A mit Typ B kombinieren?
[00:01:58.200 --> 00:02:03.160]   Naja, das werden wir erstmal angucken, nachdem wir uns den ersten Teil angesehen haben.
[00:02:03.160 --> 00:02:08.000]   Also, wenn ich zwei Integer zahlen, dividiere, dann ergibt das Ergebnis auch wieder eine
[00:02:08.000 --> 00:02:09.000]   Integer.
[00:02:09.000 --> 00:02:15.600]   Also 14 dividiert durch 4, ergibt 3, weil das ist die größte Integer, die wir da unterbringen
[00:02:15.600 --> 00:02:16.600]   können.
[00:02:16.600 --> 00:02:19.600]   Da haben Sie der Schule sicher mal gelernt, wie man sowas berechnet.
[00:02:19.600 --> 00:02:24.760]   Und eben, wenn Sie hier 32 durch 5 ergibt 6 und so weiter.
[00:02:24.760 --> 00:02:26.720]   Das gilt auch für die negativen Zahlen.
[00:02:26.720 --> 00:02:30.520]   Minus 4 dividiert durch 3 ergibt eben minus 1.
[00:02:30.520 --> 00:02:36.280]   So, und wenn Sie jetzt versuchen sollten, während der Ausführung so eine Operation durch
[00:02:36.280 --> 00:02:39.320]   0 zu dividieren, naja, das mag das System nicht.
[00:02:39.320 --> 00:02:44.880]   Und dann gibt es eben eine exception, eine Fehlermeldung, die sagt, dass das eben nicht
[00:02:44.880 --> 00:02:45.880]   akzeptiert ist.
[00:02:45.880 --> 00:02:51.160]   Und dann gibt es auch einen schönen Operator, den Rest-Operator, der ja mit diesem Prozentzeichen
[00:02:51.160 --> 00:02:52.160]   ausgedrückt wird.
[00:02:52.160 --> 00:02:53.960]   Und der gibt eben den Rest.
[00:02:53.960 --> 00:03:03.520]   Also 14 dividiert durch 4 ergibt 3, der Rest war 2, darum 14 Rest 4 ergibt 2, oder 218
[00:03:03.520 --> 00:03:05.120]   Rest 5 ergibt 3.
[00:03:05.120 --> 00:03:07.120]   Gleiche Berechnung, ja.
[00:03:07.120 --> 00:03:12.440]   Der ist sehr praktisch, wenn Sie die letzte Ziffer brauchen von irgendeiner Zahl, Rest
[00:03:12.440 --> 00:03:13.440]   10.
[00:03:13.440 --> 00:03:18.320]   Die letzten 4 Ziffern, Rest 10.000, ja, gibt Ihnen die letzten 4 Ziffern.
[00:03:18.320 --> 00:03:23.400]   Und wenn Sie feststellen wollen, ob eine Zahl gerade oder ungrade ist, ja, wenn Sie eine
[00:03:23.400 --> 00:03:26.600]   gerade Zahl haben, ergibt das den Rest 0.
[00:03:26.600 --> 00:03:31.720]   So können Sie leicht feststellen, ob da eine gerade oder ungrade Zahl ist.
[00:03:31.720 --> 00:03:35.800]   Und hier habe ich so ein paar Beispiele, picken sich eins von denen raus und überlegen Sie,
[00:03:35.800 --> 00:03:36.800]   was die Antwort sein sollte.
[00:03:36.800 --> 00:03:41.800]   Ich werde jetzt dafür nicht ein Klicker starten, das ist zu, kann nämlich auch da nicht gut
[00:03:41.800 --> 00:03:42.800]   die Antwort entgegennehmen.
[00:03:42.800 --> 00:03:50.800]   Also es ist ziemlich einfach, ja, also hier 10 dividiert durch 4 ergibt 2, dies hier ist
[00:03:50.800 --> 00:03:55.320]   ein bisschen nachdenken, 11 Rest 0.
[00:03:55.320 --> 00:03:57.480]   Was ist der Rest von 11 dividiert durch 0?
[00:03:57.480 --> 00:03:59.960]   Naja, durch 0 dividieren dürfen wir doch nicht.
[00:03:59.960 --> 00:04:03.560]   Also beschwert sich das System und sagt Laufzeitfehler, ja.
[00:04:03.560 --> 00:04:10.400]   Arithmetic exception division by 0 division, ja, das ist also, so.
[00:04:10.400 --> 00:04:13.720]   Das war also der erste Einsatz einstieg.
[00:04:13.720 --> 00:04:17.320]   Jetzt gibt es aber natürlich Ausdrücke, die haben mehrere Operanden, ja.
[00:04:17.320 --> 00:04:23.560]   Wir hätten zum Beispiel einen Ausdruck mit operanten x, y und z und da ist ein Operator
[00:04:23.560 --> 00:04:26.040]   und der taucht zweimal auf, ja.
[00:04:26.040 --> 00:04:32.120]   Naja, Sie haben ja mal Artikel gelernt, wenn Sie 7 plus 5 plus 3 haben, dann bedeutet das
[00:04:32.120 --> 00:04:36.120]   eben, dass 7 plus 5 addiert werden und dann 3 dazu, ja.
[00:04:36.120 --> 00:04:42.120]   Und 64 durch 8 durch 2 heißt eben, dass wir erst 64 durch 8 und dann durch 2 teilen
[00:04:42.120 --> 00:04:48.120]   und eben nicht 64 dividieren durch die Quotienten von 8 und 2, ja.
[00:04:48.120 --> 00:04:51.880]   So, jetzt also was entscheidet, wie wir so was machen.
[00:04:51.880 --> 00:04:56.680]   Da gibt es den Ausdruck, den haben Sie sicher schon mal gehört, associativität, ja.
[00:04:56.680 --> 00:05:02.080]   Jeder Operator hat eine Associativität und daraus können wir dann, das entscheidet
[00:05:02.080 --> 00:05:06.160]   dann, welcher der Operanten zuerst verarbeitet wird, ja.
[00:05:06.160 --> 00:05:13.600]   Also, wenn Sie hier einen Operanten y haben, ja, da gibt es zwei Möglichkeiten.
[00:05:13.600 --> 00:05:19.840]   Die eine ist dieser Operator, das hier ist der Operator, ja, der ist linksassociativ
[00:05:19.840 --> 00:05:27.600]   und das heißt, in dem Fall wird dieser Operant y zuerst mit dem linken Operanten verarbeitet, ja.
[00:05:27.600 --> 00:05:31.600]   Oder der Operator ist rechtsassociativ.
[00:05:31.600 --> 00:05:37.600]   In dem Fall würde eben halt der, dieses y zuerst mit dem zapp verarbeitet werden, ja.
[00:05:37.600 --> 00:05:44.800]   Das ist der, also gibt links- und rechtsassociative Operatoren und je nachdem,
[00:05:44.800 --> 00:05:50.240]   was wie der Operator definiert ist, wird dann entweder die eine oder die andere,
[00:05:50.240 --> 00:05:53.040]   der andere Operant als erster genommen, ja.
[00:05:53.040 --> 00:05:55.200]   Das ist die, ja.
[00:05:55.200 --> 00:05:59.760]   Und das ist eben, müssen wir festlegen und das sagt die Grammat, die ebnf,
[00:05:59.760 --> 00:06:02.560]   das regelt uns, sagt uns überhaupt nichts, ja.
[00:06:02.560 --> 00:06:08.880]   Und die meisten Operatoren, die Sie bisher kennengelernt haben, die sind linksassociativ, ja.
[00:06:08.880 --> 00:06:14.800]   Die haben Sie, das sind die, die Sie in der Mathematik bisher kennengelernt haben, vermute ich.
[00:06:14.800 --> 00:06:18.800]   So, ja. Also die Addition, Multiplikation, ja.
[00:06:18.800 --> 00:06:24.240]   Aber es gibt eben auch die rechtsassociativen und da werden wir heute noch ein Beispiel sehen, ja.
[00:06:24.240 --> 00:06:29.120]   Und wenn Sie aus der Mathematik kommen, dann sagen Sie, operatoren sind doch associativ,
[00:06:29.120 --> 00:06:33.040]   das heißt, es macht keinen Unterschied, wie wir die Klammern setzen, ja.
[00:06:33.040 --> 00:06:37.520]   Das ist, ja, in der Mathematik geht das, in der Mathematik ist das Leben einfach, ja.
[00:06:37.520 --> 00:06:39.920]   Da können Sie die Klammern setzen, wie Sie wollen, ja.
[00:06:39.920 --> 00:06:42.480]   Das ist leider auf dem Computer nicht mehr so, ja.
[00:06:42.480 --> 00:06:46.240]   Und wir werden später sehen, dass das einige Folgen für uns haben kann.
[00:06:46.240 --> 00:06:51.760]   Aber eben die gewohnten arithmetischen Operatoren sind alle linksassociativ.
[00:06:51.760 --> 00:06:52.880]   Aber das ist noch nicht alles.
[00:06:52.880 --> 00:06:56.800]   Es gibt ja noch ein paar mehr Sachen, die wir uns durch den Kopf gehen lassen müssen,
[00:06:56.800 --> 00:07:02.160]   wenn wir so einen Ausdruck uns angucken, der mehrere Operatoren hat.
[00:07:02.160 --> 00:07:07.920]   Nämlich, es ist ja durchaus möglich, dass die Operatoren unterschiedlich sind, ja.
[00:07:07.920 --> 00:07:14.160]   Sie wissen, wenn wir hier 2 plus 6 mal 5 sehen, dann wissen Sie, dass die Antwort 32 ist, ja.
[00:07:14.160 --> 00:07:20.640]   Ja, wissen Sie, dass die Antwort eben, da gehen wir erst hin, machen wir das, das ist 30.
[00:07:20.640 --> 00:07:25.360]   Und dann dazu plus 2 ergibt 32. Ja, wir gehen nicht anders hin.
[00:07:25.360 --> 00:07:29.280]   Das ist halt das, was wir normalerweise machen, ja.
[00:07:29.280 --> 00:07:35.600]   Also, wenn ein Ausdruck mehrere Operanten mit verschiedenen Operatoren hat,
[00:07:35.600 --> 00:07:43.120]   also einem Y und einem Y wird verknüpft auf der einen Seite mit diesem Operator
[00:07:43.120 --> 00:07:45.840]   und auf der anderen Seite mit diesem Operator, ja.
[00:07:45.840 --> 00:07:51.920]   Da müssen wir jetzt festlegen, ob eben das Y erst mit diesem Operator verknüpft werden soll
[00:07:51.920 --> 00:07:56.640]   oder ob es erst mit diesem Operator verknüpft werden soll, ja.
[00:07:56.640 --> 00:08:02.480]   Wir können also erst mit dem einen oder mit dem anderen das verknüpfen, ja.
[00:08:02.480 --> 00:08:08.640]   Und da entscheidet jetzt die Rangordnung der Operatoren, wer zuerst dran kommt, ja.
[00:08:08.640 --> 00:08:12.640]   Also, die Rangordnung ist festgelegt für diese verschiedenen Operatoren
[00:08:12.640 --> 00:08:20.240]   und der Operator, der die höhere Rangordnung hat, der wird als Erster rangenommen.
[00:08:20.240 --> 00:08:27.600]   Das heißt, der hat als Erster eine Chance diesen Operant Y zu verarbeiten, ja.
[00:08:27.600 --> 00:08:29.680]   Das haben Sie also auch schon mal gesehen, ja.
[00:08:29.680 --> 00:08:35.280]   Also, wie normalerweise hat ihr die Multiplikation eine höhere Rangordnung als die Addition, ja.
[00:08:35.280 --> 00:08:39.600]   Und daher, wenn wir das machen, wird also dieser Ausdruck zuerst ausgewertet
[00:08:39.600 --> 00:08:43.760]   und dann erst im letzten Schritt wird dann die Addition ausgeführt, ja.
[00:08:43.760 --> 00:08:51.040]   Das ist also, das müssen Sie sich immer genau gucken, was für Operanten haben wir,
[00:08:51.040 --> 00:08:55.440]   was für Operatoren haben wir, was ist die Rangordnung der Operatoren
[00:08:55.440 --> 00:08:57.920]   und dann können Sie dementsprechend da durchgehen, ja.
[00:08:57.920 --> 00:08:59.040]   Also, hier haben wir das.
[00:08:59.040 --> 00:09:00.640]   Sechs ist ein Literal, ja.
[00:09:00.640 --> 00:09:04.320]   Wir fangen immer von links an, wenn wir uns sowas angucken wollen, ja.
[00:09:04.320 --> 00:09:08.160]   Sechs ist ein Literal, danach kommt ein Plus, danach kommt noch ein Literal
[00:09:08.160 --> 00:09:11.680]   und danach kommt eben ein Operator, einer als höheren Rang ist,
[00:09:11.680 --> 00:09:13.120]   eines höheren Rang ist als die Plus.
[00:09:13.120 --> 00:09:17.840]   Daher wird der zuerst genommen, die Division wird durchgeführt
[00:09:17.840 --> 00:09:22.000]   und dann sieht man, da kommt ja noch ein Operator eines höheren Ranges,
[00:09:22.000 --> 00:09:26.560]   nämlich das Multiplikationssymbol, also wird das durchgeführt, ja.
[00:09:26.560 --> 00:09:31.280]   Und dann, nachdem das durchgeführt wurde, kann am Ende die Addition gemacht werden, ja.
[00:09:31.280 --> 00:09:36.880]   Also, ein Operant wird vom Operator mit höheren Rang zuerst verwendet,
[00:09:36.880 --> 00:09:42.720]   haben zwei Operatoren den selben Rang, entscheidet die Assoziativität
[00:09:42.720 --> 00:09:49.840]   und wenn zwei Operatoren den selben Rang und die selbe Assoziativität haben, ja,
[00:09:49.840 --> 00:09:54.480]   dann werden die Ausdrücke von links nach rechts ausgewertet.
[00:09:54.480 --> 00:09:57.840]   Und wenn Ihnen das nicht gefällt, dann setzen Sie Klammern, ja.
[00:09:57.840 --> 00:09:59.520]   Dafür sind Klammern da, ja.
[00:09:59.520 --> 00:10:02.480]   Denen können wir dann eben das ändern, ja.
[00:10:02.480 --> 00:10:07.760]   Und das entscheidet, also eben 1+4*4 ergibt 16, ja.
[00:10:07.760 --> 00:10:11.760]   Und da hilft also, das ist eine fürchterliche Schreibweise,
[00:10:11.760 --> 00:10:17.120]   wenn Sie so was schreiben, 1+4 zwischen Raum, Multiplikationssymbol, 4-2,
[00:10:17.120 --> 00:10:22.720]   wird trotzdem zuerst das ausgeführt, die Leerzeichen spielen alle keine Rolle, ja.
[00:10:22.720 --> 00:10:28.320]   Das ist schlimm, wenn wir so was legen Sie sich oder die nächste Leserin bös rein, ja,
[00:10:28.320 --> 00:10:30.480]   ist also nicht gut, ja.
[00:10:30.480 --> 00:10:33.280]   Also wenn Sie so was haben hier, ja, jetzt mit Klammern, ja,
[00:10:33.280 --> 00:10:37.760]   dann wird eben erst, die erste Ausdruck wird ausgewertet, jetzt kommt das Plus,
[00:10:37.760 --> 00:10:42.320]   es sieht danach kommt eine Klammer, das kommt dann auf jeden Fall zuerst, als erstes ran.
[00:10:42.320 --> 00:10:48.000]   Natürlich wird dann erst mal dieser Ausdruck ausgewertet, weil da ist der Operator, dann dieser,
[00:10:48.000 --> 00:10:54.080]   dann wird das Plus gemacht, dann sieht man, dass dieser Operator einen höheren Rang hat, als das Plus,
[00:10:54.080 --> 00:10:58.960]   also wird hier die Multiplikation ausgeführt und dann erst zum Schluss die Edition.
[00:10:58.960 --> 00:11:02.480]   Also es ist ganz, es haben Sie schon x-mal gesehen und so weiter.
[00:11:02.480 --> 00:11:08.480]   Und das ist nur heute Morgen, damit Sie einen leichten Einstieg haben und nicht zu sehr geschockt sind, ja.
[00:11:08.480 --> 00:11:15.440]   Also, ja, so, okay, können Sie sich jetzt durch den Kopf gehen lassen, was bei diesen Ausdrücken alles rauskommt.
[00:11:15.440 --> 00:11:19.360]   Denken Sie mal eine Sekunde nach, ein paar sind vielleicht ein bisschen interessanter,
[00:11:19.360 --> 00:11:25.200]   oder die hier unten, ja, da oben 9 durch 5, das ist vielleicht zu einfach, ja.
[00:11:25.200 --> 00:11:26.800]   Was ergibt das, ja.
[00:11:26.800 --> 00:11:30.000]   Ja, gucken wir uns das an, 9 durch 5 klar, 1, ja.
[00:11:30.000 --> 00:11:34.160]   695, Rest 20 ist 15, ja.
[00:11:34.160 --> 00:11:41.280]   Wenn ich hier das habe, 6 plus 18, Rest, klar mal auf, 17 minus 12, na ja, wird das erst ausgerechnet, ja.
[00:11:41.280 --> 00:11:44.960]   Dann der Rest davon ist 3 plus 6 ergibt 9, ja.
[00:11:44.960 --> 00:11:46.960]   Also keine große Überraschung.
[00:11:46.960 --> 00:11:52.400]   So, jetzt gibt es aber nicht nur Ins, sondern auch die Doubles, die Reellenzahlen, ja.
[00:11:52.400 --> 00:12:01.200]   Und die können Sie so schreiben, ja, eben mit einer Zahl, mit einem Punkt oder eben auch in diesem Format, ja.
[00:12:01.200 --> 00:12:07.920]   Das Interessante ist, dass wenn ein Punkt da ist, dann ist das eine reelle Zahl, Punkt, ja.
[00:12:07.920 --> 00:12:17.360]   Also 42.0 könnte man auch als Integer darstellen, ja, könnte man, aber das ist, wenn der Punkt da ist, eine reelle Zahl.
[00:12:17.360 --> 00:12:28.480]   Und das ist wichtig, weil, wenn wir später sehen, wie Operatausdrücke, Werte oder Variablen unterschiedlichen Types kombinieren,
[00:12:28.480 --> 00:12:34.320]   dann müssen wir uns überlegen, ist das jetzt eine Int oder ist das eine Double oder noch etwas ganz, ganz anders, ja.
[00:12:34.320 --> 00:12:44.080]   So, und natürlich sind diese Ihnen bekannten Operatoren, wie für Additionen und Subtaktionen und so weiter, auch für die Doubles definiert, ja.
[00:12:44.080 --> 00:12:57.120]   Und jetzt eben, wenn wir das, die Division machen, dann berechnet die das genaue Resultat, genau so weit, so genau, wie wir das halt hier in diesem, auf dem Computer darstellen können.
[00:12:57.120 --> 00:13:02.400]   Also 15.0 dividiert durch 2.0 ergibt eben 7.5.
[00:13:02.400 --> 00:13:06.320]   Und die Rangordnung ist in unserer Welt im Allgemeinen dieselbe, ja.
[00:13:06.320 --> 00:13:15.280]   Erst die Klammern und dann eben halt Multiplikationen, Division und Rest, bevor wir Additionen und Subtaktionen rangehen, ja.
[00:13:15.280 --> 00:13:18.880]   So, also mit reellen Zahlen sieht das genauso aus wie vorher, ja.
[00:13:18.880 --> 00:13:26.720]   Wir gehen da durch, wir gucken, aha, hier hoher Rang, höherer Rang als das, also und eke von links nach rechts, wird also ausgeführt, haben wir hier einen Plus,
[00:13:26.720 --> 00:13:33.680]   jetzt haben wir hier danach einen Operator eines höheren Ranges, wird ausgeführt, wird ausgeführt und da sind wir fertig.
[00:13:33.680 --> 00:13:44.320]   So, also, damit haben wir jetzt Int und Doubles behandelt, also die Welt, wenn wir eben denselben Operator haben, die haben wir jetzt erledigt.
[00:13:44.320 --> 00:13:50.240]   Aber jetzt wollen Sie auch wissen, was passiert, wenn wir unterschiedliche Typen haben.
[00:13:50.240 --> 00:13:56.080]   Und eben, wir nehmen immer mal an, dass das Ergebnis, das wir haben bekommen, dargestellt werden kann.
[00:13:56.080 --> 00:14:01.120]   Dass das also in dem endlichen Wertbereich, den jeder Typ unterstützt, dargestellt werden kann.
[00:14:01.120 --> 00:14:08.000]   Das Probleme, die sich aus der Endlichkeit ergeben, die werden wir erst später im Laufe des Semesters uns angucken, ja.
[00:14:08.000 --> 00:14:14.560]   So, aber jetzt hatten Sie auch eben die Frage aufgebracht, was passiert, wenn wir jetzt unterschiedliche Typen haben.
[00:14:14.560 --> 00:14:23.440]   Also wenn wir Operanten oder Literals, Art eben kombinieren und die Typen sind unterschiedlich.
[00:14:23.440 --> 00:14:34.320]   Und da gibt es eben die erste Regel und die erste Regel ist, dass wenn wir Int oder Long mit einem Double kombinieren, ja,
[00:14:34.320 --> 00:14:36.880]   dann ist das Ergebnis Double, ja.
[00:14:36.880 --> 00:14:41.040]   Das ist einfach die Regel, die man erstellt hat.
[00:14:41.040 --> 00:14:49.040]   Aus dem Gedanken heraus, dass die Doubles den größeren Zahlenbereich abdecken und man daher das Ergebnis als Double haben möchte, ja.
[00:14:49.040 --> 00:14:57.680]   Also 4.2 mal 3 ergibt eben 12.6 oder 4.5 mal 2 ergibt 9.0, ja, 9.0.
[00:14:57.680 --> 00:15:05.920]   2 ist zwar eine Integer, die wird eben verwendet, die wird umgewandelt in eine Double und dann wird das Ergebnis berechnet.
[00:15:05.920 --> 00:15:09.440]   Und das Ergebnis ist auch wieder eine Double, ja.
[00:15:09.440 --> 00:15:14.960]   Obwohl sich der Wert als Integer darstellen ließe, ist das eine Double, ja.
[00:15:14.960 --> 00:15:24.400]   Also diese Umwandlung oder Conversion von einem Typ zum anderen, die funktioniert automatisch, implizit, ja.
[00:15:24.400 --> 00:15:31.520]   Also jeder Operant wird angeguckt, der Operator wird angeguckt, der andere Operant wird angeguckt.
[00:15:31.520 --> 00:15:36.560]   Und wenn jetzt einer von den Operanten eine Int sein sollte und der andere ist Double,
[00:15:36.560 --> 00:15:40.000]   dann wird der Int operant einfach konvertiert, ja.
[00:15:40.000 --> 00:15:43.840]   Das wird passiert automatisch, da können wir nichts mitmachen, ja.
[00:15:43.840 --> 00:15:50.720]   Aber zur selben Zeit, die Regeln für Rangordnung und Assoziativität gelten weiterhin, ja.
[00:15:50.720 --> 00:15:58.080]   Also hier habe ich 7 dividiert durch 3 mal 1.2 plus 3 dividiert durch 2.
[00:15:58.080 --> 00:16:04.080]   So, gucken Sie, überlegen Sie mal kurz im Kopf, was das Ergebnis denn vielleicht sein sollte, ja, das ist nicht so schwer, ja.
[00:16:04.080 --> 00:16:08.320]   Welcher Reihenfolge wird das abgearbeitet?
[00:16:08.320 --> 00:16:11.760]   Also wir fangen an von links nach rechts, ja.
[00:16:11.760 --> 00:16:21.200]   7 dividiert durch 3 ist, beide Operanten sind Integer, es gelten die Regeln der Integer-Division, also ist das Ergebnis 2, ja.
[00:16:21.200 --> 00:16:27.360]   Multipliziert mit 1.2, produziert eine neue Reellezahl 2.4.
[00:16:27.360 --> 00:16:31.040]   Jetzt kommt ein Plus, danach kommt 3 dividiert durch 2.
[00:16:31.040 --> 00:16:37.520]   Die Division hat einen höheren Rang, also wird die Division von 3 durch 2 durchgeführt.
[00:16:37.520 --> 00:16:44.160]   Beide Operanten sind zuvergauerweise Integers, 3 dividiert durch 2 als Int ist 1, ja.
[00:16:44.160 --> 00:16:49.440]   Und daher ergibt das Ergebnis hier 2.4 plus 1 3.4, ja.
[00:16:49.440 --> 00:16:54.000]   Also deswegen ist wichtig, dass Sie immer genau wissen, was für ein Typ was ist da los, ja.
[00:16:54.000 --> 00:16:56.400]   Also das können Sie hier nochmal sehen, ja.
[00:16:56.400 --> 00:17:01.520]   Entscheidend ist immer auch in so einem Ausdruck hier, ja, von links nach rechts, ja.
[00:17:01.520 --> 00:17:07.440]   10 dividiert durch 3 ist 3, danach erst wird die Multiplication gemacht, dann wird das eine Reellezahl.
[00:17:07.440 --> 00:17:13.760]   Hier hinten 6 durch 4 ist immer noch 2 Integer-Operanten und daher ist das das richtige Ergebnis, ja.
[00:17:13.760 --> 00:17:22.560]   So, ich habe ein paar Beispiele so gegeben, dass Sie die am Kopf selber durchrechnen können, wenn Sie wollen, ja.
[00:17:22.560 --> 00:17:25.200]   Um zu sehen, was das ist.
[00:17:25.200 --> 00:17:33.040]   Was ergibt hier dieser hier, der ist vielleicht noch interessant, 9 dividiert durch 2 dividiert durch 3 plus 7.
[00:17:33.040 --> 00:17:35.040]   Was ergibt das?
[00:17:35.040 --> 00:17:41.040]   Was ergibt 2 dividiert durch 3?
[00:17:41.040 --> 00:17:43.840]   Integer, 0, genau, ja.
[00:17:43.840 --> 00:17:46.240]   Und was ergibt dann 9 dividiert durch 0?
[00:17:46.240 --> 00:17:51.200]   Genau, ein Fehler, ein Laufzeitfehler, ja.
[00:17:51.200 --> 00:17:55.200]   Das bislang mag das nicht und es gibt ein Laufzeitfehler, ja.
[00:17:55.200 --> 00:18:02.400]   Also das ist halt, deswegen, wie gesagt, wenn das Reellezahlen gewesen wären, dann wäre das anders, ja.
[00:18:02.400 --> 00:18:09.120]   So, also, das hatte ich gesagt, diese Konvertierung, die funktioniert implizit, ja.
[00:18:09.120 --> 00:18:16.160]   Also implizit, eben der Operant, ein Operant ist double, der andere nicht, also wird, der andere ist Intel, wird konvertiert.
[00:18:16.160 --> 00:18:21.920]   Aber es gibt auch die Möglichkeit, dass Sie eine Konvertierung oder Umwandlung erzwingen.
[00:18:21.920 --> 00:18:27.520]   Und das heißt, das Programm enthält eine Anweisung, dass eine Konversion stattfinden soll.
[00:18:27.520 --> 00:18:33.680]   Und sowas nennt man einen TypeCaster, das ist also eine Umwandlung von einem Typ in einem anderen, ja.
[00:18:33.680 --> 00:18:43.680]   Und das könnten Sie mal wegen machen, weil Sie haben da zwei Int-Werte und Sie wollen eigentlich das Ergebnis als Reellezahl haben, ja.
[00:18:43.680 --> 00:18:44.880]   Dann würden Sie konvertieren.
[00:18:44.880 --> 00:18:50.240]   Oder Sie haben einen Double-Wert und Sie wollen den doch in einen Int-Wert umwandeln, ja.
[00:18:50.240 --> 00:18:54.320]   Und in so einem Fall konvertieren Sie den und das passiert durch Abschneiden, ja.
[00:18:54.320 --> 00:18:56.880]   Nicht Rundung, der wird einfach trankiert.
[00:18:56.880 --> 00:19:04.880]   Der Reelletal, der Teil kleiner als eins wird einfach auf den Tisch fallen, oder unter Tisch fallen gelassen und ist einfach weg, ja.
[00:19:04.880 --> 00:19:06.880]   So, jetzt muss man einfach, ja.
[00:19:06.880 --> 00:19:17.040]   So, jetzt also, wie drücke ich so eine erzwungene Typ-Umwandlung aus, indem ich den gewünschten Typ in Klammern vor den Ausdrucks setze, ja.
[00:19:17.040 --> 00:19:24.480]   Also, zum Beispiel, wenn ich diese 19 in eine Double-Umwandlung wollte, dann würde ich hier schreiben, Klammer auf, Double 19.
[00:19:24.480 --> 00:19:29.520]   Das hat zur Folge, dass das jetzt in 19,0 umgewandelt wird.
[00:19:29.520 --> 00:19:34.880]   Und jetzt gilt wieder, die Regel ist ein operant Double, wird der andere konvertiert.
[00:19:34.880 --> 00:19:40.800]   Also hätte ich dann hier 19.0 durch 5 und das ergäbe dann 3,8, ja.
[00:19:40.800 --> 00:19:46.240]   Und wenn ich jetzt dieses Ergebnis, das ich hier habe, in einer Int-Umwandlung zurückwandeln will,
[00:19:46.240 --> 00:19:51.680]   dann würde ich hier den Int-Operator, die Int-Type-Konversation anwenden, ja.
[00:19:51.680 --> 00:19:59.040]   Und er würde halt diese 3,8 nehmen und den Teil wegschneiden und in der Tat hätten wir dann hier die drei, ja.
[00:19:59.040 --> 00:20:02.560]   So, also, das so drücke ich das aus, ja.
[00:20:02.560 --> 00:20:08.640]   Und das heißt, Sie als Programmiererin oder Programmierer übernehmen die Verantwortung, dass das Sinn macht, ja.
[00:20:08.640 --> 00:20:13.120]   Also, dass hier zum Beispiel das Ergebnis als Int dargestellt werden kann.
[00:20:13.120 --> 00:20:17.120]   Wenn das nicht dargestellt werden kann, ja, der Computer macht das, was Sie sagen, ja.
[00:20:17.120 --> 00:20:20.320]   Dann haben Sie das Problem nicht der Computer, ja.
[00:20:20.320 --> 00:20:24.640]   Und diese Konvertierung ist auch ein Operator, ja.
[00:20:24.640 --> 00:20:28.400]   Das ist der allgemein ausgesprochen, der Cast-Operator.
[00:20:28.400 --> 00:20:32.560]   Und der hat einen höheren Rang als arithmetische Operationen, ja.
[00:20:32.560 --> 00:20:40.720]   Deswegen haben wir hier ja auch gesehen, dass sich das eben nicht, wenn wir das erst 19.0 durch 5 gemacht hätten, ja.
[00:20:40.720 --> 00:20:42.640]   Das wäre ja 3 gewesen, ja.
[00:20:42.640 --> 00:20:44.240]   Und wir dann erst konvertiert haben.
[00:20:44.240 --> 00:20:49.920]   Nein, dieser Operator bezieht sich auf den Operanten, der direkt neben ihm steht.
[00:20:49.920 --> 00:20:52.160]   Und zwar direkt rechts neben ihm steht.
[00:20:52.160 --> 00:20:55.600]   Und dieser Operator ist also rechtsassoziativ.
[00:20:55.600 --> 00:20:59.760]   Der wandelt nur den Operanten direkt rechts neben sich um.
[00:20:59.760 --> 00:21:01.680]   Und der Rest ist davon nicht betroffen.
[00:21:01.680 --> 00:21:08.560]   Dann gelten natürlich die anderen Regeln, wenn ich einen einmal umgewandelt habe, könnte das implizite Umwandlung nach sich zielen, ja.
[00:21:08.560 --> 00:21:13.200]   Aber das hängt davon ab, was für eine Berechnung ich machen will.
[00:21:13.200 --> 00:21:19.760]   Und diese Cast-Operatoren sind für alle Typen verfügbar.
[00:21:19.760 --> 00:21:26.880]   Also nicht nur für ihn Double und Long, auch alle anderen, die wir später mal kennenlernen werden, wo es Sinn macht, sind die verfügbar, ja.
[00:21:26.880 --> 00:21:32.640]   Also, weil der so eine hohe Präzedenz hat, ja, hat also manchmal gibt es da Überraschungen, ja.
[00:21:32.640 --> 00:21:40.960]   Ich habe hier Double, die 1 konvertiere ich zu Double und addiere 1 durch 2.
[00:21:40.960 --> 00:21:42.960]   Und das Ergebnis ist 1,0.
[00:21:42.960 --> 00:21:47.680]   Warum? Das hier wird davon dem Cast-Operator nicht betroffen.
[00:21:47.680 --> 00:21:50.160]   1 durch 2 als Integer ergibt 0.
[00:21:50.160 --> 00:21:52.480]   Ich habe hier die 1,0 plus 0.
[00:21:52.480 --> 00:21:56.640]   Die 0 wird in 0.0 umgewandelt, aber ergibt immer nur noch 1,0, ja.
[00:21:56.640 --> 00:22:00.640]   Ohin gegen 1 plus Double, 1 dividiert durch 2.
[00:22:00.640 --> 00:22:04.000]   Das hat zur Folge, dass das 1,0 ist.
[00:22:04.000 --> 00:22:06.000]   Jetzt wird das durch 2 dividiert.
[00:22:06.000 --> 00:22:13.760]   Die 2 wird in 2.0 umgewandelt, ergibt also als Ergebnis 0,5.
[00:22:13.760 --> 00:22:17.200]   Und das mit 1 dazu ergibt eben die 1,5.
[00:22:17.200 --> 00:22:24.160]   Also, es spielt eine große Rolle, was sie konvertieren und wo sie konvertieren.
[00:22:24.160 --> 00:22:32.480]   Und wenn eben ist nicht gefällt, dass dieser Cast-Operator nur den direkt daneben stehenden Operanten betrifft,
[00:22:32.480 --> 00:22:34.880]   dann können sie natürlich Klammern setzen, ja.
[00:22:34.880 --> 00:22:38.080]   Die Klammer hat wieder eine höhere Rahmenordnung.
[00:22:38.080 --> 00:22:39.600]   Die wird zuerst ausgewertet.
[00:22:39.600 --> 00:22:45.520]   Also, hier in diesem Beispiel hätten wir eben als 1, 2 plus 1 plus 1 ergibt 4.
[00:22:45.520 --> 00:22:47.760]   Das würde konvertiert zu 4,0.
[00:22:47.760 --> 00:22:54.000]   Dann durch 3 dividiert ergibt die gewünschte, oder Ergebnis 1,3, ja.
[00:22:54.000 --> 00:22:58.640]   Also, das sind die Regeln hier für Java.
[00:22:58.640 --> 00:23:01.040]   Das ist die Java-Sicht der Welt.
[00:23:01.040 --> 00:23:04.560]   Nicht alle Programmiersprache machen das so.
[00:23:04.560 --> 00:23:07.600]   Gibt Programmiersprachen, die haben andere Vorstellungen.
[00:23:07.600 --> 00:23:09.600]   Das kann manchmal überraschend sein.
[00:23:09.600 --> 00:23:15.840]   Deswegen ist es wichtig, dass sie überlegen, was ist die Rahmenordnung, was sind die Typen.
[00:23:15.840 --> 00:23:19.200]   Andere Programmiersprachen machen das anders.
[00:23:19.200 --> 00:23:21.600]   Vielleicht haben sie das schon mal selbst erfahren.
[00:23:21.600 --> 00:23:24.640]   Microsoft Excel hat da andere Vorstellungen.
[00:23:24.640 --> 00:23:30.400]   Wenn Sie hier minus 2 hoch 2, das ist hier hoch, also 2 hoch 2 sehen, ja.
[00:23:30.400 --> 00:23:34.400]   Dann würde eine Mathematikerin minus 4 erwarten, ja.
[00:23:34.400 --> 00:23:40.800]   Weil in der Welt würde man erst die Exponentierung machen und dann eben das minus ransehen.
[00:23:40.800 --> 00:23:44.960]   Aber wenn Sie es in Excel machen, Überraschung, ja, das ist 4.
[00:23:44.960 --> 00:23:53.520]   Warum? Weil Excel hat die Auffassung, dass das hier, dass eben das minus sich nur auf die 2 bezieht.
[00:23:53.520 --> 00:23:55.520]   Und das dann hoch 2 gerechnet wird.
[00:23:55.520 --> 00:23:57.520]   Und das ist dann natürlich 4, ja.
[00:23:57.520 --> 00:24:04.320]   Also, das ist halt etwas verwirrend, weil wenn Sie dann sowas sehen, 0 minus 2 hoch 2, ja.
[00:24:04.320 --> 00:24:06.320]   Das ergibt dann eben doch minus 4, ja.
[00:24:06.320 --> 00:24:09.680]   Also, so könnte man das dann erreichen, wenn man die minus 4 haben wollte.
[00:24:09.680 --> 00:24:14.320]   Und das ist eben ein Feature oder eine Eigenhade.
[00:24:14.320 --> 00:24:22.720]   Früher wurde das auch diskutiert, gab auf einer Microsoft-Seite eine Diskussion dieses Crocs oder dieses Design Features, ja.
[00:24:22.720 --> 00:24:26.880]   Aber dann haben Sie die Seite weggenommen, die wollen Sie halt nicht mehr den Leuten zeigen, ja.
[00:24:26.880 --> 00:24:29.360]   Also, Sie müssen das berücksichtigen, ja.
[00:24:29.360 --> 00:24:41.360]   Wenn Sie in die Dokumentation reingehen, dann sehen Sie in der Tat, dass in der Excel-Regel die Exponentierung eine tieferen Ordnung hat als die Negation, ja.
[00:24:41.360 --> 00:24:43.360]   Und deswegen das so ist, ja.
[00:24:43.360 --> 00:24:46.720]   Also, passen Sie auf und was für eine Programmiersprache Sie arbeiten.
[00:24:46.720 --> 00:24:55.120]   Hoffen Sie, dass alle Compiler-Schreiber sich geeinigt haben, was die Rangordnung und so weiter ist und damit eben alles gut ist, ja.
[00:24:55.120 --> 00:25:05.120]   So, also, jetzt haben wir die Basistypen also mal angeschaut, ja, und haben einiges da gesehen, Operationen und auch ganz einfache Variable.
[00:25:05.120 --> 00:25:08.720]   Und dann gibt es natürlich noch die Typen aus der Java Bibliothek.
[00:25:08.720 --> 00:25:13.120]   Und natürlich gibt es auch hier Typen, die wir selber machen, aber das muss noch ein bisschen warten.
[00:25:13.120 --> 00:25:25.360]   Jetzt für die Typen aus der Bibliothek haben wir gesehen, haben wir verschiedene Werte gesehen und wir haben gesehen, dass wir Operationen durch Methoden angeben können, wie dieses, wir nehmen das Objekt "Hello"
[00:25:25.360 --> 00:25:30.560]   und dann machen wir die "Tor-Upper-Case-Operationen" drauf und das setzt das dann in Großbuchstaben rum.
[00:25:30.560 --> 00:25:38.000]   Aber es gibt auch die Möglichkeit für einige Insulin, für den String, gibt es die Möglichkeit, Operationen mit Operatoren zu machen.
[00:25:38.000 --> 00:25:48.720]   Das ist so ein Kompromiss, den die Java-Entwickler gemacht haben, dass die Sprache nicht zu umständlich wird, weil das sehr praktisch ist und das ist halt manchmal etwas überraschend.
[00:25:48.720 --> 00:25:55.040]   Also, ich kann den Plus-Operator verwenden, um zwei Strings zu konkatenieren.
[00:25:55.040 --> 00:26:01.360]   Es gibt auch eine besondere Operation, die ich verwenden könnte, aber wer will das immer schreiben, darum das Plus, ja.
[00:26:01.360 --> 00:26:06.160]   Also, wenn ich hier den Plus-Operator für zwei Strings verwende, gibt es neun Strings.
[00:26:06.160 --> 00:26:12.960]   Aber wenn ich hier drei Strings habe, bekomme ich auf diese Weise einen Strings, der diese Werte hat.
[00:26:12.960 --> 00:26:20.560]   Und der zweite Punkt ist, dass jegliche Ausrügen in Java kann im Prinzip operanten, verschiedene Typen kombinieren.
[00:26:20.560 --> 00:26:31.120]   Es gibt gewisse Regeln, was sie nicht machen können, aber mit den Ins und Longs und Doubles und Strings, die wir gesehen haben, können wir die kombinieren.
[00:26:31.120 --> 00:26:37.920]   Aber eben natürlich gibt es Einschränkungen bezüglich der Operatoren, die wir da einsetzen können oder verwenden können.
[00:26:37.920 --> 00:26:43.280]   So, und jetzt gibt es eine, finde ich, sehr gute Entscheidung, die die Java-Entwickler gemacht haben.
[00:26:43.280 --> 00:26:51.840]   Die haben nämlich entschieden, dass es für jeden Wert eine Darstellung als String gibt, egal was für einen Wert, auch später, egal was für ein Typ.
[00:26:51.840 --> 00:27:00.960]   Es gibt immer eine Stringdarstellung und zwar gibt es eine Default-Darstellung, die ist also vom System voreingestellt, die gibt es einfach.
[00:27:00.960 --> 00:27:05.360]   Ob die jetzt immer sinnvoll ist, ist eine andere Frage, aber es gibt sie wenigstens.
[00:27:05.360 --> 00:27:19.280]   Denn das ist sehr praktisch, damit können wir jeden Wert, egal was wir haben, mittels Print aus oder Print line, das wäre die andere, wäre die Version, wo wir noch ein bisschen noch einen Zeilenumschub bekämen, kann man das ausgeben.
[00:27:19.280 --> 00:27:26.320]   Und das ist sehr praktisch, weil wir können auf diese Weise, wenn wir irgendwie sehen wollen, was in dem Programm los ist, uns die Werte angucken.
[00:27:26.320 --> 00:27:31.280]   Wenn uns diese Default-Darstellung nicht gefällt, werden wir später sehen, wie wir die ändern können.
[00:27:31.280 --> 00:27:33.920]   Die ist nicht fix, die ist aber am Anfang immer da.
[00:27:33.920 --> 00:27:40.960]   Und in den meisten Fällen für die Typen, mit denen wir jetzt arbeiten, ist die Default-Darstellung das, was wir erwarten.
[00:27:40.960 --> 00:27:53.840]   Wenn ich also einen Int-Literal, also Int-Konstante habe, ist die Default-Darstellung eben halt diese Konstante, wenn ich so eine Int-Variable habe, dann ist die Default-Darstellung der jetzige aktuelle Wert.
[00:27:53.840 --> 00:27:55.360]   Das verdabelt es genauso.
[00:27:55.360 --> 00:28:01.920]   Und natürlich für Strings auch, der ist die Default-Darstellung von "Hello" ist eben dieser String "Hello".
[00:28:01.920 --> 00:28:11.760]   So, und jetzt eben habe ich gesagt, wir können diesen Plus-Operator verwenden, um einen String mit einem anderen Wert zu verknüpfen.
[00:28:11.760 --> 00:28:14.560]   Und wenn der andere Wert ein String ist, ist alles Bestens.
[00:28:14.560 --> 00:28:24.240]   Und wenn nicht, wird da halt ein String umgewandelt, sodass ich dann zwei Strings habe, die dann miteinander verknüpft werden können und einen vielleicht längeren String ergeben.
[00:28:24.240 --> 00:28:38.960]   Also, wenn ich also "Hello" plus 42 habe, dann geht der hin, Strings plus Nicht-String, also in Strings konvertieren, wird in Strings konvertiert und dann wird das konkateniert.
[00:28:38.960 --> 00:28:51.120]   Oder genauso wie ich eine Variable habe, "Hello", was ist der aktuelle Wert, sagen wir 99, wird in einen Strings konvertiert, 99, "Hello" plus 99 ist eben "Hello" 99.
[00:28:51.120 --> 00:28:59.120]   Und das geht nur für den Plus-Operator, alle anderen Operatoren sind nicht erlaubt, gibt es nicht, nur für den Plus-Operator.
[00:28:59.120 --> 00:29:03.520]   Aber auch das kann da schon zum Nachdenken, kann man das sagen.
[00:29:03.520 --> 00:29:12.240]   Und wieder wird von links nach rechts gerechnet und gelesen, also 12 minus 3 plus 5 ergibt, wie Sie wahrscheinlich wissen, 14.
[00:29:12.240 --> 00:29:18.960]   So, 2 plus 3 ergibt 5 plus "Hello", ergibt daher 5 "Hello".
[00:29:18.960 --> 00:29:32.560]   "Hello" plus 2, ah, 2 in Strings konvertieren ergibt "Hello 2", "Hello 2 Strings plus 3", bitte auch in Strings konvertieren ergibt "Hello 2 3".
[00:29:32.560 --> 00:29:43.520]   So, und natürlich können wir in unseren Ausdrücken nicht nur Plus verwenden, sondern auch alle anderen Operatoren, wenn die Operanten ins oder doubles sind.
[00:29:43.520 --> 00:29:49.120]   Wenn der Operat ein Strings wäre, könnten wir nicht den Multiplikations-Operator verwenden.
[00:29:49.120 --> 00:29:53.200]   Aber wenn wir eben einen 2 in haben, können wir das machen.
[00:29:53.200 --> 00:30:02.240]   Also hier, wir fangen an, von links nach rechts, "Hello" plus, okay, halt, hier ist ja ein Operator eines höheren Ranges.
[00:30:02.240 --> 00:30:08.000]   Also machen wir den zuerst 6, also 2 mal 3 ist 6, ergibt also "Hello 6", ja.
[00:30:08.000 --> 00:30:13.360]   Also das können Sie da, ist da ein einfacher Weg das zu machen.
[00:30:13.360 --> 00:30:19.040]   Ich habe noch ein Quiz für Sie, da lasse ich einfach die Slides für Sie, können Sie sich selber angucken.
[00:30:19.040 --> 00:30:24.640]   Es ist wirklich nicht schwierig und vielleicht finden die meisten von Ihnen das auch langweilig, ich weiß es nicht.
[00:30:24.640 --> 00:30:32.560]   So, also wir können also dieses Plus verwenden, um einen String und den Wert eines Ausdrucks auszugeben.
[00:30:32.560 --> 00:30:39.040]   Und die Frage jetzt, die können Sie kurz durch den Kopf gehen lassen, warum brauchen wir jetzt hier die Klammern?
[00:30:39.040 --> 00:30:47.200]   Hier habe ich, ich möchte ausgeben den Textnote und dann die arithmetisch gemittelte Note für diese Studierende.
[00:30:47.200 --> 00:31:01.760]   Da gehe ich also hin, plus, jetzt wenn ich das keine Klammer hätte, dann würde das sofort die 4.8 in ein String konvertiert werden, aber die Klammer kommt zuerst und dann wird dieser Ausdruck hier zuerst ausgerechnet und dann ist die Sache in Ordnung, ja.
[00:31:01.760 --> 00:31:03.600]   So, dann ist das in Ordnung.
[00:31:03.600 --> 00:31:11.600]   So, damit habe ich also eben das erste gesagt, was ich über Typen und Operatoren mit Typen sagen möchte und wir machen jetzt bisschen weiter mit Variablen.
[00:31:11.600 --> 00:31:19.600]   Da haben wir ja schon eben gesehen, wie man so eine Variable am Anfang deklariert, aber wollen ein bisschen mehr uns damit diesem Thema beschäftigen.
[00:31:19.600 --> 00:31:26.640]   Und eine Variable ist eben ein Name, der es uns erlaubt, auf einen gespeicherten Wert zuzugreifen.
[00:31:26.640 --> 00:31:35.600]   Kennen Sie vielleicht auch, ja, wir haben hier in den Büros diese Telefone, die 1.000 Franken kosten und trotzdem nicht das können, was es 50 Franken telefonen kann.
[00:31:35.600 --> 00:31:41.600]   Aber die haben immerhin die Möglichkeit, Werte zu speichern.
[00:31:41.600 --> 00:31:47.600]   Ich kann da also Nummern, die ich häufig anrufe, die kann ich da im Prinzip speichern, ja.
[00:31:47.600 --> 00:31:51.600]   Und dieser Wert wird da eben gespeichert und so ist das im Computer auch.
[00:31:51.600 --> 00:32:00.600]   Da muss eben halt irgendeine Speicherzelle sein, ja, die den Wert speichern.
[00:32:00.600 --> 00:32:05.600]   Diese Wahlknöpfe werden genauso benutzt, wie wir Variable benutzen, ja, die werden irgendwann eingerichtet.
[00:32:05.600 --> 00:32:08.600]   Jetzt für diese Knöpfe funktioniert es in der Fabrik.
[00:32:08.600 --> 00:32:12.600]   Die werden irgendwann konfiguriert, also sagen, welche Nummer das ist, ja.
[00:32:12.600 --> 00:32:18.600]   Und am Ende, wenn ich einmal konfiguriert habe, kann ich diesen Knopf verwenden, um eine Schnellwahl zu machen.
[00:32:18.600 --> 00:32:20.600]   Und genauso geht es mit den Variablen im Programm.
[00:32:20.600 --> 00:32:24.600]   Wir müssen sie deklarieren, ja, und wir müssen sie dann initialisieren.
[00:32:24.600 --> 00:32:26.600]   Und wir haben gesehen, das können wir auch manchmal zusammen machen.
[00:32:26.600 --> 00:32:29.600]   Und danach können wir die Variable gebrauchen.
[00:32:29.600 --> 00:32:37.600]   Also erscheint irgendwo im Text und dann wird die eben halt der Wert verwendet, den die diese Variable in dem Moment hat, ja.
[00:32:37.600 --> 00:32:43.600]   Also die Deklaration einer Variablen, die reserviert den Speicher für die Werte, ja.
[00:32:43.600 --> 00:32:47.600]   Und in Java, das ist eine Java-Regel, es gibt andere Programmiersprachen, die machen das nicht.
[00:32:47.600 --> 00:32:52.600]   Die Variable muss deklariert sein, bevor sie verwendet werden kann, ja.
[00:32:52.600 --> 00:32:57.600]   Und alles, was ich jetzt erzähle, gilt fürs Erste in einer Methode, ja.
[00:32:57.600 --> 00:33:01.600]   Wir haben noch keine Variablen gesehen, die wir außerhalb von Methoden deklarieren.
[00:33:01.600 --> 00:33:03.600]   Alles passiert innerhalb einer Methode.
[00:33:03.600 --> 00:33:08.600]   Und ich hatte ihnen gezeigt, diese Sündtags-Eben, wir geben den Typ und den Namen an, ja.
[00:33:08.600 --> 00:33:13.600]   Und wir können dann später diese Variable einen Wert zuweisen und dann ist das okay.
[00:33:13.600 --> 00:33:18.600]   Oder wir können eben halt, also die Variable muss deklariert sein, ja.
[00:33:18.600 --> 00:33:23.600]   Und dann können wir sie, nachdem sie einmal deklariert wurde, können wir sie auch in der Zuweisung benutzen
[00:33:23.600 --> 00:33:26.600]   und können der Variable irgendeinen Wert zuweisen.
[00:33:26.600 --> 00:33:34.600]   Und so eine Zuweisung muss passiert sein, bevor so eine Variable als operant verwendet werden kann, ja.
[00:33:34.600 --> 00:33:40.600]   Wenn wir die Variable verwenden wollen und es wurde kein Wert zugeweisen, dann beschwert sich das System.
[00:33:40.600 --> 00:33:47.600]   Und darum ist diese Deklaration mit Initialisierung oder Deklaration mit Definition so praktisch,
[00:33:47.600 --> 00:33:49.600]   weil die eben halt das sofort macht.
[00:33:49.600 --> 00:33:53.600]   Wenn wir das nicht machen wollen, können wir später eine Zuweisung machen, wie da oben gezeigt.
[00:33:53.600 --> 00:33:57.600]   Und dann hat die Variable einen Wert und dann kann man damit arbeiten.
[00:33:57.600 --> 00:34:04.600]   Und wenn wir vergessen sollten, den Wert, irgendeinen Wert zuzuweisen, beschwert sich das System, ja.
[00:34:04.600 --> 00:34:11.600]   Der Compiler oder das Laufzeitssystem merkt das und sagt, diese Variable hier hat keinen Wert, ja.
[00:34:11.600 --> 00:34:14.600]   Und daher dürfen wir sie nicht verwenden.
[00:34:14.600 --> 00:34:20.600]   Und natürlich, sie dürfen Variable nicht doppelt deklarieren und auch egal, wie sie das machen,
[00:34:20.600 --> 00:34:24.600]   dürfen auch keine Doppeldeklaration mit unterschiedlichen Typen machen.
[00:34:24.600 --> 00:34:30.600]   Wenn sie einmal sagen, X ist ein Int, dann bleibt das so in einem Java-Programm, in einer Java-Methode.
[00:34:30.600 --> 00:34:33.600]   Und das können wir nicht irgendwie ändern.
[00:34:33.600 --> 00:34:40.600]   So, okay. Also, so eine Zuweisung geht dann eben hin, nimmt einen Wert.
[00:34:40.600 --> 00:34:44.600]   Der Wert wird bestimmt durch den Ausdruck auf der rechten Seite, ja.
[00:34:44.600 --> 00:34:46.600]   Der Ausdruck wird evaluiert.
[00:34:46.600 --> 00:34:51.600]   Und dann wird dieser Wert in der Variable gespeichert, ja.
[00:34:51.600 --> 00:34:56.600]   Dann wird der Variable gespeichert und danach hat das eben dann den entsprechenden Wert.
[00:34:56.600 --> 00:35:02.600]   Also, wenn ich hier die Variable X habe, der weiß ich den Wert 3 zu, dann erscheint da der Wert 3.
[00:35:02.600 --> 00:35:07.600]   Und wenn ich dann eine Doppel hätte, ja, und da würde ich dann das als Note speichern,
[00:35:07.600 --> 00:35:10.600]   dann würde eben der Speicherplatz wird geschaffen.
[00:35:10.600 --> 00:35:18.600]   Und dann wird ein Verzeichnis, dass wir wissen, wo diese Variable ist und der entsprechende Wert wird da gespeichert.
[00:35:18.600 --> 00:35:24.600]   So, jetzt, die erste Sache ist, wiederholte Zuweisungen sind erlaubt.
[00:35:24.600 --> 00:35:31.600]   Also, wir können eben hier ohne weiteres diese Variable X deklarieren,
[00:35:31.600 --> 00:35:36.600]   mit 3 Initialisieren ausgeben und dann einen neuen Wert zuweisen.
[00:35:36.600 --> 00:35:38.600]   Wenn das geht, dann wird dann entsprechend geändert.
[00:35:38.600 --> 00:35:44.600]   Dann ist dann da immer der aktuelle neueste Wert in dieser Variable gespeichert.
[00:35:44.600 --> 00:35:51.600]   Und ja, das ist so eine, das haben Sie sicher auch, oder haben Sie eventuell schon mal in einer anderen Programmiersprache gesehen, ja.
[00:35:51.600 --> 00:35:58.600]   In Java verwenden wir dieses Zeichen, das im deutschen Gleichheitszeichen heißt, ja,
[00:35:58.600 --> 00:36:02.600]   als Operator, um eine Zuweisung auszudrücken, ja.
[00:36:02.600 --> 00:36:05.600]   Korrekt, da müsste man sagen, das ist der Assignment-Operator, ja.
[00:36:05.600 --> 00:36:14.600]   Und wenn Sie das wissen, dass ein Assignment-Operator ist, dann können Sie auch Ausdrücke, wie A, wird gesetzt zu B, zu C, können Sie auch verstehen, ja.
[00:36:14.600 --> 00:36:21.600]   Müssen Sie das nur wissen, ist der Rechts-Assoziativ oder Links-Assoziativ, ja, um zu wissen, in welcher Reihenfolge das ausgeführt wird.
[00:36:21.600 --> 00:36:25.600]   Und natürlich haben wir eben eine Beschreibung dafür, ja.
[00:36:25.600 --> 00:36:28.600]   Und das, was für die Expressions hatten wir, das Sie da schon gesehen.
[00:36:28.600 --> 00:36:31.600]   Das ist also das, was wir immer da schon hatten.
[00:36:31.600 --> 00:36:35.600]   So, jetzt also ein wichtiger Punkt, ja.
[00:36:35.600 --> 00:36:38.600]   Dieses Zeichen heißt eben Zuweisung, ja.
[00:36:38.600 --> 00:36:42.600]   Und das ist keine allgebrarische Gleichung, ja.
[00:36:42.600 --> 00:36:49.600]   Das heißt eben, speichere den Wert der rechten Seite in der Variable auf der linken Seite, ja.
[00:36:49.600 --> 00:36:58.600]   Und das heißt, dass dieser Ausdruck hier, der hier auf dieser Seite steht, ja, der wird zuerst ausgewertet, ja.
[00:36:58.600 --> 00:37:07.600]   Der wird ausgewertet und dann wird der Wert in der Variable gespeichert, deren Namen hier erscheint, ja.
[00:37:07.600 --> 00:37:14.600]   Es ist wichtig, dass wir hier erst rechts, ja, und dann hier zweitens rausfinden wohin.
[00:37:14.600 --> 00:37:18.600]   Und drittens findet dann die Speicheroperation statt, ja.
[00:37:18.600 --> 00:37:27.600]   Er findet die, lassen Sie mich das, ist nicht ganz korrekt, lassen Sie mir das lieber, das machen wir lieber zusammen, machen wir hier zusammen, ja.
[00:37:27.600 --> 00:37:30.600]   Also, er findet erst raus, wo geht's hin, ja.
[00:37:30.600 --> 00:37:38.600]   Und nachdem wir das gemacht haben, dann haben wir evaluiert und dann speichern wir den Wert in der Variable.
[00:37:38.600 --> 00:37:47.600]   Und das heißt natürlich, dass sich auch denselbe Variable sowohl auf der rechten als auch auf der linken Seite haben kann, ja.
[00:37:47.600 --> 00:37:56.600]   Ich habe hier die Variable x und in der nächsten Zeile habe ich eine Zuweisung, in der ich die Variable x den Wert nehme, um 2 erhöhe.
[00:37:56.600 --> 00:38:01.600]   Und dann diesen neuen Wert hier in der Variable x ablege, ja.
[00:38:01.600 --> 00:38:07.600]   Und wenn ich am Anfang also x den Wert 3 habe, was passiert dann, ja, dann x plus 2 ist 5.
[00:38:07.600 --> 00:38:12.600]   Und daher wird er den neuen Wert 5 in dieser Variable gespeichert, ja.
[00:38:12.600 --> 00:38:23.600]   Und weil das so eine wirklich wichtige Sache ist, habe ich dafür jetzt einen Klicker und den könnten Sie, könnten Sie Ihre Computer oder Smartphones rausnehmen.
[00:38:23.600 --> 00:38:28.600]   Und ich hoffe, dass ich den jetzt zum Laufen bekomme.
[00:38:28.600 --> 00:38:36.600]   So, der sollte jetzt hier für Sie sichtbar sein.
[00:38:36.600 --> 00:38:42.600]   Also, hier ist ein Programmsegment, ja, ein einfaches Programmsegment mit 4 Statements.
[00:38:42.600 --> 00:38:50.600]   Und Sie sollten entscheiden oder mir in dem Klicker angeben, welchen Wert denn diese Variable x hat,
[00:38:50.600 --> 00:38:53.600]   nachdem alle Statements ausgeführt wurden.
[00:38:53.600 --> 00:38:58.600]   Also, an diesem Punkt hier unten, welchen Wert hat die Variable x?
[00:38:58.600 --> 00:39:02.600]   So, ist der gestartet? Sehen Sie es?
[00:39:02.600 --> 00:39:07.600]   Okay. Halt, halt, halt, halt, halt.
[00:39:07.600 --> 00:39:09.600]   Aber das ist nicht der Richtige.
[00:39:09.600 --> 00:39:11.600]   Das ist nicht der Richtige.
[00:39:11.600 --> 00:39:18.600]   Also, wissen Sie, das funktioniert heute für mich nicht.
[00:39:18.600 --> 00:39:20.600]   Warum weiß ich auch nicht?
[00:39:20.600 --> 00:39:22.600]   Ich kann das nicht starten.
[00:39:22.600 --> 00:39:30.600]   Er weigert sich einfach, ich kann es nochmal versuchen, aber er weigert sich einfach, das zu starten.
[00:39:30.600 --> 00:39:32.600]   Ich weiß nicht, warum.
[00:39:32.600 --> 00:39:36.600]   Okay, dann können Sie ja, tut mir leid, für die im Oberfloraum, die können jetzt nicht abstimmen.
[00:39:36.600 --> 00:39:39.600]   Okay, was für Werte bieten Sie sich denn an?
[00:39:39.600 --> 00:39:41.600]   Wer meint, das hat den Wert 0?
[00:39:41.600 --> 00:39:43.600]   Hat jemand dafür eine Meinung?
[00:39:43.600 --> 00:39:46.600]   Den Wert 1.
[00:39:46.600 --> 00:39:49.600]   Okay, den Wert 2.
[00:39:49.600 --> 00:39:52.600]   Ja, okay. Wert 3.
[00:39:52.600 --> 00:39:55.600]   Okay, also 1 ist die richtige Antwort.
[00:39:55.600 --> 00:39:57.600]   Und warum ist das der Fall?
[00:39:57.600 --> 00:39:59.600]   Gucken Sie sich das an.
[00:39:59.600 --> 00:40:03.600]   Was passiert hier?
[00:40:03.600 --> 00:40:10.600]   Nach jedem Statement, nach dem ersten Statement hat x den Wert 0 und y, wissen wir nicht.
[00:40:10.600 --> 00:40:14.600]   Danach hat y den Wert 1 bekommen, x unverändert.
[00:40:14.600 --> 00:40:23.600]   Danach ist eben x, auf den wir gesetzt worden, den y hatte und danach wurde y geändert.
[00:40:23.600 --> 00:40:27.600]   Also deswegen ist die richtige Antwort für x 1.
[00:40:27.600 --> 00:40:32.600]   Also beachten Sie, dieser Operator hat nichts mit Gleichheit zu tun.
[00:40:32.600 --> 00:40:44.600]   Er sagt einfach nur, dass das der, die Zuweisung ist, die ausgeführt werden soll und dass da ein neuer Wert gesetzt werden soll.
[00:40:44.600 --> 00:40:49.600]   Also damit haben wir zumindest einen ersten Blick auf Variable bekommen.
[00:40:49.600 --> 00:40:54.600]   Und jetzt in der nächsten Nach der Pause möchte ich dann weitergehen.
[00:40:54.600 --> 00:41:00.600]   Und da wollen wir gucken, ob wir nicht über die einfachen Programmsegmente, die wir bisher kennengelernt haben,
[00:41:00.600 --> 00:41:02.600]   ob wir über die nicht Aussagen machen können.
[00:41:02.600 --> 00:41:09.600]   Und da werde ich zwei verschiedene Arten des Aussagenmachens vorstellen, nämlich, dass wir vorwärts und rückwärts schließen.
[00:41:09.600 --> 00:41:14.600]   Und das führt dann dazu, dass wir festhalten können, was für Bedingungen erfüllt sein müssen,
[00:41:14.600 --> 00:41:19.600]   bevor wir eine Anweisung oder eine Folge von Anweisungen ausführen
[00:41:19.600 --> 00:41:23.600]   und was für eine Bedingung vielleicht erfüllt ist, nachdem wir die ausgeführt haben.
[00:41:23.600 --> 00:41:33.600]   Und das wird uns dann erlauben, eben Aussagen über ein Programmsegment zu machen und zu sagen, dieses Programmsegment hat diesen Effekt auf diese Variable.
[00:41:33.600 --> 00:41:42.600]   Und nachdem wir das gemacht haben, gucken wir uns mal an, wie wir unser Repertoire an Anweisungen erweitern und dann eben mit Verzweigungen arbeiten.
[00:41:42.600 --> 00:41:48.600]   Aber jetzt haben Sie erstmal die Pause und jetzt machen wir Pause bis 9 Uhr, 10 Uhr.
[00:41:48.600 --> 00:41:59.600]   So, wir wollen dann jetzt weitermachen und uns mit dem Thema Aussagen über Programme beschäftigen.
[00:41:59.600 --> 00:42:09.600]   Also, wenn wir sagen Programme, dann meinen wir natürlich erstmal einfache Programmsegmente wie einfache Teile von Methoden.
[00:42:09.600 --> 00:42:15.600]   Also, Sie erinnern sich, wir hatten diese einfache ...
[00:42:15.600 --> 00:42:18.600]   Darf ich?
[00:42:18.600 --> 00:42:23.600]   Wir hatten diese einfache Methode, die für einen Quader die Oberfläche berechnete.
[00:42:23.600 --> 00:42:28.600]   Und jetzt wollen Sie eine Aussage über diese Berechnung machen.
[00:42:28.600 --> 00:42:30.600]   Ist der Witz gut?
[00:42:30.600 --> 00:42:34.600]   Okay, ja doch, ich meine schon sehr.
[00:42:34.600 --> 00:42:40.600]   Die Aussage, die Berechnung, muss natürlich diese variable Fläche involvieren.
[00:42:40.600 --> 00:42:46.600]   Das ist diese Variable, die wir benutzen, um die Fläche da festzuhalten.
[00:42:46.600 --> 00:42:54.600]   Und wenn Sie es jetzt angucken, dann ist das so, dass wir jetzt an sich gerne in der Lage wären, Aussagen zu machen.
[00:42:54.600 --> 00:43:01.600]   Aber diese Aussage über die Fläche muss an einen Ort oder eine Stelle im Programm gekoppelt sein.
[00:43:01.600 --> 00:43:07.600]   Es macht keinen Sinn, hier über die Fläche zu reden, weil die Variable existiert noch gar nicht.
[00:43:07.600 --> 00:43:10.600]   Und die Variable hat noch gar keinen Wert zugewiesen bekommen.
[00:43:10.600 --> 00:43:15.600]   Das heißt, an dem Punkt macht es überhaupt keinen Sinn, eine Aussage machen zu wollen.
[00:43:15.600 --> 00:43:18.600]   Oder eine Aussage hier auch noch nicht möglich.
[00:43:18.600 --> 00:43:20.600]   Oder hier auch noch nicht.
[00:43:20.600 --> 00:43:21.600]   Oder hier nicht.
[00:43:21.600 --> 00:43:28.600]   Erst jetzt, nachdem die Berechnung stattgefunden hat, können wir eine Aussage über diese Variable machen.
[00:43:28.600 --> 00:43:34.600]   Und das heißt also, wenn wir Aussagen machen wollen, dann müssen wir die eben an einen Ort koppeln.
[00:43:34.600 --> 00:43:40.600]   Und wir brauchen einen Weg zu sagen, wo diese Aussage gilt.
[00:43:40.600 --> 00:43:51.600]   Und wir machen am Anfang ganz einfach, wir machen, unterhalten uns nur oder gucken uns nur Aussagen an, die innerhalb einer Methode gelten werden.
[00:43:51.600 --> 00:43:56.600]   Und wir gucken uns auch nur Aussagen für Programmsegmente an, die aus Zuweisungen bestehen.
[00:43:56.600 --> 00:43:57.600]   Nichts anderes.
[00:43:57.600 --> 00:44:02.600]   Also wir haben nur Zuweisungen, so wie hier oder Deklarationen.
[00:44:02.600 --> 00:44:06.600]   Und darüber wollen wir irgendwelche Aussagen machen.
[00:44:06.600 --> 00:44:08.600]   Was ist eine Aussage?
[00:44:08.600 --> 00:44:14.600]   Eine Aussage ist eine Behauptung, die entweder wahr oder falsch ist.
[00:44:14.600 --> 00:44:18.600]   Manchmal kann man nicht sofort erkennen, ob die Aussage wahr oder falsch ist.
[00:44:18.600 --> 00:44:22.600]   Also Aussage wie Zürich ist ein Kanton in der Schweiz.
[00:44:22.600 --> 00:44:25.600]   Das können Sie sofort beantworten.
[00:44:25.600 --> 00:44:28.600]   11 ist eine Primzahl wahrscheinlich auch.
[00:44:28.600 --> 00:44:30.600]   120 ist kleiner als 11.
[00:44:30.600 --> 00:44:32.600]   X größer gleich null.
[00:44:32.600 --> 00:44:37.600]   Können Sie nicht sofort beantworten, weil das hängt davon ab, was für einen Wert X hat.
[00:44:37.600 --> 00:44:40.600]   Oder X geteilt durch 2 ergibt 8.
[00:44:40.600 --> 00:44:46.600]   Ob die Aussage wahr oder falsch ist, das hängt auch wieder von diesem Wert X ab.
[00:44:46.600 --> 00:44:50.600]   Also die entscheidende der Punkt ist nicht, ob Aussagen wahr oder falsch sind,
[00:44:50.600 --> 00:44:57.600]   sondern dass eben Aussagen, das Sinn macht zu fragen, ob die Aussage wahr oder falsch ist.
[00:44:57.600 --> 00:45:01.600]   Es muss also möglich sein, diese Frage zu stellen.
[00:45:01.600 --> 00:45:07.600]   Und es muss einen Weg geben, diese Aussage als entweder wahr oder falsch zu erkennen.
[00:45:07.600 --> 00:45:12.600]   Das heißt eben, das sind einfache Aussagen im Rahmen der klassischen Logik,
[00:45:12.600 --> 00:45:16.600]   die Sie ja in der diskreten Mathematik jetzt wahrscheinlich auch schon kennengelernt haben.
[00:45:16.600 --> 00:45:19.600]   Oder zumindest bald kennenlernen werden.
[00:45:19.600 --> 00:45:25.600]   Also wie gesagt, es wichtig ist, dass es Sinn macht zu fragen, ob eine Aussage wahr oder falsch ist.
[00:45:25.600 --> 00:45:31.600]   Und unser Ziel ist es jetzt eben Aussagen über ein Programm zu erstellen oder herzuleiten.
[00:45:31.600 --> 00:45:35.600]   Und wie ich eben sagte, diese Aussagen gelten an einer Stelle im Programm.
[00:45:35.600 --> 00:45:38.600]   Das heißt, wir müssen dann, warum machen wir das?
[00:45:38.600 --> 00:45:43.600]   Wir machen das, weil wir vielleicht festhalten wollen, was für Annahmen nötig sind,
[00:45:43.600 --> 00:45:46.600]   damit eine Aussage P wahr ist.
[00:45:46.600 --> 00:45:53.600]   P ist eine Aussage, das heißt, es macht Sinn zu fragen, ob die wahr oder falsch ist.
[00:45:53.600 --> 00:45:58.600]   Aber wir können vielleicht nicht sofort die Entscheidung wahr oder falsch treffen.
[00:45:58.600 --> 00:46:00.600]   Wir brauchen halt gewisse Annahmen.
[00:46:00.600 --> 00:46:04.600]   Und diese Annahmen sagen uns etwas über das Programm aus.
[00:46:04.600 --> 00:46:07.600]   Und das interessiert uns eben über das Programm.
[00:46:07.600 --> 00:46:12.600]   Aber das macht eben alles nur Sinn, wenn wir eben an irgendeiner Stelle das festhalten können,
[00:46:12.600 --> 00:46:17.600]   weil, wie ich Ihnen eben im Beispiel davor zeigte, es gibt Punkte im Programm,
[00:46:17.600 --> 00:46:21.600]   wo wir gar gar nicht darüber reden können, dass diese Variabe,
[00:46:21.600 --> 00:46:24.600]   dass da eben irgendeine Aussage gemacht werden kann.
[00:46:24.600 --> 00:46:30.600]   Und darum stellen wir uns vor, dass diese Programme, der Code, irgendwelche Punkte hat,
[00:46:30.600 --> 00:46:32.600]   einen Punkt, noch einen Punkt.
[00:46:32.600 --> 00:46:34.600]   Und diese Punkte haben einen Namen.
[00:46:34.600 --> 00:46:37.600]   Kann sagen Punkt A, Punkt B, Punkt C.
[00:46:37.600 --> 00:46:41.600]   Und die Annahme, die wir fällen, ist, dass wenn wir hier an dem Punkt B sind,
[00:46:41.600 --> 00:46:46.600]   dann alle Anweisungen, die davor erschienen, die wurden bereits gemacht.
[00:46:46.600 --> 00:46:49.600]   Und alle Anweisungen wurden ausgeführt.
[00:46:49.600 --> 00:46:53.600]   Und alle Anweisungen, die danach kommen, die wurden noch nicht ausgeführt.
[00:46:53.600 --> 00:46:56.600]   Also hier ist unser Punkt B.
[00:46:56.600 --> 00:47:00.600]   Und an diesem Punkt B haben wir jetzt die Situation,
[00:47:00.600 --> 00:47:04.600]   dass alle Anweisungen, die davor kamen, sind bereits gemacht worden.
[00:47:04.600 --> 00:47:08.600]   Und alle Anweisungen, die danach kommen, die wurden noch nicht ausgeführt.
[00:47:08.600 --> 00:47:12.600]   Und das ist wichtig, weil je nachdem, was die Anweisungen machen,
[00:47:12.600 --> 00:47:15.600]   könnten die ja auch irgendwelche Variable verändern.
[00:47:15.600 --> 00:47:21.600]   Also wir stellen es also vor, dass es diese imaginären Punkte da gibt
[00:47:21.600 --> 00:47:24.600]   und dass wir davon reden können, dass das so oder so ist.
[00:47:24.600 --> 00:47:28.600]   Und jetzt können wir eben über die Programme an diesem Punkt reden.
[00:47:28.600 --> 00:47:34.600]   Und diese Logik wurde entwickelt von einem Mann namens Hoor, Tony Hoor.
[00:47:34.600 --> 00:47:39.600]   Und er hat das schon vor langer Zeit, also vor fast 50 Jahren gemacht.
[00:47:39.600 --> 00:47:42.600]   Und das hat immer noch eine gewisse Bedeutung.
[00:47:42.600 --> 00:47:46.600]   Und diese Logik erlaubt es uns eben zu sagen,
[00:47:46.600 --> 00:47:50.600]   wir gucken uns ein Programm an vorwärts, um festzuhalten,
[00:47:50.600 --> 00:47:53.600]   was für Auslagen danach gelten.
[00:47:53.600 --> 00:47:56.600]   Und wir gucken uns ein Programm rückwärts an,
[00:47:56.600 --> 00:48:01.600]   um zu sehen, was am Eingang oder zu Beginn dieser Ausführung
[00:48:01.600 --> 00:48:06.600]   gegolten haben muss, damit eben eine bestimmte Annahme erfüllt ist.
[00:48:06.600 --> 00:48:08.600]   Und das werden wir als Erstes machen.
[00:48:08.600 --> 00:48:11.600]   Und um das Ganze nicht zu schwierig zu machen,
[00:48:11.600 --> 00:48:15.600]   werden wir erstmal uns eine einzige Anweisung angucken.
[00:48:15.600 --> 00:48:19.600]   Wir gucken uns eine Anweisung an und gehen von der,
[00:48:19.600 --> 00:48:21.600]   weder vorwärts oder rückwärts,
[00:48:21.600 --> 00:48:25.600]   um zu entscheiden, was mit der gemacht werden kann.
[00:48:25.600 --> 00:48:28.600]   Das wird jetzt vielleicht für Sie extrem langweilig sein,
[00:48:28.600 --> 00:48:30.600]   weil Sie das schon kennen.
[00:48:30.600 --> 00:48:31.600]   Dann gut.
[00:48:31.600 --> 00:48:36.600]   Das kann für Sie extrem tedious sein, weil Sie sagen, das ist ja ganz genau.
[00:48:36.600 --> 00:48:38.600]   Das stimmt, das ist ganz genau.
[00:48:38.600 --> 00:48:41.600]   Und damit langsam und Schritt für Schritt.
[00:48:41.600 --> 00:48:44.600]   Aber das ist wichtig, dass Sie das Schritt für Schritt verstehen,
[00:48:44.600 --> 00:48:48.600]   weil wenn Sie eben mit den einzelnen Anweisungen Probleme haben,
[00:48:48.600 --> 00:48:50.600]   kommen Sie eben nicht weiter,
[00:48:50.600 --> 00:48:53.600]   wenn es dann später kompliziertere Beispiele gibt.
[00:48:53.600 --> 00:48:56.600]   Und das werden wir sehen, ist eine wichtige Sache.
[00:48:56.600 --> 00:49:00.600]   Also unser Ziel ist es, für ein einfaches Programm
[00:49:00.600 --> 00:49:04.600]   genau zu argumentieren, was dieses Programm eigentlich macht.
[00:49:04.600 --> 00:49:06.600]   Was macht das Programm?
[00:49:06.600 --> 00:49:08.600]   Was für ein Ergebnis liefert es?
[00:49:08.600 --> 00:49:11.600]   Was gilt am Ende dieses Programms?
[00:49:11.600 --> 00:49:14.600]   Sie werden das jetzt nicht mit jedem Programm machen,
[00:49:14.600 --> 00:49:17.600]   dass Sie jeden Tag in den Übungsaufgaben schreiben.
[00:49:17.600 --> 00:49:20.600]   Wenn Sie diese Schritte für jedes Programm machten,
[00:49:20.600 --> 00:49:22.600]   dann könnte das wirklich sehr lange dauern.
[00:49:22.600 --> 00:49:26.600]   Also in der täglichen Programmentwicklung macht man das nicht ganz so genau.
[00:49:26.600 --> 00:49:31.600]   Aber es ist wichtig, dass Sie verstehen, wie dieser Ansatz funktioniert.
[00:49:31.600 --> 00:49:33.600]   Weil wenn Sie mal eine Situation kommen,
[00:49:33.600 --> 00:49:36.600]   wo Sie nicht genau wissen, was ein Programm macht
[00:49:36.600 --> 00:49:38.600]   oder ein Programm segment macht,
[00:49:38.600 --> 00:49:40.600]   dann gibt Ihnen dieser Ansatz ein Werkzeug,
[00:49:40.600 --> 00:49:44.600]   mit dem Sie diese Schritte nachvollziehen können,
[00:49:44.600 --> 00:49:47.600]   mit dem Sie eben sehen können, was das Programm macht.
[00:49:47.600 --> 00:49:53.600]   Also das ist so der erste Ansatz zur Verifikation von Programmen.
[00:49:53.600 --> 00:49:56.600]   Und das ist ein sehr wichtiger Bereich,
[00:49:56.600 --> 00:49:59.600]   wenn wir sicher sein wollen, dass die Programme das machen,
[00:49:59.600 --> 00:50:02.600]   was wir wollen und nicht irgendwas anderes.
[00:50:02.600 --> 00:50:06.600]   Also das Ganze hat eben sowohl einen didaktischen Effekt
[00:50:06.600 --> 00:50:08.600]   als auch einen praktischen Effekt.
[00:50:08.600 --> 00:50:12.600]   Weil wir können jetzt Aussagen machen über Zustände.
[00:50:12.600 --> 00:50:14.600]   Das sind Zustände der Ausführungen.
[00:50:14.600 --> 00:50:17.600]   Das Programm wird ausgeführt.
[00:50:17.600 --> 00:50:20.600]   Später können wir machen, wir kommen zu kompliziertere Programme.
[00:50:20.600 --> 00:50:25.600]   Und wir können jetzt diesen Effekt eines Programms ganz genau beschreiben.
[00:50:25.600 --> 00:50:30.600]   Wir können sagen, was es heißt, dass eine Aussage ist stärker
[00:50:30.600 --> 00:50:33.600]   und eine andere Aussage ist schwächer.
[00:50:33.600 --> 00:50:35.600]   Wir werden also einen Weg finden,
[00:50:35.600 --> 00:50:38.600]   die Aussagen in manchen Fällen zu vergleichen sagen,
[00:50:38.600 --> 00:50:41.600]   eine Aussage ist stärker oder schwächer.
[00:50:41.600 --> 00:50:44.600]   Und können dann sagen, ach, wir brauchen hier eine stärkere
[00:50:44.600 --> 00:50:46.600]   oder eine schwächere Ausgabe.
[00:50:46.600 --> 00:50:49.600]   Und das ist halt wichtig, insbesondere dann,
[00:50:49.600 --> 00:50:52.600]   wenn Sie Methoden entwickeln, die von anderen Leuten benutzt werden.
[00:50:52.600 --> 00:50:56.600]   Da wollen Sie ganz genau sagen, was erwartet diese Methode als Eingabe,
[00:50:56.600 --> 00:50:59.600]   was für Bedingungen müssen erfüllt sein,
[00:50:59.600 --> 00:51:02.600]   damit diese Methode die Aufgaben erledigen kann,
[00:51:02.600 --> 00:51:05.600]   die sie behauptet, erledigen zu können.
[00:51:05.600 --> 00:51:12.600]   Also, kommt der Punkt, wie finden wir jetzt die Richtenstellen im Programm?
[00:51:12.600 --> 00:51:16.600]   Weil letztlich interessieren Sie nicht irgendwelche Aussagen,
[00:51:16.600 --> 00:51:20.600]   sondern Aussagen, die das Verhalten der Ausführungen beschreiben.
[00:51:20.600 --> 00:51:24.600]   Und darum, um das nicht so schwierig zu machen,
[00:51:24.600 --> 00:51:27.600]   funktionieren unsere Programme zurzeit so,
[00:51:27.600 --> 00:51:30.600]   dass sie einfach allen nur mit Indivariablen arbeiten.
[00:51:30.600 --> 00:51:32.600]   Es ist nicht schwer, das weiter zu erweitern,
[00:51:32.600 --> 00:51:34.600]   aber am Anfang machen wir Indivariablen.
[00:51:34.600 --> 00:51:39.600]   Und wir nehmen an, dass die endliche Darstellung ist kein Problem.
[00:51:39.600 --> 00:51:42.600]   Alle Ergebnisse können korrekt dargestellt werden.
[00:51:42.600 --> 00:51:44.600]   Also, wenn ich eben eine Addition mache,
[00:51:44.600 --> 00:51:47.600]   dann ist das Ergebnis auch wieder eine Ind.
[00:51:47.600 --> 00:51:49.600]   Ich muss mir keine Gedanken machen, was passiert,
[00:51:49.600 --> 00:51:54.600]   wenn das Ergebnis nicht mit der endlichen Darstellung dargestellt werden kann.
[00:51:54.600 --> 00:52:00.600]   Das ist ganz wichtig, dass Sie das für diese Beispiele immer im Kopf haben.
[00:52:00.600 --> 00:52:05.600]   Also, jetzt nehmen wir alle an, wir haben hier drei Anweisungen,
[00:52:05.600 --> 00:52:06.600]   X, Y und Z.
[00:52:06.600 --> 00:52:10.600]   X wird ein Wert zugewiesen, Y wird ein Wert zugewiesen,
[00:52:10.600 --> 00:52:12.600]   Z wird ein Wert zugewiesen.
[00:52:12.600 --> 00:52:17.600]   Und wir nehmen an, dass wir wissen oder vermuten,
[00:52:17.600 --> 00:52:21.600]   dass diese Variable W, die ja hier auch auftaucht,
[00:52:21.600 --> 00:52:25.600]   dass die einen Wert größer 0 hat.
[00:52:25.600 --> 00:52:30.600]   Und wir wollen jetzt eben den Zustand vor der Ausführung eines Programmsigiments
[00:52:30.600 --> 00:52:33.600]   als Grundlage benutzen, um uns zu fragen,
[00:52:33.600 --> 00:52:38.600]   was können wir sagen, nachdem dieses Programmsigiment ausgeführt wurde.
[00:52:38.600 --> 00:52:42.600]   Also, am Anfang wissen wir, dass dieses Programm,
[00:52:42.600 --> 00:52:46.600]   in diesem Programmsigiment die Variable W, den einen Wert größer 0 hat.
[00:52:46.600 --> 00:52:49.600]   Das kann eine Anforderung sein, die wir erstellen.
[00:52:49.600 --> 00:52:52.600]   Und jetzt haben wir eine Zuweisung zu X.
[00:52:52.600 --> 00:52:54.600]   Und nachdem wir das gemacht haben,
[00:52:54.600 --> 00:52:57.600]   wissen wir, dass W ist immer noch größer 0
[00:52:57.600 --> 00:53:01.600]   und dass das X hat den Wert 17,
[00:53:01.600 --> 00:53:05.600]   weil hier war eine Zuweisung zu X.
[00:53:05.600 --> 00:53:10.600]   Und nach dieser Zuweisung zu Y, wissen wir, dass W größer 0 ist,
[00:53:10.600 --> 00:53:14.600]   X hat den Wert 17, Y hat den Wert 42.
[00:53:14.600 --> 00:53:18.600]   Und jetzt bilden wir die Summe aus W, X und Y.
[00:53:18.600 --> 00:53:21.600]   Und danach wissen wir, W ist immer noch größer 0,
[00:53:21.600 --> 00:53:25.600]   X hat den Wert 17, Y hat den Wert 42.
[00:53:25.600 --> 00:53:28.600]   Und wir wissen, das ist jetzt das, was das Interessante für uns ist,
[00:53:28.600 --> 00:53:32.600]   und Z hat einen Wert, der ist größer als 59.
[00:53:32.600 --> 00:53:37.600]   Das können wir schließen, weil wir wissen, dass 17 und 42 gibt 49
[00:53:37.600 --> 00:53:41.600]   und dem wird noch dazu addiert, ein Wert größer als 0
[00:53:41.600 --> 00:53:46.600]   und sind ja alles ins, also W ist mindestens 1.
[00:53:46.600 --> 00:53:49.600]   Und jetzt wissen wir, also, dass das Programm,
[00:53:49.600 --> 00:53:53.600]   in diesem Programmsegment Z ist größer als 59.
[00:53:53.600 --> 00:53:56.600]   Das haben wir hier festgestellt.
[00:53:56.600 --> 00:53:59.600]   Das ist, was wir vorwärtschließen nennen.
[00:53:59.600 --> 00:54:03.600]   Wir gucken uns, wir haben Aussagen, die wir wissen oder vermuten,
[00:54:03.600 --> 00:54:07.600]   die zu Beginn der Ausführung gelten, dann gucken wir uns die Aussagen an.
[00:54:07.600 --> 00:54:10.600]   Und am Ende machen wir eine Aussage über das, was gelten muss,
[00:54:10.600 --> 00:54:13.600]   nachdem das ausgeführt worden ist.
[00:54:13.600 --> 00:54:18.600]   Jetzt rückwärtschließen, also hier haben wir eine Folge von Statements.
[00:54:18.600 --> 00:54:22.600]   Und wir haben das aus Bequemlichkeitsgründen,
[00:54:22.600 --> 00:54:28.600]   habe ich einfach diese Aussagen als Kommentare da hereingeschrieben.
[00:54:28.600 --> 00:54:32.600]   Bitte beachten Sie, dass dieser Kommentar eine logische Aussage ist,
[00:54:32.600 --> 00:54:35.600]   kein Java-Auszug oder keine Anweisung.
[00:54:35.600 --> 00:54:38.600]   Ich habe einfach nur einfach was ich geschrieben habe,
[00:54:38.600 --> 00:54:43.600]   damit das Ganze auf ein Sleit vernünftigerweise passt.
[00:54:43.600 --> 00:54:46.600]   Also, das war jetzt vorwärtsschließen.
[00:54:46.600 --> 00:54:49.600]   Jetzt sind wir rückwärtschließen, ist umgekehrt.
[00:54:49.600 --> 00:54:52.600]   Wir überlegen uns, haben wir irgendeine Aussage hier,
[00:54:52.600 --> 00:54:55.600]   irgendeine Aussage oder gibt es eine Aussage,
[00:54:55.600 --> 00:54:58.600]   die wir vielleicht erreichen wollen.
[00:54:58.600 --> 00:55:01.600]   Und wir müssen jetzt feststellen,
[00:55:01.600 --> 00:55:04.600]   was für eine Bedingung muss davor erfüllt sein,
[00:55:04.600 --> 00:55:07.600]   damit das eben später der Fall ist.
[00:55:07.600 --> 00:55:11.600]   Also, nehmen wir mal an, wir wollen in diesem Fall hier haben,
[00:55:11.600 --> 00:55:15.600]   dass Z nach der Ausführung negativ ist.
[00:55:15.600 --> 00:55:20.600]   Also, wir wollen wissen, dass dieses Z kleiner als Null ist.
[00:55:20.600 --> 00:55:23.600]   Das könnte für uns wichtig sein,
[00:55:23.600 --> 00:55:26.600]   für das, was wir als Nächstes machen wollen.
[00:55:26.600 --> 00:55:29.600]   Wenn ich also Z kleiner als Null haben will,
[00:55:29.600 --> 00:55:32.600]   muss denn in dem Punkt davor gegolten haben.
[00:55:32.600 --> 00:55:36.600]   Naja, am Punkt davor muss etwas gegolten haben,
[00:55:36.600 --> 00:55:41.600]   dass ich eben sagen kann,
[00:55:41.600 --> 00:55:48.600]   dass dieser Ausdruck W plus X plus Y muss kleiner als Null sein.
[00:55:48.600 --> 00:55:50.600]   Also, hier muss gegolten haben,
[00:55:50.600 --> 00:55:54.600]   dass W plus X plus Y ist kleiner als Null.
[00:55:54.600 --> 00:55:58.600]   Und was muss davor gegolten haben, damit das eben gilt?
[00:55:58.600 --> 00:56:02.600]   Naja, jetzt wissen wir hier, Y wurde auf 42 gesetzt.
[00:56:02.600 --> 00:56:05.600]   Also, was wir jetzt haben müssen,
[00:56:05.600 --> 00:56:10.600]   ist, dass W plus X plus 42 muss kleiner als Null sein.
[00:56:10.600 --> 00:56:13.600]   Wenn das der Fall ist, dann ist nach dieser Zuweisung,
[00:56:13.600 --> 00:56:16.600]   auch W plus X plus Y kleiner als Null.
[00:56:16.600 --> 00:56:19.600]   Und jetzt sehe ich, was für ein Wert hat das X bekommen?
[00:56:19.600 --> 00:56:21.600]   Also, das X hat bekommen den Wert 17,
[00:56:21.600 --> 00:56:26.600]   also W plus 17 plus 42 muss kleiner als Null sein.
[00:56:26.600 --> 00:56:29.600]   Und dann kann ich daraus jetzt schließen,
[00:56:29.600 --> 00:56:31.600]   ah, okay, wenn das der Fall ist,
[00:56:31.600 --> 00:56:34.600]   dann kann ich eben jetzt sagen, ah,
[00:56:34.600 --> 00:56:40.600]   W muss eben kleiner als minus 59 sein,
[00:56:40.600 --> 00:56:43.600]   um das erwünschte Ergebnis haben.
[00:56:43.600 --> 00:56:47.600]   Also, das ist halt für uns ein Weg,
[00:56:47.600 --> 00:56:50.600]   wie wir ein gewünschtes Resultat erzwingen können.
[00:56:50.600 --> 00:56:54.600]   Der gewünschte Wert war, dass das Z kleiner als Null ist.
[00:56:54.600 --> 00:56:56.600]   Und wir wollen jetzt eben sicherstellen,
[00:56:56.600 --> 00:56:59.600]   dass nach der Ausführung dieses Programms,
[00:56:59.600 --> 00:57:02.600]   das eben der Fall ist, das Z kleiner als Null ist.
[00:57:02.600 --> 00:57:05.600]   Und das geht eben hier, das ist dann der Fall,
[00:57:05.600 --> 00:57:09.600]   wenn dieses W kleiner als minus 59 ist.
[00:57:09.600 --> 00:57:11.600]   Und diese Bedingung ist sowohl notwendig,
[00:57:11.600 --> 00:57:13.600]   als auch hinreichend.
[00:57:13.600 --> 00:57:17.600]   Wenn das W größer gleich minus 59 ist,
[00:57:17.600 --> 00:57:19.600]   dann ist diese Bedingung hier hinten nicht erfüllt.
[00:57:19.600 --> 00:57:21.600]   Und es ist hinreichend,
[00:57:21.600 --> 00:57:24.600]   wenn die B wirklich kleiner als minus 59 ist,
[00:57:24.600 --> 00:57:28.600]   dann haben wir in der Tat das richtige Ergebnis
[00:57:28.600 --> 00:57:30.600]   und haben dann garantiert,
[00:57:30.600 --> 00:57:32.600]   dann haben wir eine Situation,
[00:57:32.600 --> 00:57:35.600]   dass Z kleiner als Null ist.
[00:57:35.600 --> 00:57:37.600]   Also, das ist vorwärtsrückwärts.
[00:57:37.600 --> 00:57:40.600]   Sie gucken sich ein Programm einmal an in Bezug auf,
[00:57:40.600 --> 00:57:43.600]   was habe ich denn, was gilt denn,
[00:57:43.600 --> 00:57:45.600]   oder was für einen Zustand werde ich haben,
[00:57:45.600 --> 00:57:47.600]   wenn das Programm ausgeführt ist.
[00:57:47.600 --> 00:57:49.600]   Das ist diese vorwärtssichtweise.
[00:57:49.600 --> 00:57:52.600]   Das ist der Rückwärts, was für eine Bedingung
[00:57:52.600 --> 00:57:54.600]   muss am Anfang erfüllt sein,
[00:57:54.600 --> 00:57:57.600]   damit ich am Ende eine andere,
[00:57:57.600 --> 00:58:00.600]   am Ende diese Bedingung gilt.
[00:58:00.600 --> 00:58:03.600]   Also, vorwärtsschließend ist praktisch,
[00:58:03.600 --> 00:58:06.600]   wenn Sie eben ursprüngliche Anleitungen,
[00:58:06.600 --> 00:58:08.600]   ursprüngliche Annahmen haben
[00:58:08.600 --> 00:58:12.600]   und Sie jetzt eben sehen wollen, was danach gilt.
[00:58:12.600 --> 00:58:14.600]   Und das ist sehr praktisch,
[00:58:14.600 --> 00:58:16.600]   wenn eben eine Invariante gelten soll.
[00:58:16.600 --> 00:58:18.600]   Sie haben vielleicht schon die invarianten
[00:58:18.600 --> 00:58:20.600]   in Algorithmen und Datenstrukturen kennengelernt.
[00:58:20.600 --> 00:58:22.600]   Haben Sie das Wort noch nicht?
[00:58:22.600 --> 00:58:24.600]   Okay, dann werden Sie aber,
[00:58:24.600 --> 00:58:26.600]   invarianten sind eben logische Aussagen,
[00:58:26.600 --> 00:58:28.600]   die invariant sind,
[00:58:28.600 --> 00:58:30.600]   die also immer gelten,
[00:58:30.600 --> 00:58:32.600]   oder einen bestimmten Bereich immer gelten.
[00:58:32.600 --> 00:58:34.600]   Und wenn wir so was haben,
[00:58:34.600 --> 00:58:36.600]   wenn wir also sicher sein wollen,
[00:58:36.600 --> 00:58:38.600]   dass irgendeine Aussage immer gilt,
[00:58:38.600 --> 00:58:40.600]   können wir mit vorwärtsschließen
[00:58:40.600 --> 00:58:42.600]   die einzelnen Aussagen erkennen,
[00:58:42.600 --> 00:58:44.600]   die da an dem Punkt gelten müssen
[00:58:44.600 --> 00:58:46.600]   und die da an dem Punkt gelten müssen,
[00:58:46.600 --> 00:58:48.600]   die da an dem Punkt gelten müssen,
[00:58:48.600 --> 00:58:50.600]   die da an dem Punkt gelten müssen,
[00:58:50.600 --> 00:58:52.600]   die da an dem Punkt gelten.
[00:58:52.600 --> 00:58:54.600]   Und das ist ja auch ein Punkt,
[00:58:54.600 --> 00:58:56.600]   das wir jetzt schon mal sehen,
[00:58:56.600 --> 00:58:58.600]   dass wir das hier in der Formatik haben,
[00:58:58.600 --> 00:59:00.600]   das wir jetzt in der Formatik haben,
[00:59:00.600 --> 00:59:02.600]   das wir jetzt in der Formatik haben,
[00:59:02.600 --> 00:59:04.600]   das wir jetzt in der Formatik haben,
[00:59:04.600 --> 00:59:06.600]   das wir jetzt in der Formatik haben,
[00:59:06.600 --> 00:59:08.600]   das wir jetzt in der Formatik haben,
[00:59:08.600 --> 00:59:10.600]   das wir jetzt in der Formatik haben,
[00:59:10.600 --> 00:59:12.600]   das wir jetzt in der Formatik haben,
[00:59:12.600 --> 00:59:14.600]   das wir jetzt in der Formatik haben,
[00:59:14.600 --> 00:59:16.600]   das wir jetzt in der Formatik haben,
[00:59:16.600 --> 00:59:18.600]   das wir jetzt in der Formatik haben,
[00:59:18.600 --> 00:59:20.600]   das wir jetzt in der Formatik haben,
[00:59:20.600 --> 00:59:22.600]   das wir jetzt in der Formatik haben,
[00:59:22.600 --> 00:59:24.600]   das wir jetzt in der Formatik haben,
[00:59:24.600 --> 00:59:26.600]   das wir jetzt in der Formatik haben,
[00:59:26.600 --> 00:59:28.600]   das wir jetzt in der Formatik haben,
[00:59:28.600 --> 00:59:30.600]   das wir jetzt in der Formatik haben,
[00:59:30.600 --> 00:59:32.600]   das wir jetzt in der Formatik haben,
[00:59:32.600 --> 00:59:34.600]   das wir jetzt in der Formatik haben,
[00:59:34.600 --> 00:59:36.600]   das wir jetzt in der Formatik haben,
[00:59:36.600 --> 00:59:38.600]   das wir jetzt in der Formatik haben,
[00:59:38.600 --> 00:59:40.600]   das wir jetzt in der Formatik haben,
[00:59:40.600 --> 00:59:42.600]   das wir jetzt in der Formatik haben,
[00:59:42.600 --> 00:59:44.600]   das wir jetzt in der Formatik haben,
[00:59:44.600 --> 00:59:46.600]   das wir jetzt in der Formatik haben,
[00:59:46.600 --> 00:59:48.600]   das wir jetzt in der Formatik haben,
[00:59:48.600 --> 00:59:50.600]   das wir jetzt in der Formatik haben,
[00:59:50.600 --> 00:59:52.600]   das wir jetzt in der Formatik haben,
[00:59:52.600 --> 00:59:54.600]   das wir jetzt in der Formatik haben,
[00:59:54.600 --> 00:59:56.600]   das wir jetzt in der Formatik haben,
[00:59:56.600 --> 00:59:58.600]   das wir jetzt in der Formatik haben,
[00:59:58.600 --> 01:00:00.600]   das wir jetzt in der Formatik haben,
[01:00:00.600 --> 01:00:02.600]   das wir jetzt in der Formatik haben,
[01:00:02.600 --> 01:00:04.600]   das wir jetzt in der Formatik haben,
[01:00:04.600 --> 01:00:06.600]   das wir jetzt in der Formatik haben,
[01:00:06.600 --> 01:00:08.600]   das wir jetzt in der Formatik haben,
[01:00:08.600 --> 01:00:10.600]   die sind in der Simulation,
[01:00:10.600 --> 01:00:12.600]   sind die mit abgedeckt.
[01:00:12.600 --> 01:00:14.600]   Die ist so ein Vorwärtsschließen,
[01:00:14.600 --> 01:00:16.600]   ist oft leicht zu verstehen
[01:00:16.600 --> 01:00:18.600]   und erscheint eigentlich fast natürlich,
[01:00:18.600 --> 01:00:20.600]   weil wir gucken uns das Programm an
[01:00:20.600 --> 01:00:22.600]   und versuchen zu verstehen,
[01:00:22.600 --> 01:00:25.600]   was das Programm eigentlich machen soll.
[01:00:25.600 --> 01:00:27.600]   Der Nachteil ist,
[01:00:27.600 --> 01:00:29.600]   das ist ein bisschen der Nachteil,
[01:00:29.600 --> 01:00:32.600]   dass oft sehr viele Details festgehalten werden.
[01:00:32.600 --> 01:00:34.600]   Sie haben gesehen, wir haben festgehalten,
[01:00:34.600 --> 01:00:36.600]   als wir vorwärts geschlossen haben,
[01:00:36.600 --> 01:00:38.600]   dass es größer Null ist,
[01:00:38.600 --> 01:00:40.600]   dass X diesen Wert hat,
[01:00:40.600 --> 01:00:42.600]   dass Y diesen Wert hat und so weiter.
[01:00:42.600 --> 01:00:44.600]   Und nicht alle von diesen Details
[01:00:44.600 --> 01:00:46.600]   sind vielleicht am Ende wichtig für uns,
[01:00:46.600 --> 01:00:48.600]   wenn es uns darum geht,
[01:00:48.600 --> 01:00:50.600]   eine bestimmte Aussage zu treffen.
[01:00:50.600 --> 01:00:52.600]   Aber wir wissen ja am Anfang noch nicht,
[01:00:52.600 --> 01:00:54.600]   was für eine Aussage wir am Ende
[01:00:54.600 --> 01:00:57.600]   der Folge von Anweisungen eigentlich machen wollen.
[01:00:57.600 --> 01:01:00.600]   Und deswegen werden alle diese Details festgehalten,
[01:01:00.600 --> 01:01:03.600]   auch wenn sie nachher letztlich nicht wichtig sind.
[01:01:03.600 --> 01:01:05.600]   Das ist so ein Nachteil,
[01:01:05.600 --> 01:01:07.600]   dass wir das Programm anwenden können.
[01:01:07.600 --> 01:01:09.600]   Jetzt rückwärts schließen,
[01:01:09.600 --> 01:01:11.600]   ist vielleicht etwas ungewohnt für Sie,
[01:01:11.600 --> 01:01:13.600]   aber von großem praktischen Nutzen,
[01:01:13.600 --> 01:01:15.600]   weil Sie verstehen,
[01:01:15.600 --> 01:01:18.600]   was jede Anweisung zum Endergebnis beiträgt.
[01:01:18.600 --> 01:01:20.600]   Sie können gucken,
[01:01:20.600 --> 01:01:22.600]   was macht diese Anweisung
[01:01:22.600 --> 01:01:24.600]   und was hat für einen Einfluss,
[01:01:24.600 --> 01:01:26.600]   hat das auf das Endergebnis,
[01:01:26.600 --> 01:01:28.600]   das ich erreichen möchte.
[01:01:28.600 --> 01:01:31.600]   Und eben so ein Programmsegment rückwärts zu lesen,
[01:01:31.600 --> 01:01:33.600]   da braucht man ein bisschen Übung,
[01:01:33.600 --> 01:01:36.600]   um zu sehen, was ein Programm macht.
[01:01:36.600 --> 01:01:38.600]   Nach dieser Einführung
[01:01:38.600 --> 01:01:41.600]   kommen wir jetzt auf die Begriffe zu sprechen,
[01:01:41.600 --> 01:01:44.600]   die Sie vielleicht schon mal woanders gehört haben,
[01:01:44.600 --> 01:01:47.600]   nämlich auf die "Pri" und "Postcondition".
[01:01:47.600 --> 01:01:50.600]   Also die "Pri-Condition", "Pri" von vor,
[01:01:50.600 --> 01:01:53.600]   die "Pri-Condition" ist die notwendige Vorbedingung,
[01:01:53.600 --> 01:01:55.600]   die erfüllt sein muss
[01:01:55.600 --> 01:01:58.600]   oder die Bedingungen, die erfüllt sein müssen,
[01:01:58.600 --> 01:02:01.600]   vor der Ausführung einer Anweisung, vor.
[01:02:01.600 --> 01:02:03.600]   Also die "Pri-Condition" hält fest,
[01:02:03.600 --> 01:02:05.600]   was für eine Bedingung
[01:02:05.600 --> 01:02:07.600]   oder was für Bedingungen erfüllt sein müssen,
[01:02:07.600 --> 01:02:09.600]   bevor eine Anweisung ausgeführt wird.
[01:02:09.600 --> 01:02:12.600]   Und die "Postcondition", die hält fest,
[01:02:12.600 --> 01:02:15.600]   was das Ergebnis der Ausführung ist.
[01:02:15.600 --> 01:02:17.600]   Also die hält fest,
[01:02:17.600 --> 01:02:20.600]   was für einen Zustand
[01:02:20.600 --> 01:02:23.600]   oder was für eine Aussage nach der Ausführung gilt.
[01:02:23.600 --> 01:02:25.600]   Wichtig aber ist,
[01:02:25.600 --> 01:02:28.600]   die "Postcondition" gilt dann,
[01:02:28.600 --> 01:02:31.600]   wenn die "Pri-Condition" erfüllt ist.
[01:02:31.600 --> 01:02:34.600]   Wenn wir nichts über die "Pri-Condition" wissen,
[01:02:34.600 --> 01:02:37.600]   können wir vielleicht auch gar nichts über die "Postcondition" sagen.
[01:02:37.600 --> 01:02:40.600]   Also die Aussage gilt natürlich nur,
[01:02:40.600 --> 01:02:42.600]   wenn die "Pri-Condition" erfüllt ist.
[01:02:42.600 --> 01:02:46.600]   Dann haben wir den Weg, da eine Aussage zu machen.
[01:02:46.600 --> 01:02:49.600]   Und eben um das ganz einfach zu machen,
[01:02:49.600 --> 01:02:51.600]   fangen wir einfach an mit "Pri" und "Postconditions"
[01:02:51.600 --> 01:02:53.600]   für eine Anweisung.
[01:02:53.600 --> 01:02:57.600]   Wenn vor der Ausführung die "Pri-Condition" erfüllt ist,
[01:02:57.600 --> 01:03:02.600]   dann gilt nach der Ausführung die "Postcondition".
[01:03:02.600 --> 01:03:04.600]   So kann man argumentieren,
[01:03:04.600 --> 01:03:06.600]   wenn die "Pri-Condition" vorher erfüllt ist,
[01:03:06.600 --> 01:03:08.600]   gilt nachher die "Postcondition" oder umgekehrt.
[01:03:08.600 --> 01:03:11.600]   Damit die "Postcondition" erfüllt ist,
[01:03:11.600 --> 01:03:18.600]   muss vor der Ausführung die "Pri-Condition" erfüllt sein.
[01:03:18.600 --> 01:03:23.600]   Das ist die andere Sichtweise von "Pri" und "Postcondition".
[01:03:23.600 --> 01:03:25.600]   Also eben "Pri-Condition",
[01:03:25.600 --> 01:03:28.600]   Anweisung und "Postcondition" hängen zusammen.
[01:03:28.600 --> 01:03:31.600]   Die sind ganz aufeinander abgestimmt,
[01:03:31.600 --> 01:03:34.600]   weil sonst können wir ja keine Aussage machen.
[01:03:34.600 --> 01:03:39.600]   Je nachdem, was die Anweisung da macht,
[01:03:39.600 --> 01:03:44.600]   ist das eine oder andere dann eben die richtige "Pri"
[01:03:44.600 --> 01:03:46.600]   oder "Postcondition".
[01:03:46.600 --> 01:03:48.600]   Also das ist einfach wichtig.
[01:03:48.600 --> 01:03:52.600]   Am Anfang fangen wir wirklich an mit einer Anweisung.
[01:03:52.600 --> 01:03:57.600]   Und später werden wir das dann auf Folgen von Anweisungen erweitern.
[01:03:57.600 --> 01:04:02.600]   Wenn Sie Fragen haben, können Sie entweder haben hoch oder ...
[01:04:02.600 --> 01:04:08.600]   Also die "Pri-Condition" ist die Annahme, die vor der Ausführung gilt.
[01:04:08.600 --> 01:04:10.600]   Und jetzt kommt ein wichtiger Punkt.
[01:04:10.600 --> 01:04:15.600]   Diese Annahme oder diese Aussage über die, die danach gilt,
[01:04:15.600 --> 01:04:18.600]   ist die "Postcondition" gilt,
[01:04:18.600 --> 01:04:24.600]   wenn Sie diesen Punkt nach diesem Statement erreichen.
[01:04:24.600 --> 01:04:26.600]   Dann gilt die "Postcondition".
[01:04:26.600 --> 01:04:31.600]   Jetzt, warum ist dieses "Wenn wir diesen Punkt erreichen" so wichtig?
[01:04:31.600 --> 01:04:33.600]   Das ist deswegen so wichtig,
[01:04:33.600 --> 01:04:37.600]   weil eine Anweisung könnte ja aus irgendwelchen Gründen
[01:04:37.600 --> 01:04:39.600]   gar nicht zu Ende ausgeführt werden.
[01:04:39.600 --> 01:04:42.600]   Wenn Sie versuchen, durch Null zu dividieren,
[01:04:42.600 --> 01:04:44.600]   beschwert sich das System.
[01:04:44.600 --> 01:04:47.600]   Das heißt, Sie erreichen gar nicht den Punkt nach dieser Anweisung.
[01:04:47.600 --> 01:04:52.600]   Und deswegen macht es dann auch keinen Sinn über den Zustand des Programmes
[01:04:52.600 --> 01:04:54.600]   in Bezug auf die Variablen,
[01:04:54.600 --> 01:04:58.600]   die da in dieser Anweisung gesetzt werden sollten zu reden.
[01:04:58.600 --> 01:05:02.600]   Weil Sie eben keinen, Sie können da keine Aussage machen.
[01:05:02.600 --> 01:05:06.600]   Wenn Sie den Punkt nicht erreichen, dann machen Sie keine Aussage.
[01:05:06.600 --> 01:05:08.600]   Das ist ganz wichtig, dass Sie immer,
[01:05:08.600 --> 01:05:11.600]   wir denken, das gilt alles immer nur dann,
[01:05:11.600 --> 01:05:13.600]   wenn dieses Statement ausgeführt wurde.
[01:05:13.600 --> 01:05:16.600]   Wenn das Statement eben nicht ausgeführt wurde
[01:05:16.600 --> 01:05:18.600]   oder wenn die Ausführung abgebrochen wurde,
[01:05:18.600 --> 01:05:20.600]   dann können wir keine Aussage machen,
[01:05:20.600 --> 01:05:24.600]   weil wir wissen ja gar nicht, wo wir gelandet sind.
[01:05:24.600 --> 01:05:27.600]   Das ist immer wichtig, das zu bekommen.
[01:05:27.600 --> 01:05:31.600]   So, jetzt diese Aussagen, die "Prior to Post Condition",
[01:05:31.600 --> 01:05:34.600]   das sind logische Aussagen.
[01:05:34.600 --> 01:05:36.600]   Das sind logische Ausdrücke
[01:05:36.600 --> 01:05:40.600]   und die beziehen sich auf den Zustand der Ausführung.
[01:05:40.600 --> 01:05:43.600]   Also den Zustand, die Werte der Variablen oder so was.
[01:05:43.600 --> 01:05:45.600]   Das ist der Zustand eines Programms.
[01:05:45.600 --> 01:05:48.600]   Das sind die Variablen, die irgendwelche Werte haben.
[01:05:48.600 --> 01:05:52.600]   Und das heißt, diese Werte natürlich, die können wir ja selber nicht sehen.
[01:05:52.600 --> 01:05:56.600]   Die können wir nur über die Namen der Variablen erreichen.
[01:05:56.600 --> 01:05:59.600]   Und jede Variable, die wir da benutzen,
[01:05:59.600 --> 01:06:04.600]   liefert dann den Wert, den die Variable zum jetzigen Zeitpunkt haben.
[01:06:04.600 --> 01:06:08.600]   So, und das macht natürlich, das geht nur dann,
[01:06:08.600 --> 01:06:11.600]   und das ist nur dann verbleicht verständlich,
[01:06:11.600 --> 01:06:16.600]   wenn wir eben sicher sind, dass Ausdrücke keine Nebenwirkungen haben.
[01:06:16.600 --> 01:06:19.600]   Wenn Sie das nicht, da Sie nie gehört haben, was eine Nebenwirkung ist,
[01:06:19.600 --> 01:06:22.600]   ist das gut, dann erkennen Sie gar nicht die Probleme.
[01:06:22.600 --> 01:06:25.600]   Und wenn Sie sich damit gar nicht selbst das Leben schwer machen.
[01:06:25.600 --> 01:06:29.600]   Aber es gibt manchmal Ausdrücke, die könnte man eigentlich
[01:06:29.600 --> 01:06:31.600]   als logischen Ausdruck verwenden.
[01:06:31.600 --> 01:06:34.600]   Aber die haben Nebenwirkungen, das wollen wir nicht.
[01:06:34.600 --> 01:06:38.600]   Wir haben hier nur logische Ausdrücke, die haben keinen Effekt
[01:06:38.600 --> 01:06:41.600]   auf den Zustand des Programms.
[01:06:41.600 --> 01:06:47.600]   Und das geht alles eben gut und so weiter.
[01:06:47.600 --> 01:06:51.600]   Es ist wirklich nur eine Warnung an die Leute, die eben Vorkenntnisse haben.
[01:06:51.600 --> 01:06:54.600]   Nebenwirkungen haben wir noch nicht diskutiert, gibt es daher nicht.
[01:06:54.600 --> 01:06:58.600]   Aber wenn Sie davon gehört haben sollten, dann bitte denken Sie daran,
[01:06:58.600 --> 01:07:04.600]   wir arbeiten hier in einer Welt fürs erste, ganz ohne Nebenwirkungen.
[01:07:04.600 --> 01:07:08.600]   Also, wir haben die Notwendigkeit, diese Pre-Conditions
[01:07:08.600 --> 01:07:11.600]   und die Post-Conditions auszudrücken.
[01:07:11.600 --> 01:07:14.600]   Und wir wollen das mit den Namen der Variable machen.
[01:07:14.600 --> 01:07:20.600]   Und da hat sich eine Notation eingebürgert, die sich halt so
[01:07:20.600 --> 01:07:23.600]   in vielen Texten eingebürgert hat.
[01:07:23.600 --> 01:07:27.600]   Und zwar gibt es da zwei Notationen, also entweder
[01:07:27.600 --> 01:07:32.600]   als Kommentar in Java oder in vielen Texten verwendet man,
[01:07:32.600 --> 01:07:36.600]   da man keine bessere Idee hatte, wieder geschweifte Klammern.
[01:07:36.600 --> 01:07:39.600]   Die geschweiften Klammern wurden halt immer wieder verwendet.
[01:07:39.600 --> 01:07:42.600]   So, wenn wir jetzt geschweifte Klammern verwenden,
[01:07:42.600 --> 01:07:44.600]   ist es natürlich kein Java mehr.
[01:07:44.600 --> 01:07:49.600]   Aber wenn ich es also ausdrücken möchte, dass dieses W kleiner als -59 sein will,
[01:07:49.600 --> 01:07:53.600]   dann würde das eben in vielen Texten so ausgedrückt werden,
[01:07:53.600 --> 01:07:56.600]   dass wir eben hier diese sich öffnende Klammer haben,
[01:07:56.600 --> 01:08:00.600]   diese sich schließende Klammer und dazwischen die logische Aussage.
[01:08:00.600 --> 01:08:06.600]   Die logische Aussage, die wir hier machen, das ist kein Java Code.
[01:08:06.600 --> 01:08:11.600]   Wir verwenden zwar Java-Operatoren oder aus dem Artikel bekannte Operatoren,
[01:08:11.600 --> 01:08:13.600]   aber das ist kein Java-Programm.
[01:08:13.600 --> 01:08:16.600]   Das ist aber eine logische Aussage.
[01:08:16.600 --> 01:08:19.600]   Deswegen könnten Sie hier auch meinetwegen schreiben x,
[01:08:19.600 --> 01:08:24.600]   kleiner, y, kleiner, z, was Sie in Java nicht machen dürfen.
[01:08:24.600 --> 01:08:29.600]   Als Java wäre das nicht erlaubt, aber als logische Aussage wäre das
[01:08:29.600 --> 01:08:31.600]   im Prinzip erlaubt.
[01:08:31.600 --> 01:08:34.600]   Aber Sie können es auch natürlich anders schreiben,
[01:08:34.600 --> 01:08:36.600]   wenn wir auch noch andere Wege sehen.
[01:08:36.600 --> 01:08:39.600]   Also, wenn ich das hier habe und da habe ich danach,
[01:08:39.600 --> 01:08:44.600]   nachdem ich das jetzt gemacht habe, habe ich eben dann hier wieder die Aussage,
[01:08:44.600 --> 01:08:48.600]   wo ich jetzt sage, wenn eben W kleiner als -59 ist,
[01:08:48.600 --> 01:08:53.600]   dann weiß ich, dass W plus x muss kleiner als -42 sein.
[01:08:53.600 --> 01:08:57.600]   Also, das ist ein Weg, wie man diese, wie viele Texte
[01:08:57.600 --> 01:09:04.600]   und viele andere Lehrbücher solche Aussagen festhalten.
[01:09:04.600 --> 01:09:10.600]   Deswegen, wenn Sie mal da reingucken, dann können Sie, werden Sie das finden.
[01:09:10.600 --> 01:09:14.600]   Jetzt in Java gäbe es die Möglichkeit, Kommentar zu machen, zu geben.
[01:09:14.600 --> 01:09:17.600]   Oder es gäbe eine andere Möglichkeit.
[01:09:17.600 --> 01:09:19.600]   Es gibt nämlich in Java ein Statement,
[01:09:19.600 --> 01:09:22.600]   mit dem ich solche Aussagen ausdrücken kann.
[01:09:22.600 --> 01:09:24.600]   Das ist das Assert Statement.
[01:09:24.600 --> 01:09:29.600]   Das Assert Statement hat das Keyword Assert und dann folgt ein Ausdruck.
[01:09:29.600 --> 01:09:33.600]   Und das ist ein logischer Ausdruck nach den Java-Regeln.
[01:09:33.600 --> 01:09:37.600]   Also, dann natürlich ohne diese geschweiften Krammern.
[01:09:37.600 --> 01:09:41.600]   Also, zum Beispiel könnten Sie sagen Assert x größer als 0.
[01:09:41.600 --> 01:09:46.600]   Nun, das Assert Statement hat eine andere Probleme.
[01:09:46.600 --> 01:09:52.600]   Wenn dieses Assert Statement eingeschaltet ist,
[01:09:52.600 --> 01:09:54.600]   dann ist das wichtig.
[01:09:54.600 --> 01:09:58.600]   Und zur Laufzeit, dieser Ausdruck nicht gültig ist,
[01:09:58.600 --> 01:10:01.600]   dann wird eine Laufzeitfehler generiert.
[01:10:01.600 --> 01:10:07.600]   Jetzt da eben das Java Assert Statement muss eingeschaltet sein.
[01:10:07.600 --> 01:10:14.600]   Wenn aktiviert, und das ist halt nicht von der Sprache geregelt,
[01:10:14.600 --> 01:10:19.600]   wann das aktiviert, dann entscheiden Sie als Programmiererin oder Programmierer.
[01:10:19.600 --> 01:10:22.600]   Und deswegen ist das so ein bisschen heikel,
[01:10:22.600 --> 01:10:25.600]   weil je nachdem, wo Sie sind, funktioniert das mal so oder mal anders.
[01:10:25.600 --> 01:10:30.600]   Deswegen da auch fast alle Texte, die wir kennen,
[01:10:30.600 --> 01:10:34.600]   diese geschweiften Klammern verwenden, verwenden wir auch diese Zeichen.
[01:10:34.600 --> 01:10:40.600]   Die rechtfertige dafür ist, dass letztlich das, was ich Ihnen hier erzähle,
[01:10:40.600 --> 01:10:46.600]   was ich Ihnen hier erzähle, nicht nur für Java,
[01:10:46.600 --> 01:10:51.600]   das können Sie auch für viele andere Statements haben.
[01:10:51.600 --> 01:10:54.600]   Jetzt fragt mich immer, was heißt zur Laufzeit-Expression?
[01:10:54.600 --> 01:10:59.600]   Also, dieses Assert Statement, das Assert Statement war ja so,
[01:10:59.600 --> 01:11:01.600]   jetzt müsste ich kursiv schreiben, kann ich aber nicht.
[01:11:01.600 --> 01:11:03.600]   Schreibe ich eben halt in Violette.
[01:11:03.600 --> 01:11:05.600]   Hier ist eine Expression.
[01:11:05.600 --> 01:11:09.600]   Hier ist das Assert Statement, das ist mein Assert Statement.
[01:11:09.600 --> 01:11:13.600]   Und das wird jetzt, wenn Asserts aktiviert sind,
[01:11:13.600 --> 01:11:17.600]   wird zur Laufzeit dieser Ausdruck ausgewertet.
[01:11:17.600 --> 01:11:22.600]   Und wenn der nicht wahr ist, dann gibt es, wenn der also nicht wahr ist,
[01:11:22.600 --> 01:11:26.600]   dann gibt es hier eine Laufzeit-Feder genauso,
[01:11:26.600 --> 01:11:28.600]   als ob Sie durch null dividiert hätten.
[01:11:28.600 --> 01:11:32.600]   Und dann gibt es eben, dann erreichen Sie nicht den Punkt des nächsten Statements,
[01:11:32.600 --> 01:11:37.600]   aber das Statement, dann ist die Ausführung im Allgemeinen da zu Ende.
[01:11:37.600 --> 01:11:41.600]   Also, das so funktioniert, das Assert Statement,
[01:11:41.600 --> 01:11:46.600]   das ist eben ein, nicht etwas, was Sie beim Lesen des Programms prüfen,
[01:11:46.600 --> 01:11:50.600]   sondern das wird erst geprüft, wenn das Programm ausgeführt wird.
[01:11:50.600 --> 01:11:55.600]   Aber wir wollen ja uns sowas angucken, ohne das Programm eventuell ausführen zu müssen.
[01:11:55.600 --> 01:11:59.600]   Und eben da fast alle anderen diese geschweiften Klammern verwenden,
[01:11:59.600 --> 01:12:01.600]   werden wir die auch verwenden.
[01:12:01.600 --> 01:12:05.600]   Also, ich hoffe, das hat das jetzt beantwortet.
[01:12:05.600 --> 01:12:10.600]   Das ist der Grund, warum wir auch mit den geschweiften Klammern arbeiten.
[01:12:10.600 --> 01:12:15.600]   Und diese geschweiften Klammern werden jetzt praktisch zusammengefasst mit einem Statement.
[01:12:15.600 --> 01:12:19.600]   Also, ich habe hier in geschweiften Klammern die Pre-Condition,
[01:12:19.600 --> 01:12:22.600]   das ist das, was davor gelten muss.
[01:12:22.600 --> 01:12:26.600]   Dann habe ich danach auch wieder in geschweiften Klammern die Post-Condition,
[01:12:26.600 --> 01:12:29.600]   auch eine logische Aussage, die Post-Condition.
[01:12:29.600 --> 01:12:34.600]   Und dann habe ich hier in der Mitte, es ist jetzt erstmal das Programmsegment,
[01:12:34.600 --> 01:12:37.600]   das ist zurzeit ein einziges Statement.
[01:12:37.600 --> 01:12:39.600]   So schreibe ich das auf.
[01:12:39.600 --> 01:12:44.600]   Ich habe hier, wenn diese Pre-Condition gilt und das Statement ausgeführt wurde
[01:12:44.600 --> 01:12:49.600]   und das Statement keine Probleme hatte, sondern zu Ende ausgeführt wurde,
[01:12:49.600 --> 01:12:52.600]   dann gilt danach die Post-Condition.
[01:12:52.600 --> 01:12:54.600]   So müssen Sie das lesen.
[01:12:54.600 --> 01:13:01.600]   Und wenn das der Fall ist, dann sagen wir, dieses Triple,
[01:13:01.600 --> 01:13:04.600]   dieses Hortrippel ist gültig.
[01:13:04.600 --> 01:13:09.600]   Und es gilt dann, wenn für jeden Zustand, für den P-Gültig ist,
[01:13:09.600 --> 01:13:14.600]   ergibt die Ausführung von S immer einen Zustand, in dem Q-Gültig ist.
[01:13:14.600 --> 01:13:18.600]   Oder informell gesagt, wenn P vor der Ausführung von S war,
[01:13:18.600 --> 01:13:22.600]   dann ist Q nach der Ausführung von S war.
[01:13:22.600 --> 01:13:26.600]   Das sagt uns dieses Triple, dieses Triple fast zusammen,
[01:13:26.600 --> 01:13:32.600]   was eben halt, wenn vorher P gilt, nachher nach der Ausführung,
[01:13:32.600 --> 01:13:34.600]   dann gilt nachher Q.
[01:13:34.600 --> 01:13:38.600]   Das ist das System, das wir hier haben.
[01:13:38.600 --> 01:13:44.600]   Und wenn das eben nicht gültig ist, dann sagen wir, das Hortrippel ist ungültig.
[01:13:44.600 --> 01:13:48.600]   Jetzt werden wir gleich Beispiele sehen von Gültig und Ungültigem-Trippel,
[01:13:48.600 --> 01:13:52.600]   weil das eben halt wichtig ist für unser Verstehen.
[01:13:52.600 --> 01:13:59.600]   Also, das heißt, wenn wir eben diese so einen Triple haben,
[01:13:59.600 --> 01:14:07.600]   PS und Q, dann, wenn P vorher war, dann muss Q nachher war sein.
[01:14:07.600 --> 01:14:10.600]   Und jetzt haben wir bisher ziemlich informell gemacht.
[01:14:10.600 --> 01:14:15.600]   Aber das Schöne ist, für jedes Java-Statement gibt es eine genaue Regel,
[01:14:15.600 --> 01:14:20.600]   oder genaue Regeln, die die Pry- und Post-Condition in Beziehung setzen.
[01:14:20.600 --> 01:14:22.600]   Also, es gibt eine Regel für Zuweisungen.
[01:14:22.600 --> 01:14:25.600]   Es gibt eine Regel für zwei aufeinanderfolgende Anweisungen.
[01:14:25.600 --> 01:14:29.600]   Wenn ich eine Regel für zwei aufeinanderfolgende Anweisungen habe,
[01:14:29.600 --> 01:14:33.600]   kann ich auf diese Weise auch drei aufeinanderfolgende Anweisungen haben.
[01:14:33.600 --> 01:14:37.600]   Weil erst habe ich hier zwei, und danach habe ich die beiden wieder zwei Anweisungen.
[01:14:37.600 --> 01:14:39.600]   Also, kann ich diese Regeln benutzen,
[01:14:39.600 --> 01:14:42.600]   aus der Regel für ein einziges Statement,
[01:14:42.600 --> 01:14:46.600]   kann ich dann eben Regeln für einen Codeblock herausbekommen.
[01:14:46.600 --> 01:14:50.600]   Es wird Regeln geben für Verzweigungen, die wir noch nicht gesehen haben,
[01:14:50.600 --> 01:14:53.600]   und wir werden später auch Regeln verschleifen kennenlernen.
[01:14:53.600 --> 01:14:56.600]   Also, das habe ich jetzt aber hier für heute.
[01:14:56.600 --> 01:14:59.600]   Ich muss leider meinen Computer nicht überschneller geworden,
[01:14:59.600 --> 01:15:04.600]   als ich dachte, weil eben der Clicker nicht funktioniert hat.
[01:15:04.600 --> 01:15:08.600]   Und jetzt weiß ich nicht, ob ich Ihnen den nächsten Update zu wählen will.
[01:15:08.600 --> 01:15:09.600]   Danke schön.
[01:15:09.600 --> 01:15:11.600]   Ob ich jetzt noch die nächsten zehn Minuten nutzen soll,
[01:15:11.600 --> 01:15:13.600]   um Ihnen mehr Beispiele zu zeigen,
[01:15:13.600 --> 01:15:16.600]   oder ob Sie ins Wochenende gehen wollen.
[01:15:16.600 --> 01:15:21.600]   Wir fragen mal so, wem gehe ich überhaupt zu schnell voran?
[01:15:21.600 --> 01:15:26.600]   Okay, wem gehe ich zu langsam voran?
[01:15:26.600 --> 01:15:29.600]   Wer hat Angst, sich zu melden?
[01:15:29.600 --> 01:15:36.600]   Okay, weh gehe ich denn genau richtig voran?
[01:15:36.600 --> 01:15:40.600]   Also, wenn Sie wollen, kann ich jetzt noch die nächste Sache raushaben.
[01:15:40.600 --> 01:15:42.600]   Ich denke mir, ja, tut mir leid,
[01:15:42.600 --> 01:15:45.600]   ich kann noch mal versuchen, die Clicker-Frage heute
[01:15:45.600 --> 01:15:47.600]   mit den Strings aufzuschalten.
[01:15:47.600 --> 01:15:49.600]   Vielleicht funktioniert die ja doch jetzt.
[01:15:49.600 --> 01:15:53.600]   Also, probieren wir den Clicker mit den String-Operationen.
[01:15:53.600 --> 01:15:57.600]   Ob der funktioniert, gucken wir mal.
[01:15:57.600 --> 01:16:05.600]   So, jetzt, ja, das müsste ich jetzt hier.
[01:16:05.600 --> 01:16:11.600]   So, also, wenn Sie wollen, helfen Sie uns mit, das System zu debaggen.
[01:16:11.600 --> 01:16:16.600]   Also, geben Sie die Antwort für die restlichen Operationen
[01:16:16.600 --> 01:16:20.600]   auf eine Zeile an, ohne diese Hochkommer.
[01:16:20.600 --> 01:16:26.600]   Also, wenn die Antwort wäre, wenn der String 3xY wäre,
[01:16:26.600 --> 01:16:33.600]   dann schreiben Sie bitte als Antwort 3xY in den Clicker herein.
[01:16:33.600 --> 01:16:35.600]   Das sollten wir gucken, ob es funktioniert.
[01:16:35.600 --> 01:16:38.600]   Ich habe jetzt funktioniert, das ist auf meinem Computer hier.
[01:16:38.600 --> 01:16:40.600]   Ich kann also sehen, dass er läuft.
[01:16:40.600 --> 01:16:43.600]   Ich sehe, auch eine Person hat schon abgestimmt.
[01:16:43.600 --> 01:16:46.600]   Also, geben Sie die vier Antworten dafür ein.
[01:16:46.600 --> 01:16:49.600]   Es ist wirklich nicht schwierig, aber gibt Ihnen die Chance,
[01:16:49.600 --> 01:16:54.600]   das nochmal auszuprobieren.
[01:16:54.600 --> 01:16:59.600]   Und ja, ich tut mir leid, dass ich den interessanteren Clicker
[01:16:59.600 --> 01:17:01.600]   mit den Zuweisungen nicht machen konnte,
[01:17:01.600 --> 01:17:04.600]   aber dann können wir den jetzt noch machen.
[01:17:04.600 --> 01:17:10.600]   Okay, ich habe 178 Antworten.
[01:17:10.600 --> 01:17:14.600]   Na, kommen noch ein paar mehr.
[01:17:14.600 --> 01:17:18.600]   Aber...
[01:17:18.600 --> 01:17:24.600]   Okay, machen wir...
[01:17:24.600 --> 01:17:30.600]   Ja, hier sehen Sie die Ergebnisse, weiß ich nicht.
[01:17:30.600 --> 01:17:34.600]   Also, hier, gerade noch...
[01:17:34.600 --> 01:17:37.600]   Ich weiß nicht, können Sie die Antworten sehen auf Ihrem Clicker?
[01:17:37.600 --> 01:17:42.600]   Also, ich sehe sie bei mir, aber weiß ich, sehen Sie die auch?
[01:17:42.600 --> 01:17:44.600]   Ich müsste die...
[01:17:44.600 --> 01:17:47.600]   Das können wir ja...
[01:17:47.600 --> 01:17:52.600]   Das ja dadurch machen, dass wir die jetzt...
[01:17:52.600 --> 01:17:54.600]   So, gucken wir mal.
[01:17:54.600 --> 01:17:59.600]   Magie.
[01:17:59.600 --> 01:18:01.600]   Ja, funktioniert.
[01:18:01.600 --> 01:18:04.600]   Also, hier sehen Sie die Antworten, wie ich sie habe.
[01:18:04.600 --> 01:18:06.600]   Ja, aber jetzt kann ich natürlich nicht mehr die anderen zeigen.
[01:18:06.600 --> 01:18:09.600]   Früher hatte ich zwei Projektoren, aber hat man mir nicht erkannt.
[01:18:09.600 --> 01:18:11.600]   So, ein Punkt noch nebenbei.
[01:18:11.600 --> 01:18:16.600]   Wenn wir sagen, eine Antwort auf eine Zeile,
[01:18:16.600 --> 01:18:19.600]   dann meinen wir das so auf eine Zeile.
[01:18:19.600 --> 01:18:22.600]   Das ist...
[01:18:22.600 --> 01:18:24.600]   Die meisten von Ihnen wahrscheinlich haben...
[01:18:24.600 --> 01:18:26.600]   Habe ich das sogar selber falsch gesagt,
[01:18:26.600 --> 01:18:28.600]   dass Sie sagten, eine pro Zeile.
[01:18:28.600 --> 01:18:32.600]   Es ist für uns leichter, wenn wir die alle pro Zeile haben.
[01:18:32.600 --> 01:18:37.600]   Also, ich sehe, die meisten von Ihnen haben das erfreulicherweise richtig.
[01:18:37.600 --> 01:18:40.600]   Das ist natürlich...
[01:18:40.600 --> 01:18:43.600]   Ja, sehen Sie, das ist nicht ganz richtig.
[01:18:43.600 --> 01:18:46.600]   Wir haben zwar nie gesagt, wie viele Leerzeichen Sie brauchen,
[01:18:46.600 --> 01:18:51.600]   aber ein Leerzeichen ist dann doch erforderlich, mindestens eins.
[01:18:51.600 --> 01:18:53.600]   Das ist ja...
[01:18:53.600 --> 01:18:55.600]   Wir freuen uns immer wieder, wenn es kreative Lösungen gibt.
[01:18:55.600 --> 01:18:57.600]   Das ist wichtig.
[01:18:57.600 --> 01:18:59.600]   Da oben hat jemand Kommas verwendet.
[01:18:59.600 --> 01:19:02.600]   Kommas wollten wir nicht haben.
[01:19:02.600 --> 01:19:04.600]   Wir hatten nicht... Bitte machen Sie es nicht.
[01:19:04.600 --> 01:19:08.600]   Wenn ich mir das angucke, ich bin in der Lage, die Kommas zu ignorieren.
[01:19:08.600 --> 01:19:10.600]   Wenn wir ein Computer haben, der das anpuckt,
[01:19:10.600 --> 01:19:13.600]   der schüttelt den Kopf und gibt Ihnen nicht die Punkte.
[01:19:13.600 --> 01:19:15.600]   Also, bitte, wir müssen daran arbeiten,
[01:19:15.600 --> 01:19:18.600]   dass wir alle ganz genau sagen, was wir wollen
[01:19:18.600 --> 01:19:21.600]   und Sie müssen ganz genau lesen, was wir wollen.
[01:19:21.600 --> 01:19:24.600]   Also, wünsche Ihnen schönes Wochenende
[01:19:24.600 --> 01:19:26.600]   und bis Dienstag.
[01:19:26.600 --> 01:19:28.600]   (Beifall)
[01:19:28.600 --> 01:19:29.880]   (Applaus)

