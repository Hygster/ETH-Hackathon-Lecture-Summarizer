
[00:00:00.000 --> 00:00:02.000]   Okay, good morning.
[00:00:02.000 --> 00:00:10.000]   So, this week we'll continue talking about transformations on images.
[00:00:10.000 --> 00:00:13.000]   So we saw last week the Fourier transform.
[00:00:13.000 --> 00:00:18.000]   We'll quickly go through some of that now,
[00:00:18.000 --> 00:00:25.000]   but we'll continue then with other types of transformations of images.
[00:00:25.000 --> 00:00:34.000]   And today we'll focus on transformations that, you know,
[00:00:34.000 --> 00:00:36.000]   so we'll focus on unitary transformations,
[00:00:36.000 --> 00:00:47.000]   so those are transformations that at some level are a change of basis in going from pixels.
[00:00:47.000 --> 00:00:50.000]   We went to the Fourier space, the frequency space.
[00:00:50.000 --> 00:00:58.000]   Here we'll look at this lecture more specifically at transformations that, you know,
[00:00:58.000 --> 00:01:09.000]   are aligned to a particular type of images that are specifically suited for solving some problems on a particular set of images.
[00:01:09.000 --> 00:01:17.000]   Then next week, sorry, on Thursday, we'll then finish that and continue with image representations,
[00:01:17.000 --> 00:01:24.000]   more generic image representations that are useful for compression of images,
[00:01:24.000 --> 00:01:30.000]   and so compressed image representations, specifically lossy compression.
[00:01:30.000 --> 00:01:36.000]   So where we can represent images in a way that they look the same to us, to our eyes,
[00:01:36.000 --> 00:01:40.000]   but actually, you know, need a lot less bits to represent.
[00:01:40.000 --> 00:01:45.000]   Okay, and so for that we'll also use several types of transformations.
[00:01:45.000 --> 00:01:49.000]   What did we see last week? Of course, first the Fourier transform,
[00:01:49.000 --> 00:01:56.000]   but then beyond that, on Thursday, we saw in particular the convolution theorem,
[00:01:56.000 --> 00:02:01.000]   again, very important for in two directions.
[00:02:01.000 --> 00:02:12.000]   So first, that a convolution in the image domain, in the spatial domain,
[00:02:12.000 --> 00:02:16.000]   corresponds to, once you go to the Fourier domain,
[00:02:16.000 --> 00:02:26.000]   corresponds simply to a frequency per frequency multiplication of the frequency content in the image
[00:02:26.000 --> 00:02:31.000]   with the equivalent frequency content, you know, the ratio of preservation
[00:02:31.000 --> 00:02:36.000]   and also, let's say, the shift in phase given by the filter.
[00:02:36.000 --> 00:02:42.000]   So instead of having to do a convolution over the whole image
[00:02:42.000 --> 00:02:49.000]   with your filter kernel and apply that, you know, kind of consistently over the whole image,
[00:02:49.000 --> 00:02:55.000]   here you can essentially just look at every frequency in isolation
[00:02:55.000 --> 00:02:57.000]   and look at what happens to this frequency.
[00:02:57.000 --> 00:03:00.000]   Oh, you know, I just get multiplied by this factor and so on.
[00:03:00.000 --> 00:03:05.000]   So essentially, we get a very simple view and understanding of filtering.
[00:03:05.000 --> 00:03:07.000]   We saw how we could use this.
[00:03:07.000 --> 00:03:10.000]   For example, in this case here, for image restoration,
[00:03:10.000 --> 00:03:15.000]   this is our kernel in the spatial domain.
[00:03:15.000 --> 00:03:19.000]   Sorry, this is our kernel in the frequency domain.
[00:03:19.000 --> 00:03:23.000]   This was the equivalent of a block function in the image space
[00:03:23.000 --> 00:03:29.000]   that would describe this blurring operation, motion blurring of horizontal motion.
[00:03:29.000 --> 00:03:33.000]   This was what happened to each frequency in the frequency domain,
[00:03:33.000 --> 00:03:36.000]   and then we can, as best as we can, invert that.
[00:03:36.000 --> 00:03:41.000]   Here it's really just looking at, okay, this function got multiplied by 0.2.
[00:03:41.000 --> 00:03:44.000]   Okay, now I'll multiply it by a factor of 5,
[00:03:44.000 --> 00:03:48.000]   and that will undo the effect of multiplying by 0.2.
[00:03:48.000 --> 00:03:54.000]   And so I determine this, and then I can do the inverse Fourier transform
[00:03:54.000 --> 00:03:59.000]   if I want the convolution filter that I would apply in the spatial domain.
[00:03:59.000 --> 00:04:02.000]   So that's this filtering operation.
[00:04:02.000 --> 00:04:06.000]   We can now do that because the convolution term tells us that it's very simple.
[00:04:06.000 --> 00:04:09.000]   That's the product, and then we can use the product here
[00:04:09.000 --> 00:04:12.000]   because that's easy, one over is kind of easy.
[00:04:12.000 --> 00:04:15.000]   Of course, with the caveat that if it's, you know,
[00:04:15.000 --> 00:04:17.000]   the 0 divided by 0 is, you know,
[00:04:17.000 --> 00:04:20.000]   the divide by 0 cannot be undone,
[00:04:20.000 --> 00:04:25.000]   so we needed some tricks to avoid blowing up noise in those situations.
[00:04:25.000 --> 00:04:27.000]   Okay?
[00:04:27.000 --> 00:04:29.000]   Then the second one,
[00:04:29.000 --> 00:04:33.000]   the second part of the convolution theorem, the reverse way,
[00:04:33.000 --> 00:04:39.000]   is essentially something we use to mathematically represent sampling,
[00:04:39.000 --> 00:04:41.000]   sampling operations.
[00:04:41.000 --> 00:04:46.000]   In particular, in the spatial domain, we do now a product of two functions.
[00:04:46.000 --> 00:04:50.000]   We had to work out a special function, a delta function,
[00:04:50.000 --> 00:04:53.000]   which again is a function that is 0 everywhere,
[00:04:53.000 --> 00:04:56.000]   except taking exactly one point,
[00:04:56.000 --> 00:04:59.000]   but it's determined in such a way,
[00:04:59.000 --> 00:05:02.000]   the size of that peak at that point is determined in such a way
[00:05:02.000 --> 00:05:05.000]   that the integral of that function is equal to 1.
[00:05:05.000 --> 00:05:07.000]   Okay?
[00:05:07.000 --> 00:05:10.000]   That allows us to measure in exactly one location or function,
[00:05:10.000 --> 00:05:12.000]   and then we can actually have a whole train of those,
[00:05:12.000 --> 00:05:16.000]   you know, a whole periodic repetition of those in 1D or in two dimensions,
[00:05:16.000 --> 00:05:18.000]   or in three dimensions if we would, you know,
[00:05:18.000 --> 00:05:22.000]   work in three-dimensional spaces like for medical imaging.
[00:05:22.000 --> 00:05:26.000]   So, for example, in two dimensions, we have all these repeated peaks,
[00:05:26.000 --> 00:05:29.000]   which each individually measure exactly one location,
[00:05:29.000 --> 00:05:31.000]   the function value at exactly one location.
[00:05:31.000 --> 00:05:34.000]   You can observe it by doing the integral,
[00:05:34.000 --> 00:05:40.000]   and do the product of that sampling function with the actual function,
[00:05:40.000 --> 00:05:43.000]   which would rescale the delta function to have an integral now equal
[00:05:43.000 --> 00:05:46.000]   to the function value at exactly that location.
[00:05:46.000 --> 00:05:48.000]   Okay?
[00:05:48.000 --> 00:05:51.000]   So, we can model things that way in a way that we can actually
[00:05:51.000 --> 00:05:55.000]   properly execute the Fourier transform,
[00:05:55.000 --> 00:05:57.000]   because the Fourier transform is based on integrals
[00:05:57.000 --> 00:06:02.000]   of the product of the function with the Fourier basis,
[00:06:02.000 --> 00:06:04.000]   and then do the integral.
[00:06:04.000 --> 00:06:07.000]   So, we can properly model this in the continuous domain
[00:06:07.000 --> 00:06:09.000]   and end up with a discrete representation,
[00:06:09.000 --> 00:06:13.000]   and we see that essentially what happens, you know,
[00:06:13.000 --> 00:06:15.000]   the phenomena like aliasing and so on,
[00:06:15.000 --> 00:06:19.000]   that happen when we do this, when we do sampling,
[00:06:19.000 --> 00:06:23.000]   we can actually now nicely model them going from the continuous domain
[00:06:23.000 --> 00:06:27.000]   to the discrete domain, and having aliasing phenomena and so on show up.
[00:06:27.000 --> 00:06:31.000]   We can understand this now very easily by having the convolutions
[00:06:31.000 --> 00:06:34.000]   of the sampling function.
[00:06:34.000 --> 00:06:37.000]   So, the product of the sampling function, the spatial domain,
[00:06:37.000 --> 00:06:41.000]   becomes a convolution of the sampling function transformed
[00:06:41.000 --> 00:06:44.000]   in the Fourier domain, and the actual signal function,
[00:06:44.000 --> 00:06:47.000]   the one we cared about that we tried to sample,
[00:06:47.000 --> 00:06:49.000]   also transformed in the Fourier domain,
[00:06:49.000 --> 00:06:51.000]   and we have a convolution of those.
[00:06:51.000 --> 00:06:55.000]   Remember this was where if the spectra,
[00:06:55.000 --> 00:06:57.000]   which typically have a lot of low frequency,
[00:06:57.000 --> 00:06:59.000]   but then have also some high frequencies,
[00:06:59.000 --> 00:07:03.000]   if those spectra, as we convolve them with these spikes,
[00:07:03.000 --> 00:07:06.000]   again the Fourier transform of this spike train,
[00:07:06.000 --> 00:07:09.000]   or spike bed kind of all these peaks,
[00:07:09.000 --> 00:07:13.000]   the Fourier transform of that was also essentially a set of these peaks
[00:07:13.000 --> 00:07:17.000]   in the Fourier domain, and the closer we put them together
[00:07:17.000 --> 00:07:22.000]   in one in the spatial domain, the further apart they were in the frequency domain,
[00:07:22.000 --> 00:07:25.000]   when they're far apart, those copies of these blobs
[00:07:25.000 --> 00:07:29.000]   that represent the signal are far enough apart that they don't overlap,
[00:07:29.000 --> 00:07:33.000]   but if you sample not fast enough in the spatial domain,
[00:07:33.000 --> 00:07:36.000]   you move things farther apart, you sample in the spatial domain,
[00:07:36.000 --> 00:07:39.000]   it means that in a frequency domain they come closer together,
[00:07:39.000 --> 00:07:42.000]   and then these things start overlapping,
[00:07:42.000 --> 00:07:48.000]   the signals start overlapping with its copy kind of coming over from the sampling function,
[00:07:48.000 --> 00:07:53.000]   and then you get essentially, this is what you see here,
[00:07:53.000 --> 00:07:55.000]   then you would have, if you don't do things properly,
[00:07:55.000 --> 00:07:57.000]   those things would overlap, they would add up,
[00:07:57.000 --> 00:08:01.000]   and then when you try to filter away things,
[00:08:01.000 --> 00:08:04.000]   you would be left with essentially a mess here
[00:08:04.000 --> 00:08:06.000]   because you have part of the signal overlapping here,
[00:08:06.000 --> 00:08:10.000]   and you get a blend, and you get some high frequencies that show up as low frequencies
[00:08:10.000 --> 00:08:14.000]   after your filtering operation, after your reconstruction operation essentially.
[00:08:14.000 --> 00:08:18.000]   So that's why the second part, there is sampling,
[00:08:18.000 --> 00:08:22.000]   the convolution term in the other direction is important for us,
[00:08:22.000 --> 00:08:25.000]   very quickly the digital processing pipeline,
[00:08:25.000 --> 00:08:28.000]   you guys have something interesting to tell?
[00:08:28.000 --> 00:08:30.000]   No? Okay.
[00:08:30.000 --> 00:08:32.000]   Then you can wait for outside lecture today.
[00:08:32.000 --> 00:08:34.000]   Okay, so digital processing,
[00:08:34.000 --> 00:08:40.000]   so we start from a high frequency, from an unlimited, not band limited signal,
[00:08:40.000 --> 00:08:43.000]   before we sample it,
[00:08:43.000 --> 00:08:46.000]   when we know that we're going to sample at a certain rate,
[00:08:46.000 --> 00:08:49.000]   from this construction or from,
[00:08:49.000 --> 00:08:53.000]   maybe in the Nyquist sampling theorem,
[00:08:53.000 --> 00:08:56.000]   we know that at this sampling rate,
[00:08:56.000 --> 00:08:59.000]   we can only cope with things that have about this width,
[00:08:59.000 --> 00:09:01.000]   so before we sample,
[00:09:01.000 --> 00:09:05.000]   we first have to band limit the signal to avoid aliasing,
[00:09:05.000 --> 00:09:08.000]   so we'll first take the signal, we'll band limit it,
[00:09:08.000 --> 00:09:11.000]   if we're still in the analog domain,
[00:09:11.000 --> 00:09:13.000]   so in a continuous domain,
[00:09:13.000 --> 00:09:17.000]   the way to do that is actually to apply some analog filter,
[00:09:17.000 --> 00:09:20.000]   for example with a camera you would just blur slightly,
[00:09:20.000 --> 00:09:24.000]   enough so that you suppress these high frequency spikes,
[00:09:24.000 --> 00:09:26.000]   so you get something like this,
[00:09:26.000 --> 00:09:28.000]   you are band limited,
[00:09:28.000 --> 00:09:31.000]   now as you sample, you avoid the overlap, you're good,
[00:09:31.000 --> 00:09:33.000]   and then for reconstruction,
[00:09:33.000 --> 00:09:37.000]   you essentially, for example, here have this perfect reconstruction filter,
[00:09:37.000 --> 00:09:41.000]   in practice we might have one that has a little bit more of a slope here,
[00:09:41.000 --> 00:09:46.000]   but in exchange has little less extent here in the spatial domain.
[00:09:46.000 --> 00:09:49.000]   Okay, so that's what we had last week,
[00:09:49.000 --> 00:09:52.000]   any questions still for that?
[00:09:52.000 --> 00:09:54.000]   Anyone?
[00:09:54.000 --> 00:09:58.000]   Okay, so then this week,
[00:09:58.000 --> 00:10:02.000]   we'll talk about other transformations and Fourier transform,
[00:10:02.000 --> 00:10:05.000]   Fourier transform actually one example of these unitary transforms,
[00:10:05.000 --> 00:10:08.000]   so let's look more in general,
[00:10:08.000 --> 00:10:13.000]   so we saw images can essentially are really digital images,
[00:10:13.000 --> 00:10:18.000]   are represented as a matrix typically,
[00:10:18.000 --> 00:10:22.000]   as a two dimensional arrangement of measurements,
[00:10:22.000 --> 00:10:26.000]   but of course we can also just rewrite this,
[00:10:26.000 --> 00:10:29.000]   rearrange those numbers in a single vector,
[00:10:29.000 --> 00:10:32.000]   a very long vector of course, right?
[00:10:32.000 --> 00:10:36.000]   If this is a thousand by thousand pixel image,
[00:10:36.000 --> 00:10:40.000]   let's say just a grayscale image of just one dimension,
[00:10:40.000 --> 00:10:44.000]   then here we'd have a million dimensional vector space,
[00:10:44.000 --> 00:10:48.000]   and then in that vector space,
[00:10:48.000 --> 00:10:50.000]   a point in that vector space,
[00:10:50.000 --> 00:10:54.000]   so a vector is now represents a full image,
[00:10:54.000 --> 00:10:58.000]   and it has a million dimensions in that vector space.
[00:10:58.000 --> 00:11:08.000]   Now, if we revisit briefly what are linear operators,
[00:11:08.000 --> 00:11:11.000]   so linear image processing,
[00:11:11.000 --> 00:11:15.000]   essentially any linear image processing can be written as follows,
[00:11:15.000 --> 00:11:21.000]   as here, as you have this very long vector,
[00:11:21.000 --> 00:11:23.000]   say a million dimensional,
[00:11:23.000 --> 00:11:28.000]   multiplies with million by million matrix for example,
[00:11:28.000 --> 00:11:31.000]   and gives you a vector, gay,
[00:11:31.000 --> 00:11:33.000]   that is now also million dimensional.
[00:11:33.000 --> 00:11:37.000]   This matrix doesn't necessarily have to be square,
[00:11:37.000 --> 00:11:39.000]   say it could be a million,
[00:11:39.000 --> 00:11:41.000]   if this is a vector of a million,
[00:11:41.000 --> 00:11:44.000]   then of course the width of that matrix is a million,
[00:11:44.000 --> 00:11:50.000]   but let's say if it's an operation that will filter and subsample
[00:11:50.000 --> 00:11:54.000]   to have the resolution in both directions,
[00:11:54.000 --> 00:11:57.000]   then gay could for example also be 250,000 in that case, right?
[00:11:57.000 --> 00:12:00.000]   If you start from a million, you divide by four pixels,
[00:12:00.000 --> 00:12:02.000]   the pixels you get,
[00:12:02.000 --> 00:12:06.000]   but it could be a combination of both the filtering and the subsampling,
[00:12:06.000 --> 00:12:08.000]   that's a linear operation,
[00:12:08.000 --> 00:12:11.000]   that would essentially also be written as a big matrix,
[00:12:11.000 --> 00:12:13.000]   you could write it in a big matrix,
[00:12:13.000 --> 00:12:15.000]   with of course a lot of structure,
[00:12:15.000 --> 00:12:17.000]   because it would be your convolution kernel,
[00:12:17.000 --> 00:12:19.000]   let's say with your Gaussian,
[00:12:19.000 --> 00:12:22.000]   at every, you know, split out in every location for exactly,
[00:12:22.000 --> 00:12:25.000]   for this pixel, these are the convolution,
[00:12:25.000 --> 00:12:28.000]   the pixels that get affected by the convolution, etc.
[00:12:28.000 --> 00:12:30.000]   So you get a huge matrix, huge sparse matrix,
[00:12:30.000 --> 00:12:33.000]   if you have a small kernel, only a few non-zeros, right?
[00:12:33.000 --> 00:12:36.000]   So to get to compute one output,
[00:12:36.000 --> 00:12:39.000]   you really only have the few pixels affected by the kernel,
[00:12:39.000 --> 00:12:41.000]   touched by the kernel,
[00:12:41.000 --> 00:12:43.000]   would be the ones that have a non-zero coefficient here,
[00:12:43.000 --> 00:12:46.000]   so that's an example of how this matrix could look like
[00:12:46.000 --> 00:12:50.000]   to represent that particular type of homography,
[00:12:50.000 --> 00:12:53.000]   of operator.
[00:12:53.000 --> 00:12:59.000]   So if it's a linear operator,
[00:12:59.000 --> 00:13:02.000]   it needs to satisfy here this particular constraint here,
[00:13:02.000 --> 00:13:04.000]   okay?
[00:13:04.000 --> 00:13:06.000]   So it means that your operator here,
[00:13:06.000 --> 00:13:10.000]   applied to function, to, you know, a vector f1,
[00:13:10.000 --> 00:13:13.000]   operator applied to vector f2,
[00:13:13.000 --> 00:13:17.000]   multiplied with some coefficients here,
[00:13:17.000 --> 00:13:19.000]   so you apply the operator to f1,
[00:13:19.000 --> 00:13:21.000]   you apply the operator to f2,
[00:13:21.000 --> 00:13:24.000]   you multiply them each with a coefficient alpha_1, alpha_2,
[00:13:24.000 --> 00:13:29.000]   that's for every choice of f1 and f2 in that space,
[00:13:29.000 --> 00:13:32.000]   and every choice of alpha_1 and alpha_2,
[00:13:32.000 --> 00:13:34.000]   this should be valid.
[00:13:34.000 --> 00:13:38.000]   That if you do the first linear combination,
[00:13:38.000 --> 00:13:43.000]   and then compute the output, the linear operator,
[00:13:43.000 --> 00:13:46.000]   or vice versa, you first apply the operator
[00:13:46.000 --> 00:13:48.000]   on the individual vectors,
[00:13:48.000 --> 00:13:50.000]   and then apply the linear transformation,
[00:13:50.000 --> 00:13:53.000]   that those are essentially, they commute,
[00:13:53.000 --> 00:13:57.000]   they're equal for every, for all scalars,
[00:13:57.000 --> 00:14:00.000]   and for all vectors, okay?
[00:14:00.000 --> 00:14:02.000]   So if this is the case, then that's the definition
[00:14:02.000 --> 00:14:04.000]   of a linear operator, okay?
[00:14:04.000 --> 00:14:07.000]   And so that, for example, is a linear operator, okay?
[00:14:07.000 --> 00:14:11.000]   Almost all image processing systems
[00:14:11.000 --> 00:14:13.000]   contain at least some of those linear operators.
[00:14:13.000 --> 00:14:16.000]   For example, you know, deep neural networks,
[00:14:16.000 --> 00:14:18.000]   well, they have a lot of convolutional operators,
[00:14:18.000 --> 00:14:20.000]   for example, those are linear operators,
[00:14:20.000 --> 00:14:23.000]   and then on the output of this,
[00:14:23.000 --> 00:14:25.000]   so you have this, and then they will apply
[00:14:25.000 --> 00:14:27.000]   a nonlinear function, for example.
[00:14:27.000 --> 00:14:35.000]   Okay, so this is how this linear image processing system
[00:14:35.000 --> 00:14:37.000]   looks like, it can always be written in this form.
[00:14:37.000 --> 00:14:39.000]   Now it can often be written in much more compact form,
[00:14:39.000 --> 00:14:42.000]   of course, than having this huge matrix,
[00:14:42.000 --> 00:14:45.000]   because often that huge matrix has a very structured way,
[00:14:45.000 --> 00:14:47.000]   like a convolution, same coefficients
[00:14:47.000 --> 00:14:50.000]   applied systematically throughout the image.
[00:14:50.000 --> 00:14:52.000]   So always the same coefficient showing up,
[00:14:52.000 --> 00:14:56.000]   just showing up at different locations in the rows.
[00:14:56.000 --> 00:15:00.000]   Okay, so the question is how do we choose H?
[00:15:00.000 --> 00:15:03.000]   For example, you could choose it to separate salient features
[00:15:03.000 --> 00:15:05.000]   from the rest of the image signal, okay?
[00:15:05.000 --> 00:15:08.000]   This was when we did feature detection, right?
[00:15:08.000 --> 00:15:11.000]   So we wanted to find corners, for example,
[00:15:11.000 --> 00:15:14.000]   where we would have this filter that looks like a corner,
[00:15:14.000 --> 00:15:16.000]   and we'd apply it on the whole image,
[00:15:16.000 --> 00:15:18.000]   convolve it to the whole image,
[00:15:18.000 --> 00:15:20.000]   and we'd get now a new image that, you know,
[00:15:20.000 --> 00:15:23.000]   highlights that has a strong response where
[00:15:23.000 --> 00:15:27.000]   the local pattern looks like a corner, okay?
[00:15:27.000 --> 00:15:29.000]   So that's one way.
[00:15:29.000 --> 00:15:32.000]   Maybe as a way to make the image look better,
[00:15:32.000 --> 00:15:35.000]   for example, blur it a bit to get rid of noise,
[00:15:35.000 --> 00:15:37.000]   or vice versa, sharpen the image,
[00:15:37.000 --> 00:15:39.000]   depending on what happened to the image before
[00:15:39.000 --> 00:15:42.000]   and what you want to do to fix it.
[00:15:42.000 --> 00:15:48.000]   Also potentially to make game more sparse.
[00:15:48.000 --> 00:15:52.000]   So instead of having, remember, if we have,
[00:15:52.000 --> 00:15:55.000]   this is partially what we did with the Fourier transform,
[00:15:55.000 --> 00:15:59.000]   for example, where we would, for simple images,
[00:15:59.000 --> 00:16:02.000]   that don't just have some wave patterns,
[00:16:02.000 --> 00:16:04.000]   if you do the Fourier transform,
[00:16:04.000 --> 00:16:06.000]   you will then just get those few peaks,
[00:16:06.000 --> 00:16:09.000]   those main patterns to be extracted,
[00:16:09.000 --> 00:16:11.000]   and all of the other frequencies would essentially
[00:16:11.000 --> 00:16:13.000]   end up being zeros.
[00:16:13.000 --> 00:16:17.000]   So this can sometimes be desired,
[00:16:17.000 --> 00:16:20.000]   and we'll look more in detail at that.
[00:16:20.000 --> 00:16:25.000]   So how to only have a few non-zero coefficients, for example.
[00:16:25.000 --> 00:16:30.000]   So now we'll look at unitary transforms.
[00:16:30.000 --> 00:16:36.000]   We'll look in particular, so here we choose,
[00:16:36.000 --> 00:16:40.000]   A, not to be an arbitrary operator here,
[00:16:40.000 --> 00:16:44.000]   linear operator, or matrix,
[00:16:44.000 --> 00:16:48.000]   but we'll actually want that matrix to,
[00:16:48.000 --> 00:16:51.000]   this to be essentially a basis transform,
[00:16:51.000 --> 00:16:54.000]   and in particular a unitary transform.
[00:16:54.000 --> 00:16:58.000]   You can think of this,
[00:16:58.000 --> 00:17:00.000]   so essentially for it to be unitary transform,
[00:17:00.000 --> 00:17:03.000]   first, if this is the size of the image,
[00:17:03.000 --> 00:17:05.000]   then this has to be square,
[00:17:05.000 --> 00:17:08.000]   because it has to be a basis transform.
[00:17:08.000 --> 00:17:11.000]   So if it's a basis transform,
[00:17:11.000 --> 00:17:14.000]   the input and the output dimension need to be the same.
[00:17:14.000 --> 00:17:17.000]   So you have your function,
[00:17:17.000 --> 00:17:19.000]   you multiply it with the square matrix,
[00:17:19.000 --> 00:17:21.000]   and you get coefficients.
[00:17:21.000 --> 00:17:24.000]   So therefore the matrix has to be mn times mn
[00:17:24.000 --> 00:17:26.000]   in terms of dimensions,
[00:17:26.000 --> 00:17:29.000]   with m times n being the size of the image.
[00:17:29.000 --> 00:17:31.000]   So these are big matrices, of course.
[00:17:31.000 --> 00:17:34.000]   And so the transform is unitary,
[00:17:34.000 --> 00:17:37.000]   if and only if the inverse of this matrix,
[00:17:37.000 --> 00:17:40.000]   if it's a basis, remember it has to be invertible for starters.
[00:17:40.000 --> 00:17:42.000]   But here we want something special from the inverse.
[00:17:42.000 --> 00:17:48.000]   We want the inverse to be equal to the,
[00:17:48.000 --> 00:17:51.000]   essentially to the transpose,
[00:17:51.000 --> 00:17:55.000]   but also essentially here with a star,
[00:17:55.000 --> 00:17:57.000]   that means that actually,
[00:17:57.000 --> 00:18:01.000]   so if this is a real matrix,
[00:18:01.000 --> 00:18:03.000]   only real numbers,
[00:18:03.000 --> 00:18:06.000]   then it's just a transpose.
[00:18:06.000 --> 00:18:08.000]   This is what you have with the rotation matrix.
[00:18:08.000 --> 00:18:11.000]   The inverse of a rotation matrix is just this transpose.
[00:18:11.000 --> 00:18:15.000]   However, this is slightly more general.
[00:18:15.000 --> 00:18:19.000]   This actually also accounts for complex matrices.
[00:18:19.000 --> 00:18:22.000]   Remember, or Fourier transform actually had complex coefficients.
[00:18:22.000 --> 00:18:27.000]   So for complex, this is what unitary is.
[00:18:27.000 --> 00:18:29.000]   Otherwise it would just be orthonormal.
[00:18:29.000 --> 00:18:31.000]   Unitary means that we actually,
[00:18:31.000 --> 00:18:34.000]   whenever we have minus i something,
[00:18:34.000 --> 00:18:37.000]   we'll change the minus i into plus i and so on.
[00:18:37.000 --> 00:18:40.000]   So this is what means the Hermitian conjugate.
[00:18:40.000 --> 00:18:43.000]   So it means that besides just transposing,
[00:18:43.000 --> 00:18:47.000]   transposing means you just do this to the matrix,
[00:18:47.000 --> 00:18:50.000]   or actually, sorry, you do this.
[00:18:50.000 --> 00:18:52.000]   Instead of doing that,
[00:18:52.000 --> 00:18:54.000]   you also, every complex number,
[00:18:54.000 --> 00:18:57.000]   if you had a plus sign, plus i times something,
[00:18:57.000 --> 00:19:00.000]   you do now minus i times something, and vice versa.
[00:19:00.000 --> 00:19:02.000]   So you change the sign of your complex,
[00:19:02.000 --> 00:19:05.000]   of your imaginary, the imaginary part of numbers.
[00:19:05.000 --> 00:19:08.000]   That's what this is here, the Hermitian conjugate.
[00:19:08.000 --> 00:19:11.000]   So this is essentially a kind of generalized transpose
[00:19:11.000 --> 00:19:14.000]   for complex matrices.
[00:19:14.000 --> 00:19:20.000]   So if a is real valued, a is equal to a star,
[00:19:20.000 --> 00:19:23.000]   the complex, the conjugate here,
[00:19:23.000 --> 00:19:27.000]   and so then it's just a equals a transpose that you require.
[00:19:27.000 --> 00:19:31.000]   That's then called an orthonormal matrix,
[00:19:31.000 --> 00:19:34.000]   and that's essentially a rotation matrix.
[00:19:34.000 --> 00:19:37.000]   That we're talking about.
[00:19:37.000 --> 00:19:40.000]   So in three-dimensional space, you see those.
[00:19:40.000 --> 00:19:44.000]   This is, if I have vectors in three-dimensional space,
[00:19:44.000 --> 00:19:47.000]   if I just rotate them around the origin,
[00:19:47.000 --> 00:19:51.000]   that's essentially what these matrices would be about.
[00:19:51.000 --> 00:19:55.000]   Now think of this in a million-dimensional space, for example.
[00:19:55.000 --> 00:19:58.000]   But the same thing is you just rotate things around.
[00:19:58.000 --> 00:20:01.000]   You change coefficients, but the key thing with rotations,
[00:20:01.000 --> 00:20:03.000]   and with these things is you don't change the length.
[00:20:03.000 --> 00:20:06.000]   If this is the length of the vector from this origin,
[00:20:06.000 --> 00:20:09.000]   this is the length of the vector, I can rotate it around
[00:20:09.000 --> 00:20:12.000]   arbitrarily into this million-dimensional space,
[00:20:12.000 --> 00:20:15.000]   but the length of the vector stays the same.
[00:20:15.000 --> 00:20:19.000]   That's what these unitary transforms are.
[00:20:19.000 --> 00:20:24.000]   So this is actually what we see here.
[00:20:24.000 --> 00:20:31.000]   For any unitary transform here, say equals a times f,
[00:20:31.000 --> 00:20:40.000]   we get the length of the vector is c Hermitian times c here,
[00:20:40.000 --> 00:20:44.000]   which is f Hermitian times a Hermitian times a times f,
[00:20:44.000 --> 00:20:47.000]   simply applying definition, applying--
[00:20:47.000 --> 00:20:54.000]   and so now we have the property that this should be true,
[00:20:54.000 --> 00:20:57.000]   because that's the definition of unitary.
[00:20:57.000 --> 00:20:59.000]   Therefore, this disappears here,
[00:20:59.000 --> 00:21:03.000]   and so therefore this is simply the length of the vector f,
[00:21:03.000 --> 00:21:07.000]   and so the length of the vector f is the same as the length of the vector c.
[00:21:07.000 --> 00:21:09.000]   So if we have a Hermitian--
[00:21:09.000 --> 00:21:13.000]   if we have a unitary transform, by definition, the length doesn't change.
[00:21:13.000 --> 00:21:19.000]   So in other words, every unitary transfer is simply a rotation
[00:21:19.000 --> 00:21:21.000]   of the coordinate system with, in addition,
[00:21:21.000 --> 00:21:24.000]   possible sine flips and stuff like that.
[00:21:24.000 --> 00:21:26.000]   But again, sine flips also, they're just mirroring,
[00:21:26.000 --> 00:21:28.000]   they also don't change the length.
[00:21:28.000 --> 00:21:32.000]   So it means that instead of this, I can do a mirroring and get this,
[00:21:32.000 --> 00:21:36.000]   but that's still the same structure, all the vectors at the same length,
[00:21:36.000 --> 00:21:42.000]   but they might change, they might be mirroring involved also.
[00:21:42.000 --> 00:21:45.000]   So the vector lengths, the energies, essentially are conserved.
[00:21:45.000 --> 00:21:50.000]   So now, is that clear to everyone?
[00:21:50.000 --> 00:21:56.000]   So then, now we'll go from applying the transformation to a single image,
[00:21:56.000 --> 00:21:59.000]   we'll actually look at a whole collection at once.
[00:21:59.000 --> 00:22:04.000]   So F_i is a single image, it's one image,
[00:22:04.000 --> 00:22:07.000]   we now stack, so these are all long vectors,
[00:22:07.000 --> 00:22:12.000]   we'll stack these long vectors, a whole collection, into one big matrix.
[00:22:12.000 --> 00:22:17.000]   So now we get, this is still, let's say, a million dimensional this way,
[00:22:17.000 --> 00:22:21.000]   and then if we have a thousand images, then we have a thousand dimensions that way.
[00:22:21.000 --> 00:22:26.000]   That's now a photo collection, let's say, an image collection.
[00:22:26.000 --> 00:22:37.000]   Okay, and now what we'll do is, we'll do, we'll compute the auto correlation function of that image collection.
[00:22:37.000 --> 00:22:40.000]   So what was correlation again?
[00:22:40.000 --> 00:22:46.000]   Correlation was kind of taking, you know, when we look at a template, at a small region of the image,
[00:22:46.000 --> 00:22:49.000]   we would take a template, so a kernel,
[00:22:49.000 --> 00:22:54.000]   and we'd kind of compare it like one by one, you know, for this one, we compare it to this one,
[00:22:54.000 --> 00:22:59.000]   this one, this one, this one, this one, and we kind of compare how well they correlate, in a sense,
[00:22:59.000 --> 00:23:04.000]   coefficient by coefficient, right, between the kernel and the image patch.
[00:23:04.000 --> 00:23:11.000]   Here, we want to compute the correlation between, you know, two full images.
[00:23:11.000 --> 00:23:15.000]   So our template is the whole image now, and so we don't have to move it across the other image,
[00:23:15.000 --> 00:23:19.000]   no, there's actually, you know, it's the full image, correlated to the full image,
[00:23:19.000 --> 00:23:23.000]   so it's how much does the first pixel look like the first pixel, you know,
[00:23:23.000 --> 00:23:26.000]   and the second pixel looks like the second pixel, etc.
[00:23:26.000 --> 00:23:32.000]   So that's what we do here, right, so we'll take the two vectors,
[00:23:32.000 --> 00:23:37.000]   and so to multiply them, right, so the two vectors, you know, let's say f1 and f2,
[00:23:37.000 --> 00:23:43.000]   what do we do? Well, we take f1 transpose, right, or Hermitian actually, sorry,
[00:23:43.000 --> 00:23:54.000]   and then multiply it, and essentially get, actually, sorry, we do it the other way around,
[00:23:54.000 --> 00:24:02.000]   we take this one, we transpose it, and then we get here the product of the first one with the first one,
[00:24:02.000 --> 00:24:09.000]   so we'll get the first, what do we get here?
[00:24:09.000 --> 00:24:16.000]   So essentially, we want to have the expected value, so the average,
[00:24:16.000 --> 00:24:27.000]   of every first coefficient with itself, we can also get, I think there needs to be a j here somewhere,
[00:24:27.000 --> 00:24:36.000]   this is i and j actually, sorry, so we'll look at how much does the first coefficient, for example,
[00:24:36.000 --> 00:24:46.000]   correlate with the first coefficients of the other ones, etc., etc.,
[00:24:46.000 --> 00:24:58.000]   and so we essentially get here this image collection of the correlation function.
[00:24:58.000 --> 00:25:13.000]   So in the end, so we, after unitary transform, this correlation function, this correlation function,
[00:25:13.000 --> 00:25:21.000]   matrix, sorry, that indicates how much a particular coefficient, a particular pixel,
[00:25:21.000 --> 00:25:32.000]   correlates with another particular pixel, so here, so this is actually about how much pixel one correlates with pixel one,
[00:25:32.000 --> 00:25:36.000]   how much pixel one correlates with pixel two, how much pixel one correlates with pixel five,
[00:25:36.000 --> 00:25:43.000]   how much pixel five correlates with pixel ten, etc., so it's a correlation within the image.
[00:25:43.000 --> 00:26:01.000]   So that matrix, it's essentially, what we look at is the expected value of how all those coefficients
[00:26:01.000 --> 00:26:12.000]   correlate with each other, so also we can look at the correlation between those coefficients
[00:26:12.000 --> 00:26:16.000]   after a transformation, okay?
[00:26:16.000 --> 00:26:30.000]   So essentially, this would be the transformation, so if we want to look at the correlation matrix
[00:26:30.000 --> 00:26:39.000]   of the coefficients, so not the original elements here, but the coefficients after a transformation,
[00:26:39.000 --> 00:26:47.000]   then we have the expected value of this matrix here, which is the same as this operation here,
[00:26:47.000 --> 00:26:53.000]   which if we look at this here, this and this is constant, so this can be moved out,
[00:26:53.000 --> 00:26:58.000]   and essentially we get the autocorrelation function of this here.
[00:26:58.000 --> 00:27:08.000]   And so the mean squared values, the average energies of the coefficients C here,
[00:27:08.000 --> 00:27:15.000]   C_i are on the diagonal of this matrix here, these guys here,
[00:27:15.000 --> 00:27:22.000]   but this matrix can, would still be dense typically,
[00:27:22.000 --> 00:27:31.000]   but then what we'd like to do is to choose this, this eigenmatrix,
[00:27:31.000 --> 00:27:39.000]   so that, you know, this one here, so we choose this to be unitary,
[00:27:39.000 --> 00:27:47.000]   and choose this here in the way that we get from the original function here,
[00:27:47.000 --> 00:27:51.000]   the original autocorrelation function, which is a dense matrix.
[00:27:51.000 --> 00:28:01.000]   If we compute this matrix here in such a way that we get the eigenmatrix here of the autocorrelation matrix,
[00:28:01.000 --> 00:28:06.000]   so if we actually do the diagonalization of the matrix, so we compute the eigenvalues
[00:28:06.000 --> 00:28:11.000]   and the eigenvectors here of this matrix, we get something like this.
[00:28:11.000 --> 00:28:17.000]   And so essentially we can apply a transformation to this here,
[00:28:17.000 --> 00:28:21.000]   so if you apply this transformation, then to the autocorrelation matrix,
[00:28:21.000 --> 00:28:26.000]   it diagonalizes the autocorrelation matrix.
[00:28:26.000 --> 00:28:29.000]   So RFF is actually a symmetric non-negative matrix,
[00:28:29.000 --> 00:28:35.000]   therefore all the, because it's all this, you know, the way it's constructed here,
[00:28:35.000 --> 00:28:39.000]   as in the product of all those vectors.
[00:28:39.000 --> 00:28:45.000]   So therefore the eigenvalues are all larger than zero,
[00:28:45.000 --> 00:28:50.000]   and it is a normal matrix, so this is a normal matrix,
[00:28:50.000 --> 00:28:55.000]   and hence the unitary eigenmatrix always exists.
[00:28:55.000 --> 00:29:03.000]   And so if we actually pick this transform matrix to be the Hermitian of this matrix,
[00:29:03.000 --> 00:29:05.000]   we can diagonalize the matrix.
[00:29:05.000 --> 00:29:12.000]   So in other words, so this was our original autocorrelation function
[00:29:12.000 --> 00:29:17.000]   of our image collection, which was looking at how all coefficients were correlated.
[00:29:17.000 --> 00:29:24.000]   We can actually do, apply a transformation that we choose to be this eigenmatrix
[00:29:24.000 --> 00:29:29.000]   or the Hermitian of the eigenmatrix, and if we apply that, you know,
[00:29:29.000 --> 00:29:34.000]   if this is what we take, then this autocorrelation of the coefficients now,
[00:29:34.000 --> 00:29:39.000]   not of the original pixels, but of the coefficients after the transformation,
[00:29:39.000 --> 00:29:42.000]   they, you know, they are, we choose the matrix like this,
[00:29:42.000 --> 00:29:45.000]   if we choose the matrix like this, through the eigenvalue,
[00:29:45.000 --> 00:29:49.000]   because this was the eigenvalue, we can replace this, you know, this is diagonal,
[00:29:49.000 --> 00:29:52.000]   so we can, we actually get this, just the eigenvalues here,
[00:29:52.000 --> 00:29:56.000]   this has to be equal if this is the eigenvalue matrix.
[00:29:56.000 --> 00:29:59.000]   So we get this, and in other words, this of course disappears,
[00:29:59.000 --> 00:30:03.000]   and so we just get this here, right, so that's just the diagonalization of the matrix.
[00:30:03.000 --> 00:30:06.000]   Okay, so you've seen this before.
[00:30:06.000 --> 00:30:12.000]   So essentially this matrix, if we choose the transformation to be the one that comes out of the eigenvalue,
[00:30:12.000 --> 00:30:16.000]   the composition of, of this autocorrelation function,
[00:30:16.000 --> 00:30:20.000]   then we essentially just get a diagonal matrix here for the coefficients,
[00:30:20.000 --> 00:30:23.000]   the autocorrelation between the coefficients.
[00:30:23.000 --> 00:30:27.000]   What does that mean? It means that actually, you know, all of this math
[00:30:27.000 --> 00:30:32.000]   essentially means that we've now, instead of having, you know,
[00:30:32.000 --> 00:30:39.000]   in an image, this pixel and this pixel often be correlated with each other, right,
[00:30:39.000 --> 00:30:42.000]   because if this is wide, this is also often wide, for example, so they're,
[00:30:42.000 --> 00:30:46.000]   they move together, they're correlated with each other.
[00:30:46.000 --> 00:30:54.000]   In this case, we changed the representation in such a way for our particular image collection,
[00:30:54.000 --> 00:30:57.000]   this is for our particular image collection, right, not in general,
[00:30:57.000 --> 00:31:03.000]   this is for this particular image collection, so that this pixel and, sorry,
[00:31:03.000 --> 00:31:10.000]   in the new basis, in the new basis, two coefficients are completely uncorrelated.
[00:31:10.000 --> 00:31:15.000]   Okay, because this is a diagonal matrix, this autocorrelation function,
[00:31:15.000 --> 00:31:19.000]   here, this is a diagonal matrix, which is the eigenvalues along the diagonal,
[00:31:19.000 --> 00:31:26.000]   so it means that coefficient one only correlates, only have a nonzero correlation with itself,
[00:31:26.000 --> 00:31:28.000]   but it has zeros with all the other ones.
[00:31:28.000 --> 00:31:32.000]   These are all the off-diagonal numbers, are the correlation between one element
[00:31:32.000 --> 00:31:35.000]   and other elements, they're all zero, okay?
[00:31:35.000 --> 00:31:42.000]   That's what you have here, okay, so, so that's the first thing,
[00:31:42.000 --> 00:31:47.000]   the second thing is, and this is the same that you've seen in linear algebra
[00:31:47.000 --> 00:31:58.000]   for, you know, of the fact that this is essentially the equivalent of the single-evalued composition,
[00:31:58.000 --> 00:32:03.000]   and that the single-evalued composition packs the most energy in the first k,
[00:32:03.000 --> 00:32:08.000]   for every k, in the first k elements, you pack the most energy,
[00:32:08.000 --> 00:32:13.000]   so you get the best approximation of the matrix with the first k single vectors,
[00:32:13.000 --> 00:32:21.000]   or, you know, here with the first k, if you order them in order here,
[00:32:21.000 --> 00:32:31.000]   with the first k eigenvalues, right, so it packs the most energy in the first k coefficients,
[00:32:31.000 --> 00:32:34.000]   so in this case, j, where j is arbitrary,
[00:32:34.000 --> 00:32:38.000]   and the mean square approximation error by choosing only the first j coefficients,
[00:32:38.000 --> 00:32:43.000]   that error is minimized, okay?
[00:32:43.000 --> 00:32:48.000]   This is something we can also derive here,
[00:32:48.000 --> 00:32:54.000]   so we don't necessarily have to go for the math here,
[00:32:54.000 --> 00:33:02.000]   but essentially this is kind of re-deriving this property of the eigenvalue of single-evalued composition,
[00:33:02.000 --> 00:33:07.000]   so if you express here b as being the first j coefficients,
[00:33:07.000 --> 00:33:11.000]   so this is now a rectangular matrix, that is, you know,
[00:33:11.000 --> 00:33:15.000]   the length of the original number of coefficients, and then j high,
[00:33:15.000 --> 00:33:20.000]   and it's a unit matrix, but clipped at just j coefficients,
[00:33:20.000 --> 00:33:25.000]   so now b is therefore just the first j coefficients,
[00:33:25.000 --> 00:33:33.000]   then essentially if we do here the energy in the first, the trace,
[00:33:33.000 --> 00:33:38.000]   so the trace is the sum of the first b diagonal elements,
[00:33:38.000 --> 00:33:41.000]   I mean in this case the first b diagonal elements,
[00:33:41.000 --> 00:33:45.000]   that's the same as the original, but multiplied with this matrix here,
[00:33:45.000 --> 00:33:49.000]   which clips the things, which is equal to, you know,
[00:33:49.000 --> 00:33:54.000]   RCC can be replaced by here, the eigenvalue of the composition,
[00:33:54.000 --> 00:33:59.000]   and so that's also the sum simply of these elements here,
[00:33:59.000 --> 00:34:04.000]   where these are the rows of this, so this is just all simple rewriting,
[00:34:04.000 --> 00:34:11.000]   then if we want to minimize something, we use Lagrangian representation,
[00:34:11.000 --> 00:34:16.000]   so minimize something subject to a constraint,
[00:34:16.000 --> 00:34:19.000]   so we say we want to minimize this energy term here,
[00:34:19.000 --> 00:34:23.000]   so the Lagrangian would be this energy term that we want to minimize,
[00:34:23.000 --> 00:34:27.000]   but with some constraints, the ones that have to be satisfied
[00:34:27.000 --> 00:34:33.000]   multiply by some lambda, right, that's the usual Lagrangian way to write things,
[00:34:33.000 --> 00:34:39.000]   so if you now minimize this Lagrangian, you will kind of,
[00:34:39.000 --> 00:34:43.000]   the minimum means that this, the minimum towards lambda
[00:34:43.000 --> 00:34:45.000]   will ensure that the constraint is satisfied,
[00:34:45.000 --> 00:34:48.000]   because it's only there that it's satisfied,
[00:34:48.000 --> 00:34:51.000]   and minimum towards the other variables will be in here,
[00:34:51.000 --> 00:34:58.000]   and so you get, this allows you to compute the minimization of the function
[00:34:58.000 --> 00:35:01.000]   E under the constraints expressed with the lambda here,
[00:35:01.000 --> 00:35:04.000]   with the Lagrangian multiplier, okay?
[00:35:04.000 --> 00:35:09.000]   Again, this can be expressed this way, let's start there,
[00:35:09.000 --> 00:35:12.000]   and then this, the second part is expressed this way,
[00:35:12.000 --> 00:35:16.000]   the unit constraints, and no surprise that these are the lambdas,
[00:35:16.000 --> 00:35:19.000]   these ends up being actually the eigenvalues,
[00:35:19.000 --> 00:35:25.000]   and so if you differentiate L with respect to A_j,
[00:35:25.000 --> 00:35:27.000]   so which are those vectors,
[00:35:27.000 --> 00:35:30.000]   then you essentially obtain these constraints here,
[00:35:30.000 --> 00:35:35.000]   that, you know, A_j* here,
[00:35:35.000 --> 00:35:41.000]   R_ff times A_j* should be equal to lambda_j times A_j*,
[00:35:41.000 --> 00:35:43.000]   which is essentially just, you know,
[00:35:43.000 --> 00:35:46.000]   this is the expression for eigenvectors,
[00:35:46.000 --> 00:35:52.000]   therefore these guys have to be these first J_eagen vectors, okay?
[00:35:52.000 --> 00:35:56.000]   Okay, so you can look at it again,
[00:35:56.000 --> 00:35:58.000]   or you can just look at your first year linear algebra,
[00:35:58.000 --> 00:36:03.000]   this is what we derived there, or what you have derived there also.
[00:36:03.000 --> 00:36:06.000]   Okay, what does that actually mean in practice,
[00:36:06.000 --> 00:36:09.000]   which let's say, let's get some intuition in what that actually means,
[00:36:09.000 --> 00:36:15.000]   it means that if we have, let's say here, we have our image collection,
[00:36:15.000 --> 00:36:18.000]   it consists of, you know, let's not,
[00:36:18.000 --> 00:36:20.000]   it's hard to imagine things in a middle dimensional space,
[00:36:20.000 --> 00:36:23.000]   so let's start in a two dimensional space,
[00:36:23.000 --> 00:36:27.000]   we only have two coefficients, f_1 and f_2,
[00:36:27.000 --> 00:36:32.000]   and so every image in this case, or two pixel image,
[00:36:32.000 --> 00:36:37.000]   is actually just one point in this two dimensional space, okay?
[00:36:37.000 --> 00:36:39.000]   And so our points would be,
[00:36:39.000 --> 00:36:42.000]   our image collection would be essentially a bunch of points
[00:36:42.000 --> 00:36:44.000]   that are distributed this way here,
[00:36:44.000 --> 00:36:46.000]   you know, this is one image in our collection,
[00:36:46.000 --> 00:36:49.000]   this is another one, this is another one, you know, another one, etc.
[00:36:49.000 --> 00:36:53.000]   These are essentially all our points in our image collection,
[00:36:53.000 --> 00:36:58.000]   and what we see here, of course, is that coefficient f_1 and coefficient f_2
[00:36:58.000 --> 00:37:02.000]   are strongly correlated, whenever f_1 is big, f_2 is also big,
[00:37:02.000 --> 00:37:06.000]   whenever f_1 is strongly negative, f_2 is also strongly negative,
[00:37:06.000 --> 00:37:09.000]   so we have a strong correlation between the two coefficients,
[00:37:09.000 --> 00:37:13.000]   they don't actually move independently, they move together, they're correlated, okay?
[00:37:13.000 --> 00:37:17.000]   However, if we choose the right basis transformation,
[00:37:17.000 --> 00:37:20.000]   in this case just a two dimensional rotation,
[00:37:20.000 --> 00:37:24.000]   we get in a different coefficient space, okay?
[00:37:24.000 --> 00:37:29.000]   We have preserved the length, notice, you know, the shape of this is just rotated,
[00:37:29.000 --> 00:37:31.000]   all the vectors still have the same length,
[00:37:31.000 --> 00:37:35.000]   but essentially in this case, we now have c_1,
[00:37:35.000 --> 00:37:38.000]   the coefficient c_1 and the coefficient c_2
[00:37:38.000 --> 00:37:41.000]   now can essentially are uncorrelated.
[00:37:41.000 --> 00:37:46.000]   We have diagonalized this correlation matrix,
[00:37:46.000 --> 00:37:49.000]   c_1 and c_2 aren't correlated,
[00:37:49.000 --> 00:37:52.000]   it means that in this square matrix, the two by two matrix,
[00:37:52.000 --> 00:37:55.000]   we have the two eigenvalues on the diagonal,
[00:37:55.000 --> 00:37:58.000]   and the two that express the correlation between c_1 and c_2,
[00:37:58.000 --> 00:38:04.000]   the two diagonal elements, of diagonal elements, those are both zero, okay?
[00:38:04.000 --> 00:38:07.000]   And so essentially by doing that,
[00:38:07.000 --> 00:38:10.000]   we've also placed the most energy along c_1
[00:38:10.000 --> 00:38:14.000]   and then only very little energy along c_2 in this case, right?
[00:38:14.000 --> 00:38:21.000]   So we've concentrated all the energy in the variation along the c_1 axis, okay?
[00:38:21.000 --> 00:38:24.000]   So obviously this is now potentially a much better representation
[00:38:24.000 --> 00:38:28.000]   to look further into our image collection, okay?
[00:38:28.000 --> 00:38:32.000]   Okay, so again, this was in two dimension,
[00:38:32.000 --> 00:38:34.000]   but imagine this in millions, you know,
[00:38:34.000 --> 00:38:38.000]   million-dimensional space, for example, okay?
[00:38:38.000 --> 00:38:41.000]   What's also important to realize is, okay,
[00:38:41.000 --> 00:38:43.000]   so we have now those coefficients, right?
[00:38:43.000 --> 00:38:47.000]   So we have, for example, here, coefficient c_1 and c_2.
[00:38:47.000 --> 00:38:53.000]   So now if we're given c_1 here, let's say c_1 is this value,
[00:38:53.000 --> 00:38:56.000]   we could go back to this space through this inverse rotation,
[00:38:56.000 --> 00:38:59.000]   so we take this point, we apply the inverse rotation,
[00:38:59.000 --> 00:39:02.000]   and we get a point over here, okay?
[00:39:02.000 --> 00:39:06.000]   So we can actually say that, you know, the 1, 1 here,
[00:39:06.000 --> 00:39:12.000]   so this direction here is expressed by a vector 1, 1, right?
[00:39:12.000 --> 00:39:15.000]   And this is 1, 1, for example, right?
[00:39:15.000 --> 00:39:17.000]   Or it's two equal values.
[00:39:17.000 --> 00:39:25.000]   It's actually, you know, whatever, 0.07071 or something like that, whatever,
[00:39:25.000 --> 00:39:28.000]   square root of 2 divided by 2.
[00:39:28.000 --> 00:39:30.000]   And the same value here, right?
[00:39:30.000 --> 00:39:32.000]   So this is this vector here.
[00:39:32.000 --> 00:39:36.000]   The second vector is actually the orthogonal vector, it's this vector, right?
[00:39:36.000 --> 00:39:38.000]   So you can notice, right?
[00:39:38.000 --> 00:39:43.000]   So going back, I will do c_1 times this here,
[00:39:43.000 --> 00:39:45.000]   and I just obtain kind of a vector.
[00:39:45.000 --> 00:39:50.000]   So that's here, the Hermitian of the A matrix,
[00:39:50.000 --> 00:39:55.000]   times the coefficients, whatever coefficient vector I have, I can reapply that,
[00:39:55.000 --> 00:39:59.000]   and so I take the vector, I multiply this way,
[00:39:59.000 --> 00:40:03.000]   and the coefficients get multiplied, you know, and instantiate the whole image,
[00:40:03.000 --> 00:40:08.000]   like, let's say it's just 1, 0, 0, 0 for my coefficients,
[00:40:08.000 --> 00:40:09.000]   then what do I get?
[00:40:09.000 --> 00:40:14.000]   I will just select the first column of A Hermitian, right?
[00:40:14.000 --> 00:40:16.000]   Which is mostly the transpose of A, okay?
[00:40:16.000 --> 00:40:22.000]   So in other words, I take the first column of this matrix is the first row of the matrix A.
[00:40:22.000 --> 00:40:27.000]   It doesn't matter, it's one of those vectors, one of those eigenvectors,
[00:40:27.000 --> 00:40:32.000]   and so we can essentially interpret this,
[00:40:32.000 --> 00:40:38.000]   each of those columns of this matrix here as something we'll call a basis image,
[00:40:38.000 --> 00:40:44.000]   and if these are eigenvalues, then we'll call this an eigenimage, essentially.
[00:40:44.000 --> 00:40:45.000]   Right?
[00:40:45.000 --> 00:40:48.000]   So if the transform is a Karenel-Leuver transform,
[00:40:48.000 --> 00:40:51.000]   or you know, the way we just explained it, say these eigenvalues,
[00:40:51.000 --> 00:40:55.000]   then we'll call these eigenvectors of this other correlation matrix,
[00:40:55.000 --> 00:41:00.000]   we'll call them eigenimages, because these are long vectors that actually represent images,
[00:41:00.000 --> 00:41:03.000]   they're actually in the space of images,
[00:41:03.000 --> 00:41:06.000]   and therefore we'll call them eigenimages.
[00:41:06.000 --> 00:41:09.000]   If the energy concentration works well,
[00:41:09.000 --> 00:41:15.000]   so in other words, if the first few singular values are very big and then all the rest becomes very small,
[00:41:15.000 --> 00:41:19.000]   so if we really can capture most of what's going on with a few coefficients
[00:41:19.000 --> 00:41:22.000]   and not with a million coefficients,
[00:41:22.000 --> 00:41:28.000]   then we might be able to really represent our image collection with only a few eigenimages,
[00:41:28.000 --> 00:41:33.000]   a small dimensional basis that would capture most of what's going on in our image collection.
[00:41:33.000 --> 00:41:34.000]   Okay?
[00:41:34.000 --> 00:41:40.000]   So let's look at this applied to the recognition problem,
[00:41:40.000 --> 00:41:45.000]   for example, for recognizing faces.
[00:41:45.000 --> 00:41:51.000]   So if we want to recognize a complex pattern like a face,
[00:41:51.000 --> 00:41:56.000]   large portions of the image, say an image, might have to be considered,
[00:41:56.000 --> 00:42:00.000]   so you would have to look at the whole face essentially to recognize it.
[00:42:00.000 --> 00:42:04.000]   This high dimensionality, let's say even you just look at a small template of the image,
[00:42:04.000 --> 00:42:09.000]   it would still be, let's say, at least 30 by 30, that's 900 coefficients,
[00:42:09.000 --> 00:42:14.000]   and so essentially looking for these 900 coefficients that represent one face,
[00:42:14.000 --> 00:42:19.000]   and then I have a whole database, for example, of all of your faces in a database,
[00:42:19.000 --> 00:42:21.000]   and I have a few hundreds of those,
[00:42:21.000 --> 00:42:25.000]   and then I have this 900 vector that would have to multiply to correlate
[00:42:25.000 --> 00:42:31.000]   with essentially each of the existing faces in my database and do that operation,
[00:42:31.000 --> 00:42:33.000]   and so that's relatively expensive.
[00:42:33.000 --> 00:42:36.000]   If I can transform that to a space that's much more compact,
[00:42:36.000 --> 00:42:40.000]   where I can capture most of the energy in only a few coefficients,
[00:42:40.000 --> 00:42:42.000]   and I can work in that coefficient space,
[00:42:42.000 --> 00:42:48.000]   then I know that I'll be able to do very similar operation, but a lot cheaper.
[00:42:48.000 --> 00:42:53.000]   We'll get to that in more detail in a second.
[00:42:53.000 --> 00:42:55.000]   So the nearest neighbor operation could be a lot cheaper
[00:42:55.000 --> 00:42:59.000]   if we can actually work in this much smaller dimensional space.
[00:42:59.000 --> 00:43:04.000]   So if we can go from faces, for example, here in face images,
[00:43:04.000 --> 00:43:08.000]   by choosing the right transformation, we can go to a lower dimensional space,
[00:43:08.000 --> 00:43:12.000]   but where we preserve most of the energy,
[00:43:12.000 --> 00:43:15.000]   meaning we preserve more or less exactly the length of the vector,
[00:43:15.000 --> 00:43:18.000]   so we preserve most of what's actually there,
[00:43:18.000 --> 00:43:22.000]   then we might actually be able to do it much more efficiently.
[00:43:22.000 --> 00:43:27.000]   So the idea is to tailor a Kahun and Lever transform to a specific set of images
[00:43:27.000 --> 00:43:31.000]   of the recognition task to preserve the salient features.
[00:43:31.000 --> 00:43:34.000]   So let's look at it like this.
[00:43:34.000 --> 00:43:40.000]   So a very simple recognition system would be simply doing the Euclidean distance,
[00:43:40.000 --> 00:43:45.000]   which is the sum of squared differences between pixels in the images.
[00:43:45.000 --> 00:43:48.000]   So that means that I have two images.
[00:43:48.000 --> 00:43:52.000]   I have my query image, and then I have an image from the database.
[00:43:52.000 --> 00:43:54.000]   I compare them pixel by pixel.
[00:43:54.000 --> 00:43:57.000]   I look at what is the difference between those two pixels,
[00:43:57.000 --> 00:44:01.000]   difference between those two pixels, difference between those two, those two, and those two.
[00:44:01.000 --> 00:44:05.000]   And then, you know, so I do the difference between all the pixels,
[00:44:05.000 --> 00:44:09.000]   and I compute the length of that vector.
[00:44:09.000 --> 00:44:12.000]   That's actually the sum of squared differences,
[00:44:12.000 --> 00:44:15.000]   and then, you know, the square root of it.
[00:44:15.000 --> 00:44:18.000]   But essentially, it's that number that I would compute.
[00:44:18.000 --> 00:44:22.000]   So I subtract, for each pixel I subtract, I look at the difference,
[00:44:22.000 --> 00:44:25.000]   and I square that, and then I add it all up,
[00:44:25.000 --> 00:44:28.000]   and then, you know, potentially I can take the square root of the whole sum,
[00:44:28.000 --> 00:44:30.000]   but that's less important.
[00:44:30.000 --> 00:44:33.000]   But essentially, I minimize that thing, so I will pick the image.
[00:44:33.000 --> 00:44:35.000]   I've all the images in my database.
[00:44:35.000 --> 00:44:37.000]   I will pick them, I compare them, each of them.
[00:44:37.000 --> 00:44:39.000]   I will compare, I will compute this number,
[00:44:39.000 --> 00:44:44.000]   and then I will pick the one that has the smallest distance between, you know,
[00:44:44.000 --> 00:44:47.000]   database image and my query image.
[00:44:47.000 --> 00:44:51.000]   But as I said, this can be computation-expensive if you have a high-resolution image,
[00:44:51.000 --> 00:44:57.000]   or if you have even a low-resolution image, this can be expensive.
[00:44:57.000 --> 00:45:00.000]   Okay, so we'll continue with this after the break.
[00:45:00.000 --> 00:45:04.000]   Okay, so let's continue.
[00:45:06.000 --> 00:45:09.000]   So essentially, we're doing this simple recognition system.
[00:45:09.000 --> 00:45:16.000]   We have, we essentially are going to, in a whole,
[00:45:16.000 --> 00:45:22.000]   let me get the cursor, in a whole, we have a whole collection of images here.
[00:45:22.000 --> 00:45:26.000]   We want to find which of the images in our collection is closest to the query image.
[00:45:26.000 --> 00:45:29.000]   We do the difference between the two on a per-pixel basis,
[00:45:29.000 --> 00:45:33.000]   and then essentially do the square of those differences,
[00:45:33.000 --> 00:45:35.000]   and then if we want, we can do the square root,
[00:45:35.000 --> 00:45:37.000]   but as we minimize, if we do the square root,
[00:45:37.000 --> 00:45:39.000]   or we don't do the square root, it doesn't matter.
[00:45:39.000 --> 00:45:42.000]   We essentially have here a positive number,
[00:45:42.000 --> 00:45:44.000]   and we take the smallest one of them.
[00:45:44.000 --> 00:45:49.000]   And so we pick the coefficient, we pick the image that has the smallest difference
[00:45:49.000 --> 00:45:51.000]   with the query image.
[00:45:51.000 --> 00:45:53.000]   Okay, so this can be expensive.
[00:45:53.000 --> 00:45:56.000]   So we'll apply what we just did before.
[00:45:56.000 --> 00:46:01.000]   In this case, I chose the singular value representation of this.
[00:46:01.000 --> 00:46:08.000]   Also what we described as the KLT, the Kahöne-Leuvert transform.
[00:46:08.000 --> 00:46:14.000]   In other places, this is known as PCA, principal component analysis.
[00:46:14.000 --> 00:46:18.000]   Or again, you know, you can also just simply describe it as SVD.
[00:46:18.000 --> 00:46:22.000]   So just for you to know that all those concepts are actually all the same.
[00:46:22.000 --> 00:46:25.000]   They're just depending on what field they have been derived in.
[00:46:25.000 --> 00:46:27.000]   They come with different names,
[00:46:27.000 --> 00:46:32.000]   but they're all really the same basis concept of being able to do an eigenvalue
[00:46:32.000 --> 00:46:39.000]   or a singular value decomposition and diagonalize this correlation matrix, essentially.
[00:46:39.000 --> 00:46:43.000]   Okay, or to approximate a matrix by, you know,
[00:46:43.000 --> 00:46:48.000]   doing a singular value decomposition and keeping the k-first coefficients.
[00:46:48.000 --> 00:46:53.000]   Okay, so essentially what we want to approximate is this image,
[00:46:53.000 --> 00:46:57.000]   a particular query image, no, sorry, a database image.
[00:46:57.000 --> 00:47:09.000]   We want to approximate it with a set of, an eigenbasis times, you know,
[00:47:09.000 --> 00:47:11.000]   some smaller set of coefficients, right?
[00:47:11.000 --> 00:47:14.000]   What was C in the slides before is a P here.
[00:47:14.000 --> 00:47:20.000]   So we hope to be able to, you know, have a matrix that's kind of,
[00:47:20.000 --> 00:47:23.000]   so this is the length of the original images.
[00:47:23.000 --> 00:47:28.000]   So these are quite tall matrix, but we hope it do not have to be too wide.
[00:47:28.000 --> 00:47:35.000]   And while having this almost equality, you know, be well satisfied, right?
[00:47:35.000 --> 00:47:39.000]   So to only introduce a small error.
[00:47:39.000 --> 00:47:40.000]   So how do we do that?
[00:47:40.000 --> 00:47:45.000]   We start from the, this is the matrix that contains our image collection.
[00:47:45.000 --> 00:47:48.000]   So it's all the vectors of the images next to each other.
[00:47:48.000 --> 00:47:51.000]   We do a singular value decomposition of this.
[00:47:51.000 --> 00:47:56.000]   And what we hope to get is essentially a small matrix here, you know,
[00:47:56.000 --> 00:48:01.000]   height of the image times the number of images that, the number of,
[00:48:01.000 --> 00:48:07.000]   sorry, the number of coefficients we have to keep here.
[00:48:07.000 --> 00:48:09.000]   Times, you know, for each of the original images,
[00:48:09.000 --> 00:48:12.000]   essentially the coefficients that we preserve.
[00:48:12.000 --> 00:48:16.000]   We pick this, we put the sigmas on this side.
[00:48:16.000 --> 00:48:20.000]   So in other words, these are just unit vectors, each of those.
[00:48:20.000 --> 00:48:22.000]   So those are all normalized vectors.
[00:48:22.000 --> 00:48:28.000]   They're the first case singular vectors, left singular vectors of this matrix.
[00:48:28.000 --> 00:48:29.000]   Okay.
[00:48:29.000 --> 00:48:34.000]   So, and we know that, and we really arrived at with the Lagrangian,
[00:48:34.000 --> 00:48:39.000]   but you also know this simply for your first year linear algebra.
[00:48:39.000 --> 00:48:44.000]   You know that essentially this is a good approximation, you know, depending,
[00:48:44.000 --> 00:48:47.000]   this can be a good approximation or it's the best possible approximation.
[00:48:47.000 --> 00:48:52.000]   And if you're a little bit lucky or depending on your images actually showing a lot of correlation
[00:48:52.000 --> 00:48:57.000]   between pixels and so on and having, looking a lot the same and so on,
[00:48:57.000 --> 00:49:01.000]   being quite predictable in terms of what's going on,
[00:49:01.000 --> 00:49:06.000]   then you can have a good approximation with only a limited set of singular values.
[00:49:06.000 --> 00:49:11.000]   So most of the energy would be contained in the first few singular values, hopefully.
[00:49:11.000 --> 00:49:16.000]   So if this is satisfied, so if you throw all kinds of different images in,
[00:49:16.000 --> 00:49:21.000]   this will not be satisfied because one pixel will not tell you much about what happens somewhere else in the image.
[00:49:21.000 --> 00:49:25.000]   But if it's all faces, for example, then, you know, this pixel and this pixel,
[00:49:25.000 --> 00:49:28.000]   they will be very correlated for everyone.
[00:49:28.000 --> 00:49:29.000]   Okay.
[00:49:29.000 --> 00:49:36.000]   And, you know, same for this pixel and this pixel and this pixel and this pixel and so on and this pixel and this pixel also, etc.
[00:49:36.000 --> 00:49:37.000]   Okay.
[00:49:37.000 --> 00:49:40.000]   So in that case, we probably can compact quite well.
[00:49:40.000 --> 00:49:46.000]   And in that case, we can assume that our original metric that we use here,
[00:49:46.000 --> 00:49:50.000]   the difference between the images in pixels, in pixel values,
[00:49:50.000 --> 00:50:00.000]   would be, well, would be, would be also well approximated by this here.
[00:50:00.000 --> 00:50:06.000]   Remember, if you do SVD or if you do something, you actually want to work,
[00:50:06.000 --> 00:50:10.000]   also if we looked, let me go back here.
[00:50:10.000 --> 00:50:11.000]   Okay.
[00:50:11.000 --> 00:50:16.000]   We kind of assumed here that this was centered around zero, right?
[00:50:16.000 --> 00:50:23.000]   I didn't make it explicit here, but we, for all of this, we assumed that we have a centered distribution around zero.
[00:50:23.000 --> 00:50:25.000]   So how do you guarantee that?
[00:50:25.000 --> 00:50:27.000]   Well, you know, it's very simple.
[00:50:27.000 --> 00:50:29.000]   You subtract the average, right?
[00:50:29.000 --> 00:50:34.000]   So you first, with all of these things, it's really important, you shouldn't forget that.
[00:50:34.000 --> 00:50:37.000]   You first have to subtract the average.
[00:50:37.000 --> 00:50:42.000]   There's something I still remember that I forgot long ago when I was doing exercise of this type,
[00:50:42.000 --> 00:50:46.000]   so that's like 30 years ago or so.
[00:50:46.000 --> 00:50:52.000]   I remember that I was getting trouble getting things to work out because I forgot to subtract the average vector.
[00:50:52.000 --> 00:50:54.000]   And therefore, nothing worked.
[00:50:54.000 --> 00:50:55.000]   Okay.
[00:50:55.000 --> 00:51:02.000]   So you have to subtract the average vector because the assumption is otherwise you find the biggest correlation to be in the direction of the average vector, right?
[00:51:02.000 --> 00:51:07.000]   If your whole distribution is not centered around, let's say zero is here, it's not centered around zero,
[00:51:07.000 --> 00:51:13.000]   but it's somewhere over there, then your biggest thing on the vector is just going to be pointing to the average vector.
[00:51:13.000 --> 00:51:14.000]   Okay.
[00:51:14.000 --> 00:51:15.000]   So you don't want that.
[00:51:15.000 --> 00:51:16.000]   You subtract it out first.
[00:51:16.000 --> 00:51:18.000]   So this is simply the average.
[00:51:18.000 --> 00:51:21.000]   And so you take, for every image you first subtract the average,
[00:51:21.000 --> 00:51:27.000]   which means that you take your whole distribution that's out there, you shift it to be centered around zero.
[00:51:27.000 --> 00:51:29.000]   So that's what we do first.
[00:51:29.000 --> 00:51:35.000]   And then we do the best approximation of that distribution around zero doing this way.
[00:51:35.000 --> 00:51:42.000]   So this thing here is done on the shifted distribution, the one that's centered around zero.
[00:51:42.000 --> 00:51:49.000]   But of course, in terms of difference, the difference between vectors is not at all affected by shifting the vectors around.
[00:51:49.000 --> 00:51:51.000]   So this actually doesn't change anything.
[00:51:51.000 --> 00:51:54.000]   So this is actually equality here.
[00:51:54.000 --> 00:52:00.000]   The distance between the vectors before centering them around zero or after sending them around zero, that's identical.
[00:52:00.000 --> 00:52:02.000]   There's no error introduced here.
[00:52:02.000 --> 00:52:12.000]   Then we want actually to use our closest rank K approximation of the SVD or what we just showed with Lagrangian,
[00:52:12.000 --> 00:52:20.000]   that taking the first K coefficient is the best we can do for taking the eigenvalues of the autocorrelation matrix.
[00:52:20.000 --> 00:52:23.000]   So essentially we apply that.
[00:52:23.000 --> 00:52:28.000]   And so the advantage is that if we do that, this was the full space.
[00:52:28.000 --> 00:52:30.000]   This is now only a K dimensional space.
[00:52:30.000 --> 00:52:37.000]   So it's potentially a much smaller space if we have a highly correlated set of images.
[00:52:37.000 --> 00:52:45.000]   So in other words, we end up with if this is true, then this vector should be well approximated by this vector.
[00:52:45.000 --> 00:52:49.000]   And so in other words, we can approximate this, which was initially what we're going to do.
[00:52:49.000 --> 00:52:51.000]   Just compare all the images pixel by pixel.
[00:52:51.000 --> 00:52:55.000]   We actually can get a good approximation of that.
[00:52:55.000 --> 00:53:02.000]   Hopefully we actually get the same coefficient here because this distance is pretty close to this distance.
[00:53:02.000 --> 00:53:07.000]   And therefore the minimum of this is likely to actually, we're likely to preserve the right minimum here.
[00:53:07.000 --> 00:53:14.000]   And this would be a lot cheaper to compute because this distance is now say this was, let's say this was 30 by 30 pixels.
[00:53:14.000 --> 00:53:20.000]   This was 900, 900 dimensional vectors that you have to subtract from each other.
[00:53:20.000 --> 00:53:23.000]   Here you might be say 10 dimensional or so.
[00:53:23.000 --> 00:53:28.000]   And so it's only 10 vectors that you have to vector dimension 10.
[00:53:28.000 --> 00:53:31.000]   He's actually some nice illustration of this concept.
[00:53:31.000 --> 00:53:34.000]   So this is a nice kind of cut out.
[00:53:34.000 --> 00:53:43.000]   So this would work by on an image first doing a phase detection, a filter that would look for face patterns across the image.
[00:53:43.000 --> 00:53:47.000]   And then find a few places where there is a good something that looks like a face.
[00:53:47.000 --> 00:53:53.000]   You then around that detection cut out a nice little box that kind of, you know, squares in the face,
[00:53:53.000 --> 00:53:57.000]   samples it at a reasonable resolution, right?
[00:53:57.000 --> 00:54:03.000]   We don't need to have, you know, 1000 pixels on the, we don't need to have 1000 by 1000 pixels on the face.
[00:54:03.000 --> 00:54:06.000]   Maybe 30 by 30 is just fine.
[00:54:06.000 --> 00:54:13.000]   So that's still about 900 or so pixels, for example, here.
[00:54:13.000 --> 00:54:17.000]   And you arrange it in a vector.
[00:54:17.000 --> 00:54:19.000]   That's your observation vector.
[00:54:19.000 --> 00:54:22.000]   You know, first pixel there is the first coefficient.
[00:54:22.000 --> 00:54:25.000]   Second pixel is the second coefficient, et cetera.
[00:54:25.000 --> 00:54:29.000]   But of course you can see that there's huge correlation between all these pixels here.
[00:54:29.000 --> 00:54:32.000]   Also between pixels on this side and picks on that side.
[00:54:32.000 --> 00:54:34.000]   So everything here is more or less mirror image.
[00:54:34.000 --> 00:54:41.000]   So strong correlation there, et cetera, and large areas are also highly correlated, et cetera, et cetera.
[00:54:41.000 --> 00:54:48.000]   Clearly we're probably, you know, we can do better than represented in all these pixels as supposedly independent variables.
[00:54:48.000 --> 00:54:54.000]   So essentially what we have is we have the observed dimensions.
[00:54:54.000 --> 00:55:01.000]   This is really the pixel dimensions, which in this, you know, eventually very high dimensional space,
[00:55:01.000 --> 00:55:03.000]   and we have distance between pixels there.
[00:55:03.000 --> 00:55:07.000]   From that we would like to go to a feature dimension.
[00:55:07.000 --> 00:55:14.000]   This is then, you know, so this is a kind of a general thing.
[00:55:14.000 --> 00:55:18.000]   So we would go from this with a deterministic transformation to a different space,
[00:55:18.000 --> 00:55:24.000]   but we could potentially have a much lower dimensional space here.
[00:55:24.000 --> 00:55:26.000]   We won't cover all of those in detail.
[00:55:26.000 --> 00:55:29.000]   The one we're now talking about is egg and faces.
[00:55:29.000 --> 00:55:33.000]   We'll briefly talk also about feature faces.
[00:55:33.000 --> 00:55:45.000]   But there are also other choices there, but we want more advanced concepts there, which we will not discuss.
[00:55:45.000 --> 00:55:51.000]   But the logic is essentially to do the projection from a high dimensional observation space,
[00:55:51.000 --> 00:55:53.000]   so direct measurements, right?
[00:55:53.000 --> 00:55:57.000]   Your pixels are directly measured in the image as incoming light or so.
[00:55:57.000 --> 00:56:02.000]   Direct measurements projected into a more suitable space to actually measure things.
[00:56:02.000 --> 00:56:04.000]   Typically more compact space also.
[00:56:04.000 --> 00:56:08.000]   Also actually with the added advantage to reduce the noise.
[00:56:08.000 --> 00:56:13.000]   Actually if you think of it, the original image might have been a thousand by a thousand pixels,
[00:56:13.000 --> 00:56:20.000]   and actually going to measure each of those thousand by a thousand pixels and compare them one to one with the ones of a detected face,
[00:56:20.000 --> 00:56:26.000]   you will already have a lot of noise because, you know, any small shift here,
[00:56:26.000 --> 00:56:30.000]   you know, a reasonable alignment will have the nose kind of aligned on the nose,
[00:56:30.000 --> 00:56:39.000]   but if you go to a thousand by a thousand pixels having, you know, the right pixel in your eye and your, you know, iris correlates with the iris of someone else and so on,
[00:56:39.000 --> 00:56:42.000]   this on the pixel by pixel base actually not never going to really align.
[00:56:42.000 --> 00:56:48.000]   Even you with yourself, the slightest misalignment will have all the high frequency kind of misalign.
[00:56:48.000 --> 00:56:56.000]   So if the alignment is only up to a certain resolution, you actually don't want to compare pixels at a resolution beyond the quality of your alignment
[00:56:56.000 --> 00:56:59.000]   because you will just have a degraded result.
[00:56:59.000 --> 00:57:04.000]   In general, it's actually a good idea to project things down,
[00:57:04.000 --> 00:57:07.000]   partially also because of the noise ratio and so on.
[00:57:07.000 --> 00:57:14.000]   One is because you go to a space where most of the energy is captured compactly, so an advantage in computations,
[00:57:14.000 --> 00:57:21.000]   but actually also because you eliminate a lot of small detailed noisy variations
[00:57:21.000 --> 00:57:25.000]   and you have actually a better measurement of what actually matters.
[00:57:25.000 --> 00:57:30.000]   So here's an example of Eigen faces.
[00:57:30.000 --> 00:57:35.000]   Again, really important, don't forget to subtract the average.
[00:57:35.000 --> 00:57:39.000]   In this case, we can call it the average face or the mean face.
[00:57:39.000 --> 00:57:48.000]   So if you take your collection of all these faces, you first compute the average, this one, and you subtract that.
[00:57:48.000 --> 00:58:00.000]   And so the actual identity of a person is now how much the picture of a particular person differs from the average face.
[00:58:00.000 --> 00:58:02.000]   That actually makes sense.
[00:58:02.000 --> 00:58:05.000]   The signal that's in the average face, that's not useful.
[00:58:05.000 --> 00:58:09.000]   What you care about is how different you are from the average in a sense.
[00:58:09.000 --> 00:58:11.000]   That's kind of your identity.
[00:58:11.000 --> 00:58:15.000]   That vector literally represents your identity in this space.
[00:58:15.000 --> 00:58:22.000]   That difference will not represent it as a difference per pixel from the average face,
[00:58:22.000 --> 00:58:25.000]   but as a difference in a different coordinate system.
[00:58:25.000 --> 00:58:32.000]   A coordinate system that's much better suited to actually observe the major differences between faces.
[00:58:32.000 --> 00:58:35.000]   So if we look at this here, what do we see?
[00:58:35.000 --> 00:58:41.000]   For example, any idea what this one kind of correlates to?
[00:58:41.000 --> 00:58:43.000]   Exactly.
[00:58:43.000 --> 00:58:51.000]   So this kind of seems to capture the correlation that in many pictures there seems to be a correlated change.
[00:58:51.000 --> 00:58:55.000]   If this pixel is darker, then this one also tends to be darker.
[00:58:55.000 --> 00:58:56.000]   Why is that?
[00:58:56.000 --> 00:59:00.000]   Well, it's because people tend to have glasses that have all more or less the same shape.
[00:59:00.000 --> 00:59:03.000]   And so whenever it's dark here, it's also dark there and there and there.
[00:59:03.000 --> 00:59:07.000]   And when it's a bright frame, then it's the other way around.
[00:59:07.000 --> 00:59:12.000]   Or in particular, compared to the average face, when it changes in both directions.
[00:59:12.000 --> 00:59:19.000]   This is, again, remember, this is actually linear, meaning that positive and negative correlation always have to go together.
[00:59:19.000 --> 00:59:27.000]   Even if all the glasses are dark, this essentially cannot differentiate between deviating to the dark side and to the brighter side.
[00:59:27.000 --> 00:59:35.000]   So bright glass or dark glasses, they have to be captured in the same linear deviation from the central point.
[00:59:35.000 --> 00:59:40.000]   So even if all the deviations are in one direction, here the vector actually captures both directions at once.
[00:59:40.000 --> 00:59:47.000]   That's again where nonlinear systems like neural networks that introduce nonlinearities can actually start separating those.
[00:59:47.000 --> 00:59:49.000]   But here they would all be captured together.
[00:59:49.000 --> 00:59:50.000]   Anyway, so that's like glasses.
[00:59:50.000 --> 00:59:51.000]   Okay, great.
[00:59:51.000 --> 00:59:58.000]   If you look more at this, like the ones at the top there, the biggest one, because actually they're ordered.
[00:59:58.000 --> 01:00:03.000]   I think they're ordered one, two, three, four, five, six, seven, eight or so, I think.
[01:00:03.000 --> 01:00:07.000]   I'm not actually exactly sure, but I think it's in that order.
[01:00:07.000 --> 01:00:12.000]   You know, the first one, the biggest variation, which is the one associated with the biggest variation.
[01:00:12.000 --> 01:00:14.000]   What, you know, what, what is that one?
[01:00:14.000 --> 01:00:15.000]   So it's not glasses.
[01:00:15.000 --> 01:00:17.000]   What, what is it?
[01:00:17.000 --> 01:00:21.000]   Anyone?
[01:00:21.000 --> 01:00:25.000]   What is captured in that image, in the first image there?
[01:00:25.000 --> 01:00:32.000]   No.
[01:00:32.000 --> 01:00:33.000]   I mean, what do you see?
[01:00:33.000 --> 01:00:38.000]   Maybe someone can describe what they see in that upper left image there.
[01:00:38.000 --> 01:00:48.000]   Yeah, but what's the difference between that image and this image?
[01:00:48.000 --> 01:00:55.000]   Exactly, right?
[01:00:55.000 --> 01:00:57.000]   What you capture there is really lighting.
[01:00:57.000 --> 01:00:59.000]   You have kind of bright lighting from the right side.
[01:00:59.000 --> 01:01:01.000]   That's what's captured there.
[01:01:01.000 --> 01:01:09.000]   You know, and then actually if you look at these also, right, it's not so much identity as really kind of lighting that's captured there.
[01:01:09.000 --> 01:01:13.000]   So that's, you know, something to remember actually we'll get back to that in a few slides.
[01:01:13.000 --> 01:01:14.000]   Okay.
[01:01:14.000 --> 01:01:25.000]   Okay, so this is actually from many years ago, a simple, a simple, a good image for a cognition kind of system.
[01:01:25.000 --> 01:01:39.000]   It was, so given a new image coming in here, it would normalize so a face, a detected face, you know, it would normalize it.
[01:01:39.000 --> 01:01:45.000]   Also, it would subtract the mean face here, the average face, right?
[01:01:45.000 --> 01:01:49.000]   And so the vector that goes through here, you would do a projection.
[01:01:49.000 --> 01:01:54.000]   Okay, so you project it on, on these egg and faces.
[01:01:54.000 --> 01:02:02.000]   So projecting means you take the full image, full resolution image, you subtract it, you subtract the average from it.
[01:02:02.000 --> 01:02:07.000]   Then you multiply coefficient by coefficient.
[01:02:07.000 --> 01:02:19.000]   So pixel per pixel, you multiply your incoming image after you subtracted out this, you multiply it with this image, this image with each of those templates, and you get a coefficient, right?
[01:02:19.000 --> 01:02:20.000]   For each of those.
[01:02:20.000 --> 01:02:21.000]   So that's what you get here.
[01:02:21.000 --> 01:02:28.000]   So you get essentially your image coming in here, you multiply it with this, you get a number of coefficients coming out, right?
[01:02:28.000 --> 01:02:33.000]   Which is simply the product of each of the image, the difference image with each of those, for example.
[01:02:33.000 --> 01:02:38.000]   So in this case, you would get eight numbers, for example, coming out based on the previous image.
[01:02:38.000 --> 01:02:49.000]   And those eight numbers, you will now compare to the pre-computed eight numbers for, for example, eight numbers for each of your database images.
[01:02:49.000 --> 01:02:50.000]   And you get a similarity.
[01:02:50.000 --> 01:02:56.000]   And then you get here a nonlinear simple rejection system, which says it's just a threshold actually.
[01:02:56.000 --> 01:03:15.000]   It says if the difference is smaller than this much, then I will declare, you know, for the best one, if the difference is smaller than a certain number, then I will essentially output the, the coefficient, the, sorry, the identity of the face that I recognize.
[01:03:15.000 --> 01:03:30.000]   So which, which of those, which the, the index of which of those faces it was that I am the closest to, even below a threshold, if not, if I'm not below that threshold, if the error is too big, then I would say, okay, forget it.
[01:03:30.000 --> 01:03:32.000]   This is not good enough.
[01:03:32.000 --> 01:03:34.000]   Okay.
[01:03:34.000 --> 01:03:37.000]   So that's essentially what you would do here.
[01:03:37.000 --> 01:03:38.000]   Okay.
[01:03:38.000 --> 01:03:45.000]   Then, then let me actually show here this video.
[01:03:45.000 --> 01:03:46.000]   Let me see.
[01:03:46.000 --> 01:03:49.000]   Actually, if I can show it, I might have forgotten to update the link.
[01:03:49.000 --> 01:04:11.000]   Okay.
[01:04:11.000 --> 01:04:12.000]   Okay.
[01:04:12.000 --> 01:04:13.000]   Works.
[01:04:13.000 --> 01:04:18.000]   Okay.
[01:04:18.000 --> 01:04:27.000]   Normally, there should be no more face model is derived from a data set of 200 colored 3D scans of faces.
[01:04:27.000 --> 01:04:32.000]   Individual faces are combined into a single morphable model by computing dent.
[01:04:32.000 --> 01:04:35.000]   Actually, let me first give you some, some context here.
[01:04:35.000 --> 01:04:43.000]   So essentially, this is the same idea as we just saw before for two dimensional faces.
[01:04:43.000 --> 01:04:44.000]   Two dimensional faces.
[01:04:44.000 --> 01:04:45.000]   What did we have?
[01:04:45.000 --> 01:04:49.000]   We had, you know, we essentially detected a face.
[01:04:49.000 --> 01:04:57.000]   So detecting the face means we actually found the detection and the localization of the face in the image and cropping, taking a crop.
[01:04:57.000 --> 01:05:06.000]   Then we actually really had determined for, you know, the upper, for you, the upper left pixel, you know, is here and, you know, then the next one.
[01:05:06.000 --> 01:05:15.000]   And so we really, in a sense, had arranged for an alignment pixel to pixel so that we can, could then meaningfully subtract the average.
[01:05:15.000 --> 01:05:18.000]   And then, you know, project on the different basis functions.
[01:05:18.000 --> 01:05:26.000]   And if we actually collected a lot of images this way, we could actually take that whole collection and compute this SVD from this matrix of faces and so on and so on.
[01:05:26.000 --> 01:05:27.000]   Right.
[01:05:27.000 --> 01:05:34.000]   Here, we essentially do the same, but with three these cans of faces.
[01:05:34.000 --> 01:05:35.000]   Okay.
[01:05:35.000 --> 01:05:42.000]   So the same concept of actually cropping out nicely and getting that alignment that the nose pixel corresponds to the nose pixel and you know, etc.
[01:05:42.000 --> 01:05:49.000]   The eyes correspond to the eyes by finding the face and aligning it properly and cutting it out consistently between all the images.
[01:05:49.000 --> 01:05:51.000]   That's how you get correlation.
[01:05:51.000 --> 01:06:06.000]   If you do a message job at aligning, notice this will, the correlation will be terrible because if the nose moves around in your detected image, it means that suddenly, you know, you cannot predict anymore so well what, you know, where the nose would be and therefore you have to start
[01:06:06.000 --> 01:06:13.000]   modeling, you know, nose in many different locations and you need a lot more basis images to actually represent faces if you don't have a good alignment.
[01:06:13.000 --> 01:06:14.000]   Okay.
[01:06:14.000 --> 01:06:16.000]   Here also in 3D, they'll do the same thing.
[01:06:16.000 --> 01:06:18.000]   They actually had scans of people faces.
[01:06:18.000 --> 01:06:22.000]   They all carefully aligned those ahead of time.
[01:06:22.000 --> 01:06:30.000]   And then you'll see they'll actually look at the face at the color of the face, but also the geometry of the face.
[01:06:30.000 --> 01:06:36.000]   But for that, they first had to create an alignment between all those 3D faces to each other.
[01:06:36.000 --> 01:06:37.000]   So that's what they do.
[01:06:37.000 --> 01:06:47.000]   And so in a sense, instead of having just a grayscale image as we had before, so a single value, what they do here is they actually at every location.
[01:06:47.000 --> 01:06:50.000]   They have six values.
[01:06:50.000 --> 01:06:52.000]   What are those six values?
[01:06:52.000 --> 01:06:59.000]   R, G, B, so color, X, Y and Z.
[01:06:59.000 --> 01:07:02.000]   The 3D coordinates of the point.
[01:07:02.000 --> 01:07:03.000]   But of course they need alignment.
[01:07:03.000 --> 01:07:06.000]   So they need the XYZ coordinate of the point on the nose.
[01:07:06.000 --> 01:07:09.000]   They need the XYZ coordinate of, you know, a particular point here.
[01:07:09.000 --> 01:07:12.000]   So they need like alignment of all the 3D faces to each other.
[01:07:12.000 --> 01:07:15.000]   But once they have that, they can actually compute things that way.
[01:07:15.000 --> 01:07:18.000]   So it's really exactly the same thing as before.
[01:07:18.000 --> 01:07:22.000]   Now you have XYZ, RGB coordinates.
[01:07:22.000 --> 01:07:25.000]   So you have like six values, but that's okay.
[01:07:25.000 --> 01:07:32.000]   If you linearize in a long vector, you know, instead of having every pixel just have one value, you can now have every pixel have six values.
[01:07:32.000 --> 01:07:33.000]   It doesn't actually matter.
[01:07:33.000 --> 01:07:35.000]   You just have a longer vector.
[01:07:35.000 --> 01:07:39.000]   It's still just a vector and you still can subtract the average.
[01:07:39.000 --> 01:07:42.000]   Once you align everything, you subtract the average, you do SVD, blah, blah, blah.
[01:07:42.000 --> 01:07:44.000]   It all still is exactly the same thing.
[01:07:44.000 --> 01:07:48.000]   Okay. So let me continue playing the video now.
[01:07:48.000 --> 01:07:50.000]   So it's actually very nice illustration.
[01:07:50.000 --> 01:07:57.000]   The key author here was Thomas Vetter, who's a professor at the University of Basel actually.
[01:07:57.000 --> 01:08:01.000]   But this was, you know, when he was still, this was still earlier before he was.
[01:08:01.000 --> 01:08:04.000]   Point correspondences to a reference face.
[01:08:04.000 --> 01:08:10.000]   A modified optic flow algorithm establishes 3D correspondence automatically.
[01:08:10.000 --> 01:08:13.000]   We'll actually talk about optical flow next week.
[01:08:13.000 --> 01:08:27.000]   Okay. So, but it's about finding correspondences between, you know, in this case, it's like different faces will do it in video between from one video frame to the next.
[01:08:27.000 --> 01:08:37.000]   The morphable model combines 3D shape and texture information of all example faces into one vector space of faces.
[01:08:37.000 --> 01:08:49.000]   We can form arbitrary linear combinations of the examples and generate continuous transitions.
[01:08:49.000 --> 01:09:04.000]   Starting from the average face, individual original faces are caricatured by increasing their distance from the average.
[01:09:04.000 --> 01:09:25.000]   Forming the average for male and female faces separately, the difference can be added to or subtracted from an individual face to change the perceived gender.
[01:09:25.000 --> 01:09:33.000]   Other facial attributes, such as the fullness of a face, can be manipulated in a similar way.
[01:09:33.000 --> 01:09:38.000]   From a labeled set of faces, the characteristic changes are extracted automatically.
[01:09:38.000 --> 01:09:42.000]   In our model, they're controlled by a single parameter.
[01:09:42.000 --> 01:09:58.000]   Differences in facial expressions captured from another face can be mapped to any individual.
[01:09:58.000 --> 01:10:07.000]   We now reconstruct 3D shape and texture in order to animate a face, given only a single photograph of a person.
[01:10:07.000 --> 01:10:20.000]   First, we manually align the average face to the target image, roughly estimating position, size, orientation, and illumination.
[01:10:20.000 --> 01:10:28.000]   Then, a fully automated algorithm finds the best reconstruction of the face within the morphable model.
[01:10:28.000 --> 01:10:40.000]   3D shape and texture are optimized along with parameters such as size, orientation, and color contrast.
[01:10:40.000 --> 01:10:48.000]   The output is a high resolution 3D mesh of the face.
[01:10:48.000 --> 01:11:05.000]   This is an estimate of 3D shape and surface colors based on a single image.
[01:11:05.000 --> 01:11:14.000]   Additional texture extraction improves details and texture.
[01:11:14.000 --> 01:11:20.000]   The construction can now be rendered into the image, and a whole range of facial variations can be applied.
[01:11:20.000 --> 01:11:32.000]   Here we simulate weight gain and weight loss.
[01:11:32.000 --> 01:11:45.000]   Facial expression can be post-processed in images, forcing a face to frown or to smile.
[01:11:45.000 --> 01:11:54.000]   From this image, we also estimated 3D shape and texture and combined the photograph with 3D computer graphics.
[01:11:54.000 --> 01:11:59.000]   Cast shadows of novel objects are rendered correctly into the scene.
[01:11:59.000 --> 01:12:27.000]   Illumination conditions can be changed and pose can be varied to some extent.
[01:12:27.000 --> 01:12:32.000]   From a single black and white image, we obtain a full estimate of 3D shape.
[01:12:32.000 --> 01:12:48.000]   The result of the matching procedure includes an estimate of surface color since the morphable model contains color information.
[01:12:48.000 --> 01:13:13.000]   Finally, we show the application of our model to a painting.
[01:13:13.000 --> 01:13:23.000]   This is all purely linear.
[01:13:23.000 --> 01:13:28.000]   The morphable face model is derived from a data system.
[01:13:28.000 --> 01:13:38.000]   Linear models can be powerful with the right amount of data and linear fits to the data.
[01:13:38.000 --> 01:13:48.000]   On top of that, people will bring in nonlinear methods, neural networks that will mostly start from there, but then add additional capabilities.
[01:13:48.000 --> 01:14:10.000]   This is quite impressive what you can get out of this.
[01:14:10.000 --> 01:14:18.000]   In many ways, you could actually see this as training.
[01:14:18.000 --> 01:14:25.000]   It is essentially just computing an SVD on a big matrix.
[01:14:25.000 --> 01:14:35.000]   This is where I want you to learn in this course.
[01:14:35.000 --> 01:14:46.000]   You have the understanding of what is happening here with the simple linear methods and what you can already capture.
[01:14:46.000 --> 01:15:05.000]   In the end, 90% of what is happening is probably this stuff with some additional capabilities captured by having nonlinear representations.
[01:15:05.000 --> 01:15:15.000]   In terms of how many you have to use, I think in this case they only used, I think, I am not exactly sure anymore, but I think it was maybe 256 scans only.
[01:15:15.000 --> 01:15:18.000]   It was actually quite a small number.
[01:15:18.000 --> 01:15:32.000]   The reason is, so essentially, the reason that they could use that small of a number is because they strongly normalize the problem.
[01:15:32.000 --> 01:15:35.000]   What do I mean by that?
[01:15:35.000 --> 01:15:42.000]   If you would try to train a neural network to do similar things, but you do not help it by aligning the pictures.
[01:15:42.000 --> 01:15:44.000]   Remember, here they had the alignment.
[01:15:44.000 --> 01:15:59.000]   If you do not help it to align the pictures in advance, you are essentially just providing it random images with random lighting, with random poses.
[01:15:59.000 --> 01:16:13.000]   Then you actually have to explicitly, in a sampling way, and actually also there, the sampling that we learned here is relevant also for that, the understanding of how that works.
[01:16:13.000 --> 01:16:23.000]   You essentially have to sample every possible pose, multiply it with every possible lighting, multiply it with every possible identity.
[01:16:23.000 --> 01:16:43.000]   If you need 100 samples, or let's say 50 samples for pose, and you need, let's say, 50 samples for illumination, and you need 250 for identity, then the number of data points you need is 50 times 50 times 250, or something like that.
[01:16:43.000 --> 01:16:45.000]   Then you need many, many images.
[01:16:45.000 --> 01:16:50.000]   If you actually take out some of those variations, you normalize for lighting.
[01:16:50.000 --> 01:16:52.000]   How did they normalize for lighting?
[01:16:52.000 --> 01:16:57.000]   They had all those 256 people, or whatever the number was, but I think it was really in that order.
[01:16:57.000 --> 01:16:59.000]   They all had them sit down on a chair.
[01:16:59.000 --> 01:17:04.000]   They had a special setup that would capture them with the same lighting, same everything, fully controlled.
[01:17:04.000 --> 01:17:06.000]   Therefore, there was no pose variation.
[01:17:06.000 --> 01:17:07.000]   There was no light variation.
[01:17:07.000 --> 01:17:15.000]   They actually made sure they, as they told you, they actually did a modified optical flow to get a one-to-one kind of correspondence between all the points on the face and so on.
[01:17:15.000 --> 01:17:25.000]   All that variability was gone, and then just the identity, you know, with a few hundred faces, they actually could capture, you know, enough variability.
[01:17:25.000 --> 01:17:30.000]   I mean, more faces would probably be better, but it was already enough to do quite impressive things.
[01:17:30.000 --> 01:17:34.000]   So that's the way, you know, that's how, that's what you have to remember.
[01:17:34.000 --> 01:17:38.000]   It depends on the size of the space you have to, in a sense, sample with your data.
[01:17:38.000 --> 01:17:50.000]   If you normalize your space, then if there's only one dimension or a few dimensions of variability, then a few points, you know, randomly distributed there will be good enough to capture that.
[01:17:50.000 --> 01:17:59.000]   If you live in a lot of kind of uncorrelated variations, then, you know, you might have to sample many, many times more,
[01:17:59.000 --> 01:18:05.000]   because the space that intrinsically you're trying to capture is a space with a lot more variability.
[01:18:05.000 --> 01:18:16.000]   You know, this is when cell driving car companies want to capture what happens in the street, you know, by driving around and just capture situations.
[01:18:16.000 --> 01:18:22.000]   Well, the problem is the relevant situations come with this really long tail.
[01:18:22.000 --> 01:18:31.000]   So, you know, just driving around like nothing happens, you drive straight, people around you drive normally, pedestrians do no crazy things, etc.
[01:18:31.000 --> 01:18:35.000]   That's pretty quick to capture enough to understand that.
[01:18:35.000 --> 01:18:41.000]   But if you actually need to also be able to react to surprises, you actually need to capture enough of those and so on.
[01:18:41.000 --> 01:18:46.000]   So that's where certainly the sampling becomes very difficult to actually get enough examples of everything,
[01:18:46.000 --> 01:18:50.000]   especially if you want to do end-to-end deep learning where you're not normalizing things.
[01:18:50.000 --> 01:19:00.000]   And so if you've seen it like, I mean, in the end, with the right algorithms, you know, somewhere there's the input space and the output space.
[01:19:00.000 --> 01:19:07.000]   But in between there might be a latent space that captures in a sense the intrinsic dimensionality of things.
[01:19:07.000 --> 01:19:11.000]   Okay, in this case, the latent space is very simple.
[01:19:11.000 --> 01:19:13.000]   It's like the dimensionality here that's relevant.
[01:19:13.000 --> 01:19:16.000]   Okay, how many singular values are different here?
[01:19:16.000 --> 01:19:17.000]   It's actually very simple.
[01:19:17.000 --> 01:19:20.000]   The dimensionality of the problem intrinsically.
[01:19:20.000 --> 01:19:23.000]   We're really capturing this by looking at the data.
[01:19:23.000 --> 01:19:28.000]   Also, again, here you can really directly understand this just mathematically get the number.
[01:19:28.000 --> 01:19:31.000]   You look at this matrix here.
[01:19:31.000 --> 01:19:33.000]   How many phases do you need to capture?
[01:19:33.000 --> 01:19:36.000]   Well, you don't know, but, you know, you capture a whole bunch of phases.
[01:19:36.000 --> 01:19:38.000]   You do the singular value decomposition.
[01:19:38.000 --> 01:19:45.000]   And if you see that, you know, after a hundred values, like the rest is really irrelevant,
[01:19:45.000 --> 01:19:52.000]   you can model every phase that you keep adding to your data set is already perfectly modeled inside the space of, you know,
[01:19:52.000 --> 01:19:58.000]   your hundred first singular values, for example, for the veteran Lance model, for example.
[01:19:58.000 --> 01:20:01.000]   Well, you know, then there's really not much more to be captured, right?
[01:20:01.000 --> 01:20:07.000]   If you can capture 99% of the appearance of the phase from your first hundred singular values,
[01:20:07.000 --> 01:20:12.000]   it means intrinsically you actually didn't need more than a hundred phases to actually capture this.
[01:20:12.000 --> 01:20:15.000]   If you have hundreds randomly distributed phases, you should actually have had captures.
[01:20:15.000 --> 01:20:18.000]   Now, if you only take a hundred phases, you don't know this, right?
[01:20:18.000 --> 01:20:23.000]   It's only once you capture 200 phases that you see what actually, you know, a hundred is good enough.
[01:20:23.000 --> 01:20:28.000]   Having had 200 is still good because it will have reduced the noise on your, you know,
[01:20:28.000 --> 01:20:32.000]   a hundred dimensional space of how phases, you know, typically look like and so on,
[01:20:32.000 --> 01:20:36.000]   because it averages out a bit the noise and so on, right?
[01:20:36.000 --> 01:20:41.000]   Okay, so those are some of the insights on to know the dimensionality of the problem.
[01:20:41.000 --> 01:20:43.000]   Literally in the linear space is pretty easy.
[01:20:43.000 --> 01:20:47.000]   It's you just look at a single values and see how many are actually useful.
[01:20:47.000 --> 01:20:50.000]   Okay, and that really depends on what you want to do.
[01:20:50.000 --> 01:20:59.000]   Being able to still see the difference between people might need less than being able to have a fully photorealistic representation of every single person.
[01:20:59.000 --> 01:21:05.000]   You know, and then if you have like a Tom Hanks, you know, like really be able to recognize the, you know,
[01:21:05.000 --> 01:21:09.000]   once you project in this lower dimensional space to recognize Tom Hanks, you know,
[01:21:09.000 --> 01:21:13.000]   you might need a little bit more than just being able to differentiate between people, for example, right?
[01:21:13.000 --> 01:21:19.000]   Differentiating between people means preserving of difference, you know,
[01:21:19.000 --> 01:21:24.000]   so that you can still tell them apart, being able to, you be happy and, you know,
[01:21:24.000 --> 01:21:28.000]   you'll be able to see that it's Tom Hanks might be another level of, you know,
[01:21:28.000 --> 01:21:31.000]   you might see like, well, it looks like Tom Hanks a bit, but it's not quite him.
[01:21:31.000 --> 01:21:35.000]   There's something off, you know, like, because there's still too much error that you left in,
[01:21:35.000 --> 01:21:40.000]   although it would be enough to recognize him compared to the rest of the people in database.
[01:21:40.000 --> 01:21:46.000]   It might not be enough to, you know, have you think it's a photorealistic representation of the actor, right?
[01:21:46.000 --> 01:21:54.000]   Okay, so again, we start from, we know, you know, here we normalize the pose.
[01:21:54.000 --> 01:21:58.000]   Notice it's just a frontal pose, right?
[01:21:58.000 --> 01:22:01.000]   Pixel by pixel correspondence is what we assume here and so on.
[01:22:01.000 --> 01:22:05.000]   Assuming that, you know, we do that, we subtract the average face,
[01:22:05.000 --> 01:22:11.000]   we get same dimension of matrix, we simplify that by doing ceiling of value decomposition,
[01:22:11.000 --> 01:22:16.000]   we clip it to a smaller set of singular values, whatever is relevant to our problem,
[01:22:16.000 --> 01:22:21.000]   like which error can we ignore? Essentially here, this determines how much we can clip off
[01:22:21.000 --> 01:22:23.000]   and how compact we can make it.
[01:22:23.000 --> 01:22:29.000]   And then we can do the sum of square difference matching in the approximate space here.
[01:22:29.000 --> 01:22:32.000]   And so be more efficient. Essentially, we're doing something like this.
[01:22:32.000 --> 01:22:36.000]   We represent the face as the average face plus a number of coefficients,
[01:22:36.000 --> 01:22:42.000]   meaning what we actually do is we subtract this and then we project on those coefficients, right?
[01:22:42.000 --> 01:22:47.000]   So multiply which is each of those images and get one scalar per product here.
[01:22:47.000 --> 01:22:53.000]   We do the inner product between this and the actual face with this subtracted out.
[01:22:53.000 --> 01:22:59.000]   Okay? And then we can easily compare in this coefficient space.
[01:22:59.000 --> 01:23:05.000]   Okay? Okay, so now we'll continue with this on Thursday,
[01:23:05.000 --> 01:23:12.000]   but essentially something really interesting here, which shows the limitations of egg and faces.
[01:23:12.000 --> 01:23:18.000]   So here people looked at differences due to varying elimination
[01:23:18.000 --> 01:23:24.000]   and seeing that those can actually be much more important than the actual differences between faces.
[01:23:24.000 --> 01:23:33.000]   Okay? So what those guys did here was they looked at the error.
[01:23:33.000 --> 01:23:38.000]   They got in a simple -- this is with the number of principal components.
[01:23:38.000 --> 01:23:42.000]   So from 0 to 150 here.
[01:23:42.000 --> 01:23:47.000]   So this is -- the principal component is how many singular values where they're actually using, right?
[01:23:47.000 --> 01:23:55.000]   They looked at this from 0 to 150 here and looked at how the error in recognition --
[01:23:55.000 --> 01:24:00.000]   so they took a vector, you know, they took the first 50, for example,
[01:24:00.000 --> 01:24:03.000]   and so they had a -- you know, instead of the fulls every pixel,
[01:24:03.000 --> 01:24:09.000]   they just took the first 50 coefficients after going to the egg and face space
[01:24:09.000 --> 01:24:15.000]   and correlated it with the incoming vector and then saw how often they found the correct one versus the incorrect one.
[01:24:15.000 --> 01:24:18.000]   And I'm not sure exactly -- so this is the error rate they had,
[01:24:18.000 --> 01:24:23.000]   and I'm not sure exactly how big the database was they were comparing to, so how hard the problem was.
[01:24:23.000 --> 01:24:26.000]   Obviously if you only compare to two faces, which of the two is it,
[01:24:26.000 --> 01:24:29.000]   that's an easier problem than if you have a thousand faces in your database,
[01:24:29.000 --> 01:24:33.000]   because then the random distance between faces is going to be a lot smaller,
[01:24:33.000 --> 01:24:37.000]   and a small mistake could already make you recognize the wrong face, right?
[01:24:37.000 --> 01:24:42.000]   Anyways, they were getting an error rate as soon as they had --
[01:24:42.000 --> 01:24:49.000]   so you see here they needed about, say, 30 faces, 30 egg and faces, 30 coefficients,
[01:24:49.000 --> 01:24:54.000]   to get a decent recognition, but then adding more didn't help, okay?
[01:24:54.000 --> 01:25:00.000]   So using a more model that better approximates the original face was actually not helping them.
[01:25:00.000 --> 01:25:05.000]   And then something very interesting, if they had dropped the three first coefficients,
[01:25:05.000 --> 01:25:09.000]   they actually did a lot better, a lot less error, right?
[01:25:09.000 --> 01:25:14.000]   They went from 25% error to 15% error, or like even a bit below that.
[01:25:14.000 --> 01:25:23.000]   So why is that? Well, you know, it has to do with the elimination that was in the database here,
[01:25:23.000 --> 01:25:26.000]   the elimination change. If we look back here, right?
[01:25:26.000 --> 01:25:31.000]   If you look at the first three here, it's mostly capturing elimination changes.
[01:25:31.000 --> 01:25:40.000]   So it means that most of the energy, you know, the differences between images is mostly captured here,
[01:25:40.000 --> 01:25:46.000]   which means that even my database, if people start with someone has light from here in the database,
[01:25:46.000 --> 01:25:49.000]   and someone else is stored with light from there in the database,
[01:25:49.000 --> 01:25:55.000]   but now that person actually have a query image with a light not here, but over here,
[01:25:55.000 --> 01:26:01.000]   then this picture of that person, of the person that was in the database with the light over here,
[01:26:01.000 --> 01:26:06.000]   suddenly that picture might actually look much closer in the difference to this other person,
[01:26:06.000 --> 01:26:10.000]   but that had light from the same side in the database.
[01:26:10.000 --> 01:26:13.000]   So essentially that's because these are the biggest coefficients,
[01:26:13.000 --> 01:26:19.000]   so that's where most of the energy is actually in the lighting and not in the identity.
[01:26:19.000 --> 01:26:24.000]   So that was essentially, that's the problem that is illustrated here,
[01:26:24.000 --> 01:26:33.000]   that if you take away the first three coefficients, this actually corresponds to this,
[01:26:33.000 --> 01:26:38.000]   that this actually does better, and that's because those first three actually irrelevant variations,
[01:26:38.000 --> 01:26:44.000]   and so if you actually take them out, you do better.
[01:26:44.000 --> 01:26:50.000]   So we want, I won't have the time to explain this today, but just like to get started,
[01:26:50.000 --> 01:26:58.000]   the idea is that we have, let's say here one, two, three, four, five classes, five people, five individuals,
[01:26:58.000 --> 01:27:04.000]   and we want to differentiate between those five individuals.
[01:27:04.000 --> 01:27:08.000]   So essentially we have, you know, this is the center of each of those,
[01:27:08.000 --> 01:27:14.000]   this is the average of the red individual and the average of the gray individual, etc.
[01:27:14.000 --> 01:27:21.000]   And what we want to do is, we want to somehow ignore,
[01:27:21.000 --> 01:27:27.000]   we want to treat differently the variation within an individual and the variation across individuals.
[01:27:27.000 --> 01:27:33.000]   And we care about the variation across individuals and we don't care about the variation within an individual.
[01:27:33.000 --> 01:27:41.000]   If my task is, again it depends on the task, if my task is to determine what is the identity of the person,
[01:27:41.000 --> 01:27:49.000]   then I care about the difference between individuals, I don't care about, you know, how the individual appearance can vary.
[01:27:49.000 --> 01:27:54.000]   Actually I'm going to care about to model it and then to explicitly ignore it.
[01:27:54.000 --> 01:28:00.000]   That's what we'll see next week, how you can also with linear algorithms actually do something quite interesting there.
[01:28:00.000 --> 01:28:02.000]   Okay, so we see that on Thursday.
[01:28:02.000 --> 01:28:05.360]   [APPLAUSE]
[01:28:05.360 --> 01:28:08.040]   (audience applauding)

