
[00:00:00.000 --> 00:00:02.760]   Okay, good morning everyone.
[00:00:02.760 --> 00:00:05.200]   So I guess it's also probably
[00:00:05.200 --> 00:00:08.320]   the first lecture of the semester or second already, first.
[00:00:08.320 --> 00:00:11.480]   Okay. So for me also.
[00:00:11.480 --> 00:00:17.400]   So today, so this is Visual Computing.
[00:00:17.400 --> 00:00:21.040]   I'm Mike Polofes and I will teach
[00:00:21.040 --> 00:00:23.480]   the first part of this lecture,
[00:00:23.480 --> 00:00:26.960]   which is mostly so Visual Computing consists both
[00:00:26.960 --> 00:00:31.120]   of processing images.
[00:00:31.120 --> 00:00:32.400]   So your given images,
[00:00:32.400 --> 00:00:35.800]   you will look at how to analyze and process them,
[00:00:35.800 --> 00:00:39.720]   then we'll also look at how to computationally generate images.
[00:00:39.720 --> 00:00:42.000]   So in some sense, image processing,
[00:00:42.000 --> 00:00:44.880]   image analysis, computer vision, on one hand,
[00:00:44.880 --> 00:00:46.120]   that's the part I'll be covering,
[00:00:46.120 --> 00:00:47.960]   that's the first half of the semester.
[00:00:47.960 --> 00:00:50.600]   Then second half, it's more going to be
[00:00:50.600 --> 00:00:52.760]   focused very complementary aspect,
[00:00:52.760 --> 00:00:54.520]   which is then computer graphics,
[00:00:54.520 --> 00:00:57.720]   generating images from models.
[00:00:57.720 --> 00:01:00.360]   And that will be by,
[00:01:00.360 --> 00:01:02.320]   taught by Marcus Kroes,
[00:01:02.320 --> 00:01:05.200]   I think I type for there.
[00:01:05.200 --> 00:01:09.280]   Also for the assistants,
[00:01:09.280 --> 00:01:11.560]   there will be for each part,
[00:01:11.560 --> 00:01:13.840]   a main assistant responsible.
[00:01:13.840 --> 00:01:19.880]   So Philip Lindenberger will be in charge of the first half of the semester.
[00:01:19.880 --> 00:01:22.480]   There will be of course other assistants also,
[00:01:22.480 --> 00:01:26.600]   but he can be your point of contact if you have any questions or things like that.
[00:01:26.600 --> 00:01:28.600]   And then for the,
[00:01:28.600 --> 00:01:31.200]   oh sorry, there's a mistake here.
[00:01:31.200 --> 00:01:33.360]   For the second part,
[00:01:33.360 --> 00:01:35.560]   the part taught by Marcus Kroes,
[00:01:35.560 --> 00:01:38.640]   it will be RFL,
[00:01:38.640 --> 00:01:48.960]   The topics of the lecture in the first part,
[00:01:48.960 --> 00:01:53.600]   we'll essentially start by looking at what are images,
[00:01:53.600 --> 00:01:56.320]   what are digital images in particular,
[00:01:56.320 --> 00:01:58.760]   how do we represent images,
[00:01:58.760 --> 00:02:01.880]   how do we represent them in a digital form,
[00:02:01.880 --> 00:02:07.160]   both geometrically as a grid of numbers,
[00:02:07.160 --> 00:02:09.440]   numbers indicating,
[00:02:09.440 --> 00:02:13.480]   reflecting a particular physical property that's captured in the image.
[00:02:13.480 --> 00:02:17.800]   The image in the end is from a particular point of view,
[00:02:17.800 --> 00:02:21.080]   an impression of how much light comes from,
[00:02:21.080 --> 00:02:23.200]   gets reflected typically from light source,
[00:02:23.200 --> 00:02:26.280]   gets reflected by the scene and comes to us
[00:02:26.280 --> 00:02:28.480]   from every direction a different amount of light,
[00:02:28.480 --> 00:02:32.680]   that's at some level what is an image.
[00:02:32.680 --> 00:02:35.760]   So we look at how to represent that digitally.
[00:02:35.760 --> 00:02:39.680]   Also we'll talk a little bit about what are the sensors,
[00:02:39.680 --> 00:02:44.560]   what is the underlying technology that allows us to build up images
[00:02:44.560 --> 00:02:46.960]   in a way that we can recognize those images then later
[00:02:46.960 --> 00:02:50.200]   when we show them on a display,
[00:02:50.200 --> 00:02:52.600]   so that they essentially mimic in a sense
[00:02:52.600 --> 00:02:59.120]   the processes that we perceive the world with our eyes,
[00:02:59.120 --> 00:03:02.680]   and what is the technology that allows us to mimic that process
[00:03:02.680 --> 00:03:04.960]   in a certain way,
[00:03:04.960 --> 00:03:10.960]   although then in practice it works quite differently from our eyes,
[00:03:10.960 --> 00:03:13.920]   but it's a process that works well and is adapted
[00:03:13.920 --> 00:03:17.160]   to digital manipulation, digital processing,
[00:03:17.160 --> 00:03:20.440]   and also just to afterwards render on a digital screen
[00:03:20.440 --> 00:03:23.800]   like this one or this one.
[00:03:23.800 --> 00:03:26.840]   Okay, then we'll talk about,
[00:03:26.840 --> 00:03:32.440]   we'll look a little bit at some processes that we can do on images,
[00:03:32.440 --> 00:03:36.520]   we'll look at a very simple problem of segmentation,
[00:03:36.520 --> 00:03:40.120]   there can be very complicated problems in segmentation,
[00:03:40.120 --> 00:03:46.320]   but segmentation essentially somehow separating the images in two parts.
[00:03:46.320 --> 00:03:49.320]   Let's say in the simplest or conceptually the simplest way to explain it,
[00:03:49.320 --> 00:03:52.520]   there's a part of the image that interests us that we care about
[00:03:52.520 --> 00:03:54.720]   and then there's a part that we don't care about.
[00:03:54.720 --> 00:03:58.520]   You could call it foreground and background,
[00:03:58.520 --> 00:04:04.720]   if you have, for example, when people present the weather,
[00:04:04.720 --> 00:04:07.360]   they are waving at a screen,
[00:04:07.360 --> 00:04:09.520]   these days it's mostly a digital screen behind them
[00:04:09.520 --> 00:04:11.320]   because in the meanwhile people have figured out
[00:04:11.320 --> 00:04:14.520]   how to properly align a digital screen and cameras
[00:04:14.520 --> 00:04:17.320]   and have all of those things work properly together.
[00:04:17.320 --> 00:04:20.120]   There was actually a time where these things didn't work so well together
[00:04:20.120 --> 00:04:22.920]   and so they had to, in post-production,
[00:04:22.920 --> 00:04:29.920]   or the weather person was just looking at a green screen and waving about
[00:04:29.920 --> 00:04:33.720]   and on TV it would appear as if there was a map,
[00:04:33.720 --> 00:04:37.320]   but the person himself wasn't actually seeing the map that they were waving at,
[00:04:37.320 --> 00:04:39.920]   which could lead to confusion,
[00:04:39.920 --> 00:04:44.320]   but there to be able to do that they would have to segment the foreground from the background.
[00:04:44.320 --> 00:04:48.120]   They would cut out the person and leave the green background out.
[00:04:48.120 --> 00:04:52.320]   They would select the interesting part, the foreground,
[00:04:52.320 --> 00:04:56.320]   and then separate it from the pixels, the points,
[00:04:56.320 --> 00:05:00.920]   the parts of the image that form the background.
[00:05:00.920 --> 00:05:05.320]   It can also be looking at an image, a medical image,
[00:05:05.320 --> 00:05:09.320]   and deciding what part might be a tumor
[00:05:09.320 --> 00:05:14.320]   and what part is just a normal image of a healthy human being.
[00:05:14.320 --> 00:05:18.320]   That's also foreground, background, separating in the interesting part.
[00:05:18.320 --> 00:05:21.320]   You hope there's no interesting part in that case,
[00:05:21.320 --> 00:05:23.320]   but it's separating that interesting part,
[00:05:23.320 --> 00:05:28.320]   the part you want to look at carefully from the normal stuff, the background.
[00:05:28.320 --> 00:05:31.320]   We look at that kind of two-class segmentation,
[00:05:31.320 --> 00:05:34.320]   segmenting in foreground and background.
[00:05:34.320 --> 00:05:41.320]   There are many more general or more advanced versions of this problem also.
[00:05:41.320 --> 00:05:46.320]   Most recently, MetaLabs came out with Segment Anything,
[00:05:46.320 --> 00:05:52.320]   which is a very advanced way of generating segmentations in images
[00:05:52.320 --> 00:05:56.320]   based on a ton of training data and so on and so on.
[00:05:56.320 --> 00:06:01.320]   Throughout the lectures, we won't go too deep into that, these most modern methods,
[00:06:01.320 --> 00:06:07.320]   but we will at the end talk a little bit about convolutional neural networks.
[00:06:07.320 --> 00:06:14.320]   All of these neural network-based, AI-based methods that you see these days,
[00:06:14.320 --> 00:06:21.320]   however, everything you'll see in this lecture is actually relevant
[00:06:21.320 --> 00:06:23.320]   to build up these networks and all of those things.
[00:06:23.320 --> 00:06:29.320]   You'll see really in this lecture the basis that then allows you to not just run a few scripts
[00:06:29.320 --> 00:06:32.320]   and try out some cool neural net demos or so,
[00:06:32.320 --> 00:06:39.320]   but you'll actually learn how those computer vision, convolutional neural networks
[00:06:39.320 --> 00:06:44.320]   and other type of things that kind of grant basis layers for that,
[00:06:44.320 --> 00:06:46.320]   the basic image processing steps.
[00:06:46.320 --> 00:06:51.320]   Many of the image processing steps that we'll see throughout the lecture
[00:06:51.320 --> 00:06:57.320]   actually come together in our all present in one form or the other
[00:06:57.320 --> 00:07:01.320]   in many of those more modern methods then.
[00:07:01.320 --> 00:07:07.320]   After segmentation and then also a little bit of morphology,
[00:07:07.320 --> 00:07:16.320]   which is mostly related to looking at if you have a particular point in the image,
[00:07:16.320 --> 00:07:21.320]   which we'll call pixels like pixel element, picture element.
[00:07:21.320 --> 00:07:25.320]   It's the atom, let's say, of which you construct images.
[00:07:25.320 --> 00:07:31.320]   It's point measurements of the quantity, for example, the light that we're interested in.
[00:07:31.320 --> 00:07:38.320]   It's that an image is not just a random assembly of those picture elements,
[00:07:38.320 --> 00:07:40.320]   but they actually have a structure.
[00:07:40.320 --> 00:07:45.320]   A pixel has a well-defined neighborhood of pixels that are next to it,
[00:07:45.320 --> 00:07:47.320]   and there might be some relationship.
[00:07:47.320 --> 00:07:53.320]   We might say, well, if this pixel was not part of a segmentation,
[00:07:53.320 --> 00:07:57.320]   but all the neighbors are part of, then we might decide that we flip that pixel over
[00:07:57.320 --> 00:07:59.320]   to be also part of the segmentation.
[00:07:59.320 --> 00:08:03.320]   These type of processes that are kind of based on neighborhoods and so on,
[00:08:03.320 --> 00:08:05.320]   we'll briefly look at that.
[00:08:05.320 --> 00:08:11.320]   After that, we'll come to convolutions,
[00:08:11.320 --> 00:08:15.320]   which also, for example, here at the base of convolutional neural nets,
[00:08:15.320 --> 00:08:19.320]   one of the key elements in it.
[00:08:19.320 --> 00:08:25.320]   So convolutions are, we'll also then, you know,
[00:08:25.320 --> 00:08:30.320]   convolutions and free transforms and filters, all of these belong together.
[00:08:30.320 --> 00:08:42.320]   Convolutions are the, when you look at a particular pixel element in the image,
[00:08:42.320 --> 00:08:46.320]   you would also look at its neighborhood and you would generate a function
[00:08:46.320 --> 00:08:55.320]   that somehow combines, you know, it would, so it's, you know,
[00:08:55.320 --> 00:08:58.320]   I won't explain it now in detail or so, but it's essentially the type of process
[00:08:58.320 --> 00:09:03.320]   that allows you to, for example, model an image, if you start from an image,
[00:09:03.320 --> 00:09:08.320]   and you, you know, there's a process that would blur the image, for example, right?
[00:09:08.320 --> 00:09:12.320]   Physically, that would happen by, for example, you know, putting,
[00:09:12.320 --> 00:09:17.320]   if your lens is out of focus, then the light that's supposed to land on a single,
[00:09:17.320 --> 00:09:22.320]   at a single point and give a sharp image, if your lens is slightly out of focus,
[00:09:22.320 --> 00:09:25.320]   that light would actually end up not landing where it's supposed to be,
[00:09:25.320 --> 00:09:27.320]   but be spread out a little bit.
[00:09:27.320 --> 00:09:31.320]   The process of convolution and so on is actually going to model mathematically
[00:09:31.320 --> 00:09:36.320]   that process of taking a part of the image and distributing it, you know,
[00:09:36.320 --> 00:09:41.320]   like to other pixels in the image and create a new image, so it's a function on an image,
[00:09:41.320 --> 00:09:44.320]   let's say the sharp image, that goes to the unsharp image,
[00:09:44.320 --> 00:09:47.320]   that can be modeled mathematically with this process.
[00:09:47.320 --> 00:09:50.320]   You can actually also do the reverse process and do a sharpening filter.
[00:09:50.320 --> 00:09:55.320]   So these actually all correspond to, to how we implement filters on images.
[00:09:55.320 --> 00:10:00.320]   So we'll look at, in detail at that, we'll actually learn a new language
[00:10:00.320 --> 00:10:07.320]   or a new transformation, because it will turn out that if we look in detail at all those filters
[00:10:07.320 --> 00:10:13.320]   and what those linear filtering operations come, you know, like do,
[00:10:13.320 --> 00:10:18.320]   there are sometimes strange behaviors, in particular also if we look at the images
[00:10:18.320 --> 00:10:21.320]   that consist of samples and we do filters and so on,
[00:10:21.320 --> 00:10:28.320]   there will be a number of, you know, complicated behaviors that are hard to understand
[00:10:28.320 --> 00:10:33.320]   if we just look at the image pixel by pixel, point by point.
[00:10:33.320 --> 00:10:37.320]   However, if we transform it in an alternative representation,
[00:10:37.320 --> 00:10:42.320]   a representation that looks at the image more globally and essentially says,
[00:10:42.320 --> 00:10:47.320]   well, you know, this image on average, on average is pretty bright,
[00:10:47.320 --> 00:10:50.320]   it's mostly white with a few black pixels, okay,
[00:10:50.320 --> 00:10:55.320]   and then, you know, it has, you know, in terms of global structure,
[00:10:55.320 --> 00:11:00.320]   it has a few patterns that is kind of white and dark and white and dark and white and dark,
[00:11:00.320 --> 00:11:04.320]   so it has this kind of wave pattern that's kind of, you know,
[00:11:04.320 --> 00:11:09.320]   like vertical waves that have brighter and darker patches and so on.
[00:11:09.320 --> 00:11:14.320]   So essentially, we look at the language that describes these kind of global patterns in the image
[00:11:14.320 --> 00:11:17.320]   and we'll start describing images that way, okay,
[00:11:17.320 --> 00:11:19.320]   and you might wonder, why do we do this and so on?
[00:11:19.320 --> 00:11:22.320]   Well, it turns out that in that representation,
[00:11:22.320 --> 00:11:27.320]   some of these strange effects that show up when we manipulate digital images,
[00:11:27.320 --> 00:11:31.320]   when we sample digital images or re-sample digital images and so on,
[00:11:31.320 --> 00:11:35.320]   they all become pretty easy to understand in this alternative representation, okay?
[00:11:35.320 --> 00:11:38.320]   Also, some operations are more efficient in that representation.
[00:11:38.320 --> 00:11:44.320]   So that's the Fourier transform, which is just changing a basis from a point per point,
[00:11:44.320 --> 00:11:48.320]   you know, basis like x, y, z, for example, in 3D space.
[00:11:48.320 --> 00:11:53.320]   What we'll see is that an image basis actually images,
[00:11:53.320 --> 00:11:57.320]   something you learned in this lecture, this will probably be, I might be wrong,
[00:11:57.320 --> 00:12:02.320]   but it will probably be the first time you look at geometric spaces,
[00:12:02.320 --> 00:12:07.320]   you know, you will get some intuition for geometric spaces that are not one, two, or three dimensional,
[00:12:07.320 --> 00:12:10.320]   but actually are maybe million dimensional, okay?
[00:12:10.320 --> 00:12:12.320]   What are those million dimensions?
[00:12:12.320 --> 00:12:16.320]   Well, it's essentially every pixel is one dimension, right?
[00:12:16.320 --> 00:12:19.320]   So you can represent the image as a huge vector space.
[00:12:19.320 --> 00:12:26.320]   All the images, all possible images, a huge vector space where every pixel is one dimension.
[00:12:26.320 --> 00:12:30.320]   Okay, so if you have a million pixels in your image, you have a million dimensions, right?
[00:12:30.320 --> 00:12:33.320]   So you got to represent the image as a million dimensional vector, okay?
[00:12:33.320 --> 00:12:37.320]   We'll cover all of these things much more in detail, so at this point it is all a bit fuzzy,
[00:12:37.320 --> 00:12:39.320]   and you don't understand this is normal, okay?
[00:12:39.320 --> 00:12:43.320]   I'm going now over the whole lecture in, you know, brief introduction,
[00:12:43.320 --> 00:12:47.320]   but it's just giving you a preview a little bit and we'll put things in context
[00:12:47.320 --> 00:12:52.320]   so you can go more in depth through the lecture, okay?
[00:12:52.320 --> 00:12:59.320]   So essentially an image, if you look at it as a million dimensional vector,
[00:12:59.320 --> 00:13:03.320]   it's essentially every pixel is kind of one dimension of that vector, okay?
[00:13:03.320 --> 00:13:09.320]   And that's essentially not necessarily a great way to represent and understand some of those,
[00:13:09.320 --> 00:13:14.320]   some of those effects that we'll encounter as we manipulate those images.
[00:13:14.320 --> 00:13:19.320]   And so we'll choose then a change of basis, which, you know, in a three-dimensional XYZ space
[00:13:19.320 --> 00:13:23.320]   would be a change of basis, a rotation of the space, right?
[00:13:23.320 --> 00:13:26.320]   You reparameterize your space by rotating it around.
[00:13:26.320 --> 00:13:34.320]   Here, you know, it's also, we'll actually look at, here, unitary transforms,
[00:13:34.320 --> 00:13:36.320]   Fourier transform also, unitary transform.
[00:13:36.320 --> 00:13:42.320]   Unitary transforms actually transforms that actually correspond to the equivalent of rotations.
[00:13:42.320 --> 00:13:49.320]   You know, rotations are transformations of 3D space that don't change the,
[00:13:49.320 --> 00:13:52.320]   that don't change the length of vectors, right?
[00:13:52.320 --> 00:13:56.320]   So you rotate around, you can move around, like, let's say in particular you rotate around,
[00:13:56.320 --> 00:14:01.320]   if I have a vector that's this long, you know, in this basis, and then I change it,
[00:14:01.320 --> 00:14:07.320]   now it has different coordinates in the basis, but the length of the vector is still the same, okay?
[00:14:07.320 --> 00:14:11.320]   That's this type of transformations, but this unitary transform, again,
[00:14:11.320 --> 00:14:15.320]   we'll apply them not on two or three-dimensional space, we'll apply them on a million-dimensional space,
[00:14:15.320 --> 00:14:17.320]   or, you know, maybe only a thousand-dimensional space.
[00:14:17.320 --> 00:14:23.320]   Let's say you do a 30 by 30 patch representing a template of a face, for example.
[00:14:23.320 --> 00:14:29.320]   So you have 900 numbers that represent how a face looks like if you kind of do a cutout.
[00:14:29.320 --> 00:14:33.320]   Then you can do unitary transform on this 900-dimensional space.
[00:14:33.320 --> 00:14:37.320]   Okay, we'll look both at generic transforms, like the Fourier transform.
[00:14:37.320 --> 00:14:45.320]   We'll also look at specific transforms that are adjusted to a particular problem.
[00:14:45.320 --> 00:14:53.320]   I already told you which problem, for example, doing face recognition or finding faces, recognizing faces,
[00:14:53.320 --> 00:14:57.320]   you know, being able to kind of look at different faces, for example, you know,
[00:14:57.320 --> 00:15:02.320]   so that when, you know, I want to unlock my phone, I just hold my face in front of the phone,
[00:15:02.320 --> 00:15:07.320]   and it will essentially be able to unlock it because it actually recognizes it's my face in front of it, right?
[00:15:07.320 --> 00:15:10.320]   Or actually the same with my laptop, okay?
[00:15:10.320 --> 00:15:15.320]   So therefore we need to, given an image, be able to say, you know, to go to a vector space
[00:15:15.320 --> 00:15:21.320]   and then say, is this the right vector or is it close enough to the person I'm trying to recognize
[00:15:21.320 --> 00:15:23.320]   versus any other person.
[00:15:23.320 --> 00:15:27.320]   And so we'll see that these transformations transforming to a particular problem,
[00:15:27.320 --> 00:15:32.320]   we can actually work in lower-dimensional spaces and we don't have to work in 900-dimensional space,
[00:15:32.320 --> 00:15:36.320]   which could be very expensive, but we can work in a much more compact space
[00:15:36.320 --> 00:15:41.320]   where the actual features that matter will be there.
[00:15:41.320 --> 00:15:50.320]   The, this will also be fundamental, the more generic transforms of the type,
[00:15:50.320 --> 00:15:53.320]   will be fundamental also in image compression, okay?
[00:15:53.320 --> 00:15:59.320]   As I kind of hinted, if you have an image, you know, roughly a thousand by a thousand pixels here on the screen,
[00:15:59.320 --> 00:16:05.320]   that's a million numbers, that's actually a million numbers for a grayscale image.
[00:16:05.320 --> 00:16:10.320]   If you have a color image, we won't talk too much about this, this is more in the graphics part,
[00:16:10.320 --> 00:16:13.320]   what color actually is, we'll briefly talk about it in sensing,
[00:16:13.320 --> 00:16:18.320]   but for now, for this part of the lecture, you can assume, okay, color actually,
[00:16:18.320 --> 00:16:25.320]   because of the way our eyes perceive color, which is not physical full-spectrum, you know, color,
[00:16:25.320 --> 00:16:30.320]   we actually have three different types of color-sensitive sensors in our eyes.
[00:16:30.320 --> 00:16:36.320]   So in a sense, what we perceive is red, green, you know, variations of combinations of red, green and blue,
[00:16:36.320 --> 00:16:41.320]   RGB, which you might have seen on screens or other things.
[00:16:41.320 --> 00:16:49.320]   So because we perceive these three colors, we need screens to at least, you know,
[00:16:49.320 --> 00:16:54.320]   play around with combinations of also those three colors, red, green and blue.
[00:16:54.320 --> 00:16:57.320]   If you would actually look very close at the screen here, you might be able to see,
[00:16:57.320 --> 00:17:00.320]   or some of the screens you might be able to see actually dots,
[00:17:00.320 --> 00:17:04.320]   when you look very close, red, green and blue dots on the screen.
[00:17:04.320 --> 00:17:10.320]   So that means actually instead of a single number per point,
[00:17:10.320 --> 00:17:13.320]   you actually need three numbers if it's a color image, okay?
[00:17:13.320 --> 00:17:21.320]   So that means already three million numbers, so if you only use eight bits per,
[00:17:21.320 --> 00:17:26.320]   and we'll discuss that also, but if you only use eight bits per, you know, per color,
[00:17:26.320 --> 00:17:29.320]   that's still three megabytes for a pretty simple image.
[00:17:29.320 --> 00:17:34.320]   If you now talk about a video, you know, it's actually sending images here at 60 frames per second,
[00:17:34.320 --> 00:17:37.320]   it's always the same image, so that would be cheap to compress.
[00:17:37.320 --> 00:17:43.320]   But let's say I play a video here, we'd be talking about three megabytes times 60 hertz.
[00:17:43.320 --> 00:17:47.320]   You know, you can already start seeing that you're, you know,
[00:17:47.320 --> 00:17:53.320]   what you thought was a really high bandwidth, you know, a few gigabits to your home, you know,
[00:17:53.320 --> 00:17:59.320]   fiber would quickly be, you know, fully filled with a single video stream, okay?
[00:17:59.320 --> 00:18:02.320]   So clearly we need compression.
[00:18:02.320 --> 00:18:10.320]   So first we look at single image compression, which is using these transforms.
[00:18:10.320 --> 00:18:15.320]   And then we'll look at also after that, at video.
[00:18:15.320 --> 00:18:21.320]   Now it turns out at video, you know, what is important in video,
[00:18:21.320 --> 00:18:30.320]   if you want to understand and compress videos also, is to see, you know,
[00:18:30.320 --> 00:18:35.320]   like if I look at this scene, for example, I see mostly the same stuff,
[00:18:35.320 --> 00:18:38.320]   except that, you know, some of you are moving a bit around and so on,
[00:18:38.320 --> 00:18:44.320]   or in general if I film a random scene from frame to frame, not that much will change,
[00:18:44.320 --> 00:18:46.320]   except that some things are moving, right?
[00:18:46.320 --> 00:18:51.320]   Or I'm moving and therefore the visually everything moves around me because I'm moving.
[00:18:51.320 --> 00:18:56.320]   But if I move from here to here, I still see all the same stuff, almost all the same stuff.
[00:18:56.320 --> 00:18:59.320]   There's a few things occluded and disoccluded.
[00:18:59.320 --> 00:19:03.320]   But mostly I see the same things, I just see them in a different place in my field of view,
[00:19:03.320 --> 00:19:05.320]   or same with the camera.
[00:19:05.320 --> 00:19:09.320]   You would see the same things, almost the same pixels, almost the same image content,
[00:19:09.320 --> 00:19:12.320]   but slightly, you know, in a different part of the image.
[00:19:12.320 --> 00:19:16.320]   Okay, so the way we'll do compression for video, and the way we'll also do anything
[00:19:16.320 --> 00:19:21.320]   that tries to understand videos and so on, is first by really trying to find, you know,
[00:19:21.320 --> 00:19:25.320]   something we call optical flow, it's actually trying to see how things move in the image.
[00:19:25.320 --> 00:19:28.320]   You know, that stuff was over here and now it moved over there,
[00:19:28.320 --> 00:19:31.320]   we'll try to compute that from images.
[00:19:31.320 --> 00:19:35.320]   And this will be also the basis to be able to do compression.
[00:19:35.320 --> 00:19:40.320]   Because then the way we'll explain it is, okay, this new image that I now have to explain,
[00:19:40.320 --> 00:19:45.320]   based on the previous image, I take this patch over here and I just move it over here,
[00:19:45.320 --> 00:19:51.320]   or actually vice versa, I will say, the patch here that I want to, you know,
[00:19:51.320 --> 00:19:56.320]   rebuild for the new image or transmit for the next image, this patch over here, you know,
[00:19:56.320 --> 00:20:00.320]   just go look a little bit to the left and to, you know, a little bit lower in the previous image.
[00:20:00.320 --> 00:20:06.320]   So take this patch, copy it over here in the new image, and that will give you a good starting point.
[00:20:06.320 --> 00:20:12.320]   It won't be perfect, so we'll still need some additional stuff based on normal image compression.
[00:20:12.320 --> 00:20:16.320]   You say, okay, and you do a collage from all the patches from the previous image,
[00:20:16.320 --> 00:20:20.320]   let's say in a simple way, you do this collage based on how things moved around,
[00:20:20.320 --> 00:20:25.320]   and then you say, okay, now I have to do touch-ups, and then I'll use normal image compression
[00:20:25.320 --> 00:20:28.320]   to explain what touch-ups I have to do.
[00:20:28.320 --> 00:20:35.320]   That's in two minutes the lecture that we'll have on video compression.
[00:20:35.320 --> 00:20:40.320]   We'll also talk about radon transforms.
[00:20:40.320 --> 00:20:47.320]   This is one, we'll have one lecture where we'll go into more medical image processing.
[00:20:47.320 --> 00:20:53.320]   All the images we look at for the rest are typically going to be images that just look at surfaces.
[00:20:53.320 --> 00:20:58.320]   So we have light sources that, you know, send light out, so photons go out,
[00:20:58.320 --> 00:21:04.320]   they hit surfaces, they bounce off, part of it gets absorbed, part of it bounces around,
[00:21:04.320 --> 00:21:07.320]   and then if you put a camera somewhere, or you have your eyes somewhere,
[00:21:07.320 --> 00:21:11.320]   that light will kind of be measured how much light is reflected on surfaces
[00:21:11.320 --> 00:21:14.320]   from every direction based on the lighting there.
[00:21:14.320 --> 00:21:19.320]   So you only look at surfaces typically, or, you know, mostly really surfaces.
[00:21:19.320 --> 00:21:24.320]   You have some transparent things and so on, but mostly you look at surfaces.
[00:21:24.320 --> 00:21:27.320]   With radon transform or with medical imaging,
[00:21:27.320 --> 00:21:30.320]   you're actually interested at doing images through, you know,
[00:21:30.320 --> 00:21:33.320]   like not of the surface of the person, but actually through the body,
[00:21:33.320 --> 00:21:35.320]   measure what's inside.
[00:21:35.320 --> 00:21:39.320]   So there we'll actually use still the same geometric, you know, like a pixel,
[00:21:39.320 --> 00:21:45.320]   a point, an image point will be measured at what comes in from a ray in space.
[00:21:45.320 --> 00:21:50.320]   So like if I look in that direction, I, you know, my eye sees whatever is first
[00:21:50.320 --> 00:21:52.320]   in that direction when I look at surfaces.
[00:21:52.320 --> 00:21:55.320]   For image, medical imaging, it will be different.
[00:21:55.320 --> 00:21:57.320]   I'll be looking with x-rays or something.
[00:21:57.320 --> 00:22:01.320]   I'll be looking all the way through, and I see kind of everything that's along the line,
[00:22:01.320 --> 00:22:03.320]   all the way through the body, for example.
[00:22:03.320 --> 00:22:07.320]   And I just see the brightest thing like, or the accumulation of everything through the body
[00:22:07.320 --> 00:22:09.320]   in a particular way.
[00:22:09.320 --> 00:22:14.320]   It turns out that to understand that, and to model again mathematically that process,
[00:22:14.320 --> 00:22:20.320]   and represent that, and analyze that, there's this random transform that's very useful.
[00:22:20.320 --> 00:22:24.320]   It's also, I also like to discuss it because it's actually also closely coupled
[00:22:24.320 --> 00:22:27.320]   to the Fourier transform, it shows, and so it gives you another insight
[00:22:27.320 --> 00:22:32.320]   in what the Fourier transform is doing and can be doing.
[00:22:32.320 --> 00:22:39.320]   And so it also explains a little bit the basis of, you know, CT imaging and things like this.
[00:22:39.320 --> 00:22:41.320]   So computational tomography.
[00:22:41.320 --> 00:22:47.320]   So the typical, like, how medical imaging kind of some of the basis for that.
[00:22:47.320 --> 00:22:54.320]   And then we'll finish with this, this is the first time we'll actually cover this topic in this lecture.
[00:22:54.320 --> 00:23:00.320]   But we'll then discuss also convolutional neural networks,
[00:23:00.320 --> 00:23:04.320]   which will actually also bring back a lot of those steps.
[00:23:04.320 --> 00:23:08.320]   The image segmentation is actually a nonlinear operator,
[00:23:08.320 --> 00:23:13.320]   but then everything we see after that mostly, the convolutions and filters and so on,
[00:23:13.320 --> 00:23:16.320]   are all linear filters.
[00:23:16.320 --> 00:23:20.320]   They'll have the interesting property that if you apply a linear filter
[00:23:20.320 --> 00:23:23.320]   and then a second linear filter behind it, and a third linear filter,
[00:23:23.320 --> 00:23:26.320]   and you know, any number of linear filters that you want,
[00:23:26.320 --> 00:23:31.320]   up to saturating your, you know, your 8 bits and, you know, and things like this.
[00:23:31.320 --> 00:23:35.320]   But up to, if you assume that you have, you don't have issues of saturations
[00:23:35.320 --> 00:23:38.320]   or, you know, not having enough precision or so, up to that,
[00:23:38.320 --> 00:23:42.320]   all of those linear filters, if you apply 10 linear filters after each other,
[00:23:42.320 --> 00:23:45.320]   you could actually replace that by a single linear filter.
[00:23:45.320 --> 00:23:50.320]   It's guaranteed you actually could apply the filters to each other,
[00:23:50.320 --> 00:23:54.320]   and that makes a big filter, and then you just take that big filter as a single operation
[00:23:54.320 --> 00:23:59.320]   and apply to the image, and you would have the same effect as the 10 linear filters in a row.
[00:23:59.320 --> 00:24:03.320]   So linear filters somehow, they don't do that means, you know,
[00:24:03.320 --> 00:24:06.320]   in a sense they do very interesting things, but in the other hand,
[00:24:06.320 --> 00:24:10.320]   they don't combine in a very interesting way because they just kind of keep combining into,
[00:24:10.320 --> 00:24:14.320]   you know, you can all collapse them to a single linear operation.
[00:24:14.320 --> 00:24:19.320]   So at some level, they don't, they're not that interesting.
[00:24:19.320 --> 00:24:24.320]   You find them everywhere, but they only, they're limited in how much they can do.
[00:24:24.320 --> 00:24:30.320]   Convolutional neural nets are essentially, there's one small difference
[00:24:30.320 --> 00:24:35.320]   when they apply all those filters in a network, a deep neural network,
[00:24:35.320 --> 00:24:40.320]   so they will have actually many in a row, apply many small filters in a row,
[00:24:40.320 --> 00:24:45.320]   but the key difference is that after every filter, they make a nonlinear decision.
[00:24:45.320 --> 00:24:49.320]   I mean, or they essentially apply a nonlinear effect.
[00:24:49.320 --> 00:24:55.320]   For example, typical one is, okay, if the result is positive, then I just keep the result,
[00:24:55.320 --> 00:25:00.320]   but if it's negative, you know, I just clip it to zero.
[00:25:00.320 --> 00:25:02.320]   So that's nonlinear, right?
[00:25:02.320 --> 00:25:05.320]   So positive, it's, or let's say for you like this way, so positive,
[00:25:05.320 --> 00:25:10.320]   if the value is positive, I just output that particular value,
[00:25:10.320 --> 00:25:13.320]   so it's 45 degree curve, right?
[00:25:13.320 --> 00:25:18.320]   If it's linear, you know, you push it up, and you know, if it's positive,
[00:25:18.320 --> 00:25:21.320]   but you push it down, it's negative, and then, you know, afterwards you recombine,
[00:25:21.320 --> 00:25:26.320]   somehow always ends up, you know, having one combined linear filter effect,
[00:25:26.320 --> 00:25:30.320]   but as soon as you put a nonlinear effect, then you can do much, much more interesting things.
[00:25:30.320 --> 00:25:33.320]   At that point, you can actually take decisions in a sense, right?
[00:25:33.320 --> 00:25:36.320]   So if it's positive, so now you can make the difference,
[00:25:36.320 --> 00:25:44.320]   so essentially linear filters in a sense, what they do is they cannot make the difference between,
[00:25:44.320 --> 00:25:50.320]   so if they have a strong positive effect, so they say, oh, this really looks like, you know, whatever,
[00:25:50.320 --> 00:25:53.320]   for example, some of the features we look at is corners, right?
[00:25:53.320 --> 00:26:02.320]   So hey, this really looks like a corner, like a white, you know, inside corner with a black outside, okay?
[00:26:02.320 --> 00:26:06.320]   So let's say that's a feature you're interested in, you want to find this corner here,
[00:26:06.320 --> 00:26:13.320]   then you could look for a template like this, and you would correlate or convolut the image with a template of a corner,
[00:26:13.320 --> 00:26:17.320]   and then it would give you a strong response if you hit this.
[00:26:17.320 --> 00:26:21.320]   The problem is you are bound to also, if you use a linear filter,
[00:26:21.320 --> 00:26:25.320]   you're bound to also have a very strong response if you have the exact opposite,
[00:26:25.320 --> 00:26:28.320]   and it will be a very strong negative response, okay?
[00:26:28.320 --> 00:26:33.320]   So if you have a black corner here with a white surrounding, right?
[00:26:33.320 --> 00:26:38.320]   If you have a linear filter, it has to also at that point give a strong response,
[00:26:38.320 --> 00:26:41.320]   so the responses between the positive and the negative are always coupled,
[00:26:41.320 --> 00:26:43.320]   you cannot separate them in linear filters,
[00:26:43.320 --> 00:26:51.320]   so you can, if you say strong response to this, then you have an equally strong negative response to the opposite visual signal, okay?
[00:26:51.320 --> 00:26:56.320]   And because as you keep stacking things up, they all recombine in a single combined response,
[00:26:56.320 --> 00:27:03.320]   it means that your filters can somehow not just choose the positive but ignore the negative, okay?
[00:27:03.320 --> 00:27:10.320]   Deep neural networks, the key thing is they insert at every layer of the network a negative, like a nonlinear decision.
[00:27:10.320 --> 00:27:15.320]   It says, "Yes, I keep the positive, but I ignore the negative."
[00:27:15.320 --> 00:27:19.320]   That's in a sense what they're doing, you know, intuitively at a certain level.
[00:27:19.320 --> 00:27:23.320]   That allows them to be much more powerful because there they can just select what they care about
[00:27:23.320 --> 00:27:31.320]   and not have the byproduct of kind of, you know, also kind of having a strong response to the negative, to the opposite signal, okay?
[00:27:31.320 --> 00:27:34.320]   So that is what actually then turns out to be,
[00:27:34.320 --> 00:27:41.320]   suddenly you can represent pretty much anything or get any decision function created with this,
[00:27:41.320 --> 00:27:47.320]   where linear decision boundaries at some level, okay, by the way, in the end what are you doing?
[00:27:47.320 --> 00:27:53.320]   You're essentially looking at a big vector space and what a neural network at some level is doing,
[00:27:53.320 --> 00:27:58.320]   or any decision mechanism, is putting a boundary somewhere in that space, okay?
[00:27:58.320 --> 00:28:06.320]   If you have a linear system, that boundary is just a plane, you know, a hyperplane or whatever, but it's just a plane.
[00:28:06.320 --> 00:28:12.320]   You can put any number of linear filters behind each other, it will always remain a hyperplane somewhere in that space.
[00:28:12.320 --> 00:28:18.320]   So it means everything on one side of that plane is labeled one way, if you do binary classification.
[00:28:18.320 --> 00:28:27.320]   Everything on the other side is labeled the other way, and you won't be able to get anything else out of your linear filters, okay?
[00:28:27.320 --> 00:28:34.320]   With nonlinear, you can actually end up drawing any arbitrary boundary and say, okay, those things over here are positive,
[00:28:34.320 --> 00:28:39.320]   and then those are negative, and then those are positive again, and so on, you can have very complicated boundaries,
[00:28:39.320 --> 00:28:44.320]   arbitrarily complicated boundaries with neural networks, okay?
[00:28:44.320 --> 00:28:52.320]   Okay, so that's, you know, a kind of big overview of everything we'll be discussing in the first part of the lecture.
[00:28:52.320 --> 00:29:04.320]   Any immediate questions related to this or other questions related to this first part of the lecture?
[00:29:04.320 --> 00:29:12.320]   Okay, you know, this, so as I said, like, this was not the level you should understand, it's mostly, I hope,
[00:29:12.320 --> 00:29:17.320]   a good intro, give you some background, and as we go through the lecture, it will allow you to put a different part into context,
[00:29:17.320 --> 00:29:22.320]   also looking at what will come afterwards.
[00:29:22.320 --> 00:29:23.320]   Yes?
[00:29:23.320 --> 00:29:26.320]   [inaudible]
[00:29:26.320 --> 00:29:27.320]   What?
[00:29:27.320 --> 00:29:29.320]   [inaudible]
[00:29:29.320 --> 00:29:37.320]   Oh, the slides should be made available to you by, like, for the first part, I think by, Philip should upload them.
[00:29:37.320 --> 00:29:44.320]   I think now I just send him an email 15 minutes before the lecture, so I think he might, like, this might not yet have happened for this lecture,
[00:29:44.320 --> 00:29:51.320]   but the goal will be that it will be uploaded before the lecture so that you have access to them.
[00:29:51.320 --> 00:30:03.320]   I think it's on the course website, but I think it will be there, but anyways, you'll hear about, from Philip, you'll hear about it.
[00:30:03.320 --> 00:30:07.320]   Any other questions?
[00:30:07.320 --> 00:30:13.320]   Also related to practical organization or other things, so actually, I'll, I'll, I have some course logistics after this.
[00:30:13.320 --> 00:30:24.320]   Okay, so on the graphics side, I won't go as much into detail there, but essentially, you'll, you know, you look at basics of how to draw a triangle,
[00:30:24.320 --> 00:30:34.320]   like the basic kind of graphics pipeline, you know, steps, drawing pipelines, rasterizing, you know, again, the images are grids, rasters,
[00:30:34.320 --> 00:30:43.320]   and so you kind of go through it, you know, pixel by pixel or so and, you know, kind of make decisions there or compute the value you should get there.
[00:30:43.320 --> 00:30:47.320]   Then very important is being able to move things around.
[00:30:47.320 --> 00:30:56.320]   So transformations, here we're actually talking about 2D, you know, 2D and 3D transformations, and kind of basic geometry and then textures,
[00:30:56.320 --> 00:31:07.320]   texture in this case is essentially the appearance of a particular triangle, you can attach kind of an image to a triangle in a sense,
[00:31:07.320 --> 00:31:15.320]   that would be the texture, and then as you move that triangle around, it will go to different place and then you have to, it will land on different pixels
[00:31:15.320 --> 00:31:29.320]   and then you have to sample that texture to see what part of the texture, what, you know, that texture, what, you know, what, how to fill in the right color in the image based on sampling that texture.
[00:31:29.320 --> 00:31:33.320]   So you look at the rendering pipeline, then important, of course, is lighting.
[00:31:33.320 --> 00:31:42.320]   If you don't generate the light in your, have some notion of lighting in graphics, you know, you're not going to get much, okay,
[00:31:42.320 --> 00:31:50.320]   so actually the basics would be to just copy the texture values or whatever you say, this thing is red, you know, just copy red values to your image,
[00:31:50.320 --> 00:31:54.320]   but that creates very flat images that are not very interesting.
[00:31:54.320 --> 00:31:59.320]   So what you actually want to do is also generate, simulate the lighting process.
[00:31:59.320 --> 00:32:09.320]   That means that if light is coming from a certain direction, you know, it will be, so you model the fact that, you know, the brightness,
[00:32:09.320 --> 00:32:15.320]   let me try this here, okay, so now my hand is, it gets a lot of light straight from the light there.
[00:32:15.320 --> 00:32:22.320]   As I, you know, mostly approximately from any direction, you will see the same brightness from my hand.
[00:32:22.320 --> 00:32:25.320]   This is called lamb version reflectance.
[00:32:25.320 --> 00:32:29.320]   It means that the light that hits there on this surface will mostly reflect the same in every direction.
[00:32:29.320 --> 00:32:32.320]   The same amount of light will reflect in any direction, roughly.
[00:32:32.320 --> 00:32:36.320]   That's a good approximation for a good number of materials.
[00:32:36.320 --> 00:32:44.320]   That's also for the screen, for example, the case that reflects light roughly equally in the 180 degrees in front of the surface.
[00:32:44.320 --> 00:32:53.320]   But then if I pivot the surface like this, sorry, you guys can't see it anymore, but you see on this side that my hand is now less bright, right?
[00:32:53.320 --> 00:32:59.320]   That's because, of course, now if you just look at the amount of light that hits my, that illuminates my hand now,
[00:32:59.320 --> 00:33:03.320]   it's a much smaller fraction of the amount of light of the projector.
[00:33:03.320 --> 00:33:10.320]   At this point, it's about this, while now it's about this fraction of the projector that hits, that illuminates my hand.
[00:33:10.320 --> 00:33:18.320]   And so essentially the normal between the light direction and the surface direction will determine how bright a surface looks like.
[00:33:18.320 --> 00:33:23.320]   Or, you know, how much light is actually captured by the surface and reflected by the surface, et cetera, et cetera.
[00:33:23.320 --> 00:33:27.320]   So that's lighting and shading.
[00:33:27.320 --> 00:33:29.320]   Also, you talk about colors.
[00:33:29.320 --> 00:33:32.320]   As I said, colors are actually quite complicated.
[00:33:32.320 --> 00:33:40.320]   You know, our eyes might not exactly sense things the same way that the screen represents it.
[00:33:40.320 --> 00:33:43.320]   All of these things can lead to some interesting effects.
[00:33:43.320 --> 00:33:48.320]   You have to choose how you represent colors, et cetera, et cetera.
[00:33:48.320 --> 00:33:50.320]   There's a lot of depth to that.
[00:33:50.320 --> 00:33:58.320]   I think Marcus will actually go through some of that with you to at least give you some basic understandings.
[00:33:58.320 --> 00:34:06.320]   For example, also, you might have noticed that your printer doesn't, your screen is an RGB screen,
[00:34:06.320 --> 00:34:17.320]   but your printer actually typically C-M-Y-K sees for, so it's cyan, magenta, and yellow, and then K is for black.
[00:34:17.320 --> 00:34:20.320]   That's just because it's hard to make black by just mixing colors.
[00:34:20.320 --> 00:34:23.320]   But what you really need is C-M-Y-K.
[00:34:23.320 --> 00:34:24.320]   It's different colors.
[00:34:24.320 --> 00:34:29.320]   This is because, you'll see all of this, but it's because there you actually subtracting light.
[00:34:29.320 --> 00:34:33.320]   It's what light gets absorbed on the surface.
[00:34:33.320 --> 00:34:37.320]   If you print something on the surface, on the screen is what light gets emitted.
[00:34:37.320 --> 00:34:44.320]   Those are inverse processes, and that means that if you want to combine, you know, to generate a color,
[00:34:44.320 --> 00:34:48.320]   here you decide on a screen like this, you decide what do I emit.
[00:34:48.320 --> 00:34:51.320]   I emit RG, and how much RG and V do I emit?
[00:34:51.320 --> 00:34:58.320]   When you actually print, you say what should the surface absorb in terms of light?
[00:34:58.320 --> 00:35:04.320]   And therefore, if you put two colors together, you absorb not two colors instead of one when you mix colors.
[00:35:04.320 --> 00:35:07.320]   That's why it's actually some of the inverse colors.
[00:35:07.320 --> 00:35:12.320]   Anyways, you'll see all of that when you'll talk about colors.
[00:35:12.320 --> 00:35:15.320]   And of course, visibility and shadows.
[00:35:15.320 --> 00:35:20.320]   You know, if I turn my hand this way, then this doesn't get any light from there, right?
[00:35:20.320 --> 00:35:24.320]   All of this needs to be modeled, so that's all geometry, et cetera.
[00:35:24.320 --> 00:35:30.320]   It could also be that this doesn't get any light, not because it's oriented the wrong way, but because there's an occluder, right?
[00:35:30.320 --> 00:35:35.320]   Because my other hand is kind of capturing light, so there's no light hitting this anymore.
[00:35:35.320 --> 00:35:39.320]   Obviously, you want to model that, otherwise your graphics is going to look kind of strange
[00:35:39.320 --> 00:35:44.320]   if the light illuminates every surface, you know, behind other surfaces equally, right?
[00:35:44.320 --> 00:35:48.320]   So, visibility and shadows.
[00:35:48.320 --> 00:35:52.320]   Then, I think this time there will be curves and surfaces will be discussed.
[00:35:52.320 --> 00:36:01.320]   How do you represent kind of not discretized surfaces, but actually smooth surfaces or as smooth as possible surfaces using mathematical representations,
[00:36:01.320 --> 00:36:06.320]   both curves in 2D and then surfaces in 3D?
[00:36:06.320 --> 00:36:08.320]   Some geometry processing, I'll see with that.
[00:36:08.320 --> 00:36:10.320]   And also ray tracing.
[00:36:10.320 --> 00:36:17.320]   The standard graphics pipeline is, you know,
[00:36:17.320 --> 00:36:23.320]   is directly rendering these triangles and, you know, projecting those in the image and so on.
[00:36:23.320 --> 00:36:25.320]   Ray tracing is a different process.
[00:36:25.320 --> 00:36:32.320]   It actually, you know, will trace rays through space and see, you know, until it hits the light and stuff like that.
[00:36:32.320 --> 00:36:39.320]   With today's graphics hardware and so on, this is starting to become quite feasible also in real-time interactive settings and so on.
[00:36:39.320 --> 00:36:41.320]   So, you'll also look at that.
[00:36:41.320 --> 00:36:51.320]   So, this is, you know, also working at Disney is also going to tell you or maybe have a guest lecture and, you know, both throughout the lecture
[00:36:51.320 --> 00:37:02.320]   and also, you know, probably dive deeper in some of the kind of more advanced special effects that are happening at Disney, right?
[00:37:02.320 --> 00:37:09.320]   Okay, so in terms of course logistics, you should be able to find all the info on the website.
[00:37:09.320 --> 00:37:13.320]   There's probably also the slides.
[00:37:13.320 --> 00:37:19.320]   They might also be on the Moodle or somewhere else, but I think they'll be on the website.
[00:37:19.320 --> 00:37:21.320]   So, you all found the way today.
[00:37:21.320 --> 00:37:25.320]   We'll be here at the same place on Thursday afternoon for the other lecture of the week.
[00:37:25.320 --> 00:37:31.320]   And then the exercises will be those two sessions here.
[00:37:31.320 --> 00:37:37.320]   Philip will communicate with you, you know, what group, in what group you do normally be.
[00:37:37.320 --> 00:37:40.320]   If you have conflicts, you can also switch around.
[00:37:40.320 --> 00:37:44.320]   The groups are so as long as this is somewhat ends up with balanced groups.
[00:37:44.320 --> 00:37:49.320]   But that's something that he will reach out to you for.
[00:37:49.320 --> 00:37:54.320]   The exercise also only starts next week, so this week no exercises yet.
[00:37:54.320 --> 00:38:04.320]   As the exercises, you know, have the goal to revisit some of the concepts and actually get some hands-on experience with some of the concepts in the lecture.
[00:38:04.320 --> 00:38:08.320]   This week is too early.
[00:38:08.320 --> 00:38:11.320]   Is it a third lecture from tools?
[00:38:11.320 --> 00:38:14.320]   Oh, yes, you might be right.
[00:38:14.320 --> 00:38:17.320]   Yes, I think that's something I forgot to update.
[00:38:17.320 --> 00:38:19.320]   Good point.
[00:38:19.320 --> 00:38:28.320]   Yes, it was shifted a few years ago and then when I copied something over, I missed that.
[00:38:28.320 --> 00:38:30.320]   Yeah, I think you're right.
[00:38:30.320 --> 00:38:33.320]   Okay.
[00:38:33.320 --> 00:38:39.320]   I think all the other times I still write, but do double check.
[00:38:39.320 --> 00:38:42.320]   Okay.
[00:38:42.320 --> 00:38:46.320]   So the exercise is non-count for the grade.
[00:38:46.320 --> 00:38:49.320]   The grade is determined by the final exam.
[00:38:49.320 --> 00:38:54.320]   However, of course, the doing the exercises and, you know, kind of,
[00:38:54.320 --> 00:39:02.320]   well, being able to do the exercises, doing the exercises is, of course, should be very correlated with how you do on the final exam.
[00:39:02.320 --> 00:39:08.320]   Or in other words, some of the things that you do there and this and that are the things that are going to come back at the exam.
[00:39:08.320 --> 00:39:10.320]   Okay.
[00:39:10.320 --> 00:39:13.320]   So I attend one of the two sessions each week.
[00:39:13.320 --> 00:39:18.320]   The exercise complement the lectures to provide insight and hands-on experience.
[00:39:18.320 --> 00:39:28.320]   And the goal is also to be able to finish the exercises during the session with the assistance of the assistance.
[00:39:28.320 --> 00:39:32.320]   So the goal is to not have homework to do for the lecture.
[00:39:32.320 --> 00:39:35.320]   So hopefully you have the time to do that.
[00:39:35.320 --> 00:39:41.320]   The exercises since a few years have been switched from MATLAB to Python.
[00:39:41.320 --> 00:39:45.320]   So this will all be Python exercises, at least for the first part of the lecture.
[00:39:45.320 --> 00:39:50.320]   And I think for graphics it's probably different.
[00:39:50.320 --> 00:39:59.320]   So now I'll just give you a little bit of overview of beyond kind of the -- so this is the first intro to visual computing.
[00:39:59.320 --> 00:40:05.320]   Here I want to sketch a little bit everything that's going on in the broader space of visual computing at ETH,
[00:40:05.320 --> 00:40:10.320]   both in the computer science department, so first in the Institute of Visual Computing, actually,
[00:40:10.320 --> 00:40:13.320]   which combines both graphics and vision.
[00:40:13.320 --> 00:40:21.320]   So I'm leading the computer vision and geometry lab.
[00:40:21.320 --> 00:40:26.320]   Marcus is leading the computer graphics lab.
[00:40:26.320 --> 00:40:32.320]   Olga is leading the interactive geometry lab, which is also really focused on computer graphics,
[00:40:32.320 --> 00:40:35.320]   geometry processing.
[00:40:35.320 --> 00:40:39.320]   Then C. Utang is leading the vision and learning group,
[00:40:39.320 --> 00:40:44.320]   where I'm mostly focused -- and I'll show some examples throughout the lecture --
[00:40:44.320 --> 00:40:51.320]   on having cameras that move around through environments and try to understand what's going on in the environment,
[00:40:51.320 --> 00:40:58.320]   build representations of the environment, think of scenarios like head mounted displays,
[00:40:58.320 --> 00:41:04.320]   like a HoloLens device or VR devices, also phones that move around
[00:41:04.320 --> 00:41:11.320]   and to help you navigate or self-driving cars or drones or other things that essentially --
[00:41:11.320 --> 00:41:19.320]   systems that need to be able to navigate the world or do things in the world need to perceive their environment and function.
[00:41:19.320 --> 00:41:24.320]   Olga is more focused on cameras that look at people and understand what people are doing,
[00:41:24.320 --> 00:41:30.320]   tracking people, modeling people, making, building digital avatars, et cetera, et cetera.
[00:41:30.320 --> 00:41:34.320]   That's what we are doing in the vision space.
[00:41:34.320 --> 00:41:39.320]   In addition to that, Otmar Heligus, who's doing HCI and computer vision,
[00:41:39.320 --> 00:41:44.320]   also more focused on tracking people, how they interact and what they can --
[00:41:44.320 --> 00:41:49.320]   these kind of interactive computer vision-based modalities.
[00:41:49.320 --> 00:41:55.320]   Sted and Kuros does the computational robotics, leads the computational robotics lab.
[00:41:55.320 --> 00:42:01.320]   This is a lab that's focused on the intersection of robotics and graphics.
[00:42:01.320 --> 00:42:05.320]   You can wonder, okay, why do robots need graphics or so?
[00:42:05.320 --> 00:42:10.320]   This is about enabling reinforcement learning and enabling -- so you need a simulation environment
[00:42:10.320 --> 00:42:15.320]   to be able to train your robot without destroying your robot in the process.
[00:42:15.320 --> 00:42:22.320]   So you actually want to have a kind of -- you want to leverage all of the modeling and 3D and capabilities
[00:42:22.320 --> 00:42:26.320]   of, you know, manipulating geometry, having interactive geometry,
[00:42:26.320 --> 00:42:32.320]   use that to simulate your robot behavior, train your robot behavior and so on,
[00:42:32.320 --> 00:42:37.320]   in simulation to then transfer that to an actual physical robot and so on.
[00:42:37.320 --> 00:42:40.320]   Okay? So that's what he's doing then.
[00:42:40.320 --> 00:42:48.320]   In ETHET, there is the computer vision laboratory with Luke Fanghole
[00:42:48.320 --> 00:42:54.320]   and Konokoro and Fisher U.
[00:42:54.320 --> 00:43:00.320]   Luke and Fisher are more on the computer vision side and there is more on the medical imaging side.
[00:43:00.320 --> 00:43:05.320]   Then there's the Institute of Machine Learning that also does some --
[00:43:05.320 --> 00:43:14.320]   also does some work sometimes in both medical image processing as well as computer vision and so on.
[00:43:14.320 --> 00:43:20.320]   In photogrammetry and remote sensing, this is in Debalk in the civil engineering department.
[00:43:20.320 --> 00:43:28.320]   However, he's actually also really has a computer vision background and does computer vision research.
[00:43:28.320 --> 00:43:34.320]   Then there's a lot of work in robotics happening in the day-maft department,
[00:43:34.320 --> 00:43:38.320]   so in mechanical engineering, Roland Sigurd.
[00:43:38.320 --> 00:43:43.320]   Actually, I should have, but Marco Hutter there also are doing computer vision.
[00:43:43.320 --> 00:43:46.320]   Margarita and Eminor-Hiles moved on.
[00:43:46.320 --> 00:43:49.320]   I forgot to update this part.
[00:43:49.320 --> 00:43:53.320]   Then also at the university or actually between the university and ETH,
[00:43:53.320 --> 00:43:56.320]   there's the Institute of Neuronformatics.
[00:43:56.320 --> 00:44:05.320]   They do some very interesting work in particular in neuro-inspired sensors.
[00:44:05.320 --> 00:44:15.320]   The Toby Delbrouk actually built and we'll talk about that on Thursday.
[00:44:15.320 --> 00:44:25.320]   At the origin of event cameras, these are special type of camera that much more mimics the actual way the eye senses the world.
[00:44:25.320 --> 00:44:29.320]   We're not measuring every pixel every time at every frame,
[00:44:29.320 --> 00:44:34.320]   measure how much light came in now and then again the same thing, the next step and so on.
[00:44:34.320 --> 00:44:38.320]   So much more sparse process is like, okay, as long as nothing changes, there's nothing to signal,
[00:44:38.320 --> 00:44:43.320]   but when something moves somewhere or something happens somewhere and the brightness changes in a particular area,
[00:44:43.320 --> 00:44:45.320]   then it sends a signal.
[00:44:45.320 --> 00:44:47.320]   It's like, oh, this pixel became brighter by 10%.
[00:44:47.320 --> 00:44:49.320]   Oh, this one became darker by 10%.
[00:44:49.320 --> 00:44:55.320]   So it just sends these type of signals, completely different way to create images.
[00:44:55.320 --> 00:44:57.320]   So Toby did that.
[00:44:57.320 --> 00:45:01.320]   Now there's actually so many Samsung, everybody's building these cameras.
[00:45:01.320 --> 00:45:03.320]   They're originated from here.
[00:45:03.320 --> 00:45:05.320]   There's also a few startups here in Zurich.
[00:45:05.320 --> 00:45:14.320]   Davide Skarmutza is one of the leaders in the field of actually using and building algorithms to leverage these type of cameras to do cool stuff.
[00:45:14.320 --> 00:45:23.320]   For example, he just set a paper in nature that showed some of his really crazy drone flights that now can beat you in pilots and so on.
[00:45:23.320 --> 00:45:26.320]   Okay, so I leave it at that for the first part.
[00:45:26.320 --> 00:45:31.320]   Now we have a break and then we'll resume in 15 minutes.
[00:45:31.320 --> 00:45:35.320]   And I forgot, was there a presentation or not?
[00:45:35.320 --> 00:45:41.320]   No, because at some point there might be some presentation during the breaks from different student organizations.
[00:45:41.320 --> 00:45:45.320]   Thank you.
[00:45:45.320 --> 00:45:48.320]   Okay.
[00:45:48.320 --> 00:45:57.320]   So I told you about all the labs at ETH or at least a good part of the labs that do computer vision related things and computer graphics related things.
[00:45:57.320 --> 00:45:59.320]   So visual computing related things.
[00:45:59.320 --> 00:46:05.320]   There's also a lot of industry, both big tech as well as startups.
[00:46:05.320 --> 00:46:08.320]   Actually, often those things are correlated.
[00:46:08.320 --> 00:46:15.320]   Here's a few things that are happening here in Zurich in this space.
[00:46:15.320 --> 00:46:17.320]   So Disney, of course, is here.
[00:46:17.320 --> 00:46:24.320]   This was actually Marcus Gross that brought Disney here, set up a Disney research lab.
[00:46:24.320 --> 00:46:30.320]   Now it's focused on the studios and so the special effects and so on.
[00:46:30.320 --> 00:46:41.320]   Google is of course here, has lots of computer vision and graphics people related to both on the research side of Google here with several groups.
[00:46:41.320 --> 00:46:48.320]   Also a former professor from ETH, Vittorio Ferrari, is there several others.
[00:46:48.320 --> 00:46:55.320]   Then there's also actually former Disney, Tavo Bieler is doing avatars and other things.
[00:46:55.320 --> 00:47:04.320]   So digital humans at Google, they do a lot of things related to their AR, VR, also search maps, etc., etc.
[00:47:04.320 --> 00:47:08.320]   With different vision and graphics components.
[00:47:08.320 --> 00:47:13.320]   In particular also ARCore.
[00:47:13.320 --> 00:47:30.320]   There was a team that worked on ARCore that also did the navigation or the, you know, in Google Maps, if you do pedestrian navigation.
[00:47:30.320 --> 00:47:35.320]   And you can click to then get kind of localized based on an image.
[00:47:35.320 --> 00:47:38.320]   That's actually done here in Zurich by Simon Linden and his team.
[00:47:38.320 --> 00:47:46.320]   Also including one of my PhD students, the actual algorithm, the origin, not today's algorithm that's used,
[00:47:46.320 --> 00:47:55.320]   but the first version of the algorithm that was then developed further was actually developed in my lab actually.
[00:47:55.320 --> 00:48:03.320]   And published in 2015 and is now kind of the base for the algorithm that's in Google Maps for example.
[00:48:03.320 --> 00:48:10.320]   You know, there's startups here doing like physics simulation on GPUs.
[00:48:10.320 --> 00:48:16.320]   There was a startup that got acquired, or actually a startup information.
[00:48:16.320 --> 00:48:22.320]   I think it was called Zurich Sensor, so it was never really started because it got, the whole team got acquired,
[00:48:22.320 --> 00:48:25.320]   acquired by Oculus.
[00:48:25.320 --> 00:48:36.320]   So Meta now in the meanwhile is about 300 people here in, or maybe even 400 people working with mostly vision background.
[00:48:36.320 --> 00:48:45.320]   That are working on the tracking and many other aspects, computer vision related aspects.
[00:48:45.320 --> 00:48:56.320]   Also some graphics for Oculus device for MetaQuest devices.
[00:48:56.320 --> 00:49:03.320]   There was, Koaba was a startup of the computer vision lab, got acquired.
[00:49:03.320 --> 00:49:11.320]   It was a startup that 15 years ago, you could also, you could take pictures.
[00:49:11.320 --> 00:49:24.320]   Actually I think it's still their technology in Vivino where you can take a picture of a bottle and it will kind of recognize what the label is and so on and do that efficiently.
[00:49:24.320 --> 00:49:34.320]   But they were acquired by Qualcomm as part of the, you know, became part of the euphoria in Qualcomm which then got sold further to PTC.
[00:49:34.320 --> 00:49:48.320]   Which is one of, you know, you might not know it, it's not a consumer oriented company, but it's actually a big company and everything that's digital industry kind of digital twins and IOT and these type of things.
[00:49:48.320 --> 00:49:56.320]   So anyway, so they used that for doing augmented IT and other experiences at PTC.
[00:49:56.320 --> 00:50:17.320]   There was a startup called Procedural, you know, here's some computer vision work that some of Pascal Mller in particular did between graphics and the computer vision lab to label facades here and segment facades in all its components and understand that this facade had a structure that all these windows are essentially the same elements copied over and so on.
[00:50:17.320 --> 00:50:39.320]   And they developed that further to be able to build procedurally, build kind of digital cities with the idea to help urban planning so that you can generate kind of, if you put a street layout, you can generate a plausible set of buildings that, you know, with a proper style and you define the style and it will populate it and generate a whole virtual city, for example.
[00:50:39.320 --> 00:50:58.320]   So that was what Procedural was, they got acquired by Esri, which is a large international company and they're not as far as I know the mixed reality expertise center for Esri and so they're also based in Kais-Pimpf in, have their offices there.
[00:50:58.320 --> 00:51:25.320]   There's a small startup, a startup CVL that got acquired by Logitech, for example, that was doing some camera stuff. LibreVision was a startup from Marcus that was looking, that was, you know, you might have seen in football matches at some period they had like these circles and tracking players and all of these analysis of what was going on in the game and enabling the commentators to discuss, you know, the effects.
[00:51:25.320 --> 00:51:44.320]   This was all pioneered by LibreVision, so it was a mix of vision and graphics, became part of ISRT, which is, I think, a Norwegian group, if I'm not mistaken, that is kind of specialized in sports, kind of video processing things.
[00:51:44.320 --> 00:52:02.320]   FaceShift startup also from, it was a student with MacPauly, who was a professor next to Marcus Gross in computer graphics here, he's now a professor at APFL, so he was assistant professor here, became a full professor at APFL.
[00:52:02.320 --> 00:52:19.320]   This was a student and then postdoc, people, Vicer, there were other people also involved, the startup was kind of linked to APFL because that's when they started after that postdoc but was established in Zurich because, you know, Tivo and others were from here.
[00:52:19.320 --> 00:52:32.320]   And that became the basis, got acquired by APFL, this is actually when in APFL you have an emojis and you have your face tracked kind of, you know, and doing grimaces in front of your phone, that's their technology.
[00:52:32.320 --> 00:52:42.320]   So, you know, they got acquired, a bunch of people moved to Cupertino but also there's a part that stayed here.
[00:52:42.320 --> 00:52:49.320]   Now there, that's part of the team here of APFL, APFL has been growing in the meanwhile but that's one of the teams here.
[00:52:49.320 --> 00:53:04.320]   There's also another team more related to robotics and actually self-driving cars, although they cannot say that they work on self-driving cars and stuff, but that's also related, they also have computer vision expertise and people doing that there.
[00:53:04.320 --> 00:53:21.320]   There was a startup called Dacuda, they had at some point a product that was called a scanning mouse, so a mouse actually has a small light sensor below it that tracks, you know, with a laser and then reflection patterns and so on and will track your motion.
[00:53:21.320 --> 00:53:27.320]   What they did was replace that with a camera that actually just, or augment that with a camera that would look at anything below your mouse.
[00:53:27.320 --> 00:53:36.320]   So they had a little window and the mouse not only was a mouse but was also a scanner so you could scan receipts and stuff like that.
[00:53:36.320 --> 00:53:41.320]   That was their first product, of course eventually that would all be replaced by just taking a picture.
[00:53:41.320 --> 00:53:52.320]   So, but then after that they wanted to go to 3D scanning and things like this and then they got acquired by Magic Leap as the basis for the tracking team to augment the tracking team.
[00:53:52.320 --> 00:54:00.320]   In the meanwhile, most of the Magic Leap computer vision team is actually here in Zurich.
[00:54:00.320 --> 00:54:15.320]   There's about 60 people I think that do computer vision. They're in the same building as the informatics department in the AI center in Eurlico.
[00:54:15.320 --> 00:54:17.320]   What else here?
[00:54:17.320 --> 00:54:25.320]   Bunch of other startups and small companies or companies that use maybe Leica also.
[00:54:25.320 --> 00:54:29.320]   There was a startup that was doing drone flights.
[00:54:29.320 --> 00:54:36.320]   They, I mean there's many startups doing drones here in Zurich. This whole ecosystem.
[00:54:36.320 --> 00:54:42.320]   Oterion is actually a startup followed by one of my students, Lauren Smeyer.
[00:54:42.320 --> 00:54:52.320]   They do a bit of computer vision, not so much, but one startup was going to do the self-lying drones for GoPro.
[00:54:52.320 --> 00:54:57.320]   So first, themselves, then they got bought by GoPro. That didn't work out. Then they got bought by Leica.
[00:54:57.320 --> 00:55:06.320]   Leica now has the self-lying scanners. So lighter scanners mounted on drones that can kind of do a map of a building by flying through it and so on.
[00:55:06.320 --> 00:55:13.320]   Leica Geosystems more in general has a lot of computer vision, robotics, you know, and other metrology applications.
[00:55:13.320 --> 00:55:24.320]   They historically were based in Hebrug, or are based in Hebrug next to the border with Austria in Liechtenstein in that corner.
[00:55:24.320 --> 00:55:33.320]   But they now more and more also have a big operation in Zurich, both doing these type of things, but also actually doing a lot of graphics.
[00:55:33.320 --> 00:55:45.320]   So they're part of the bigger hexagon group. And so hexagon has also a good part of their hexagon digital realities platform is also being built here in Zurich.
[00:55:45.320 --> 00:55:55.320]   And that's more on the graphic side, representing digital representations in the cloud of cities and other kind of scans.
[00:55:55.320 --> 00:56:16.320]   Anyway, so that's a little bit of, you know, a little bit of the things, the many things that happen in Zurich in this space is actually, I would say that in the space of computer vision, especially, oh, and I forgot, of course, the Microsoft Mixed with IT and the iLab that I set up.
[00:56:16.320 --> 00:56:25.320]   So actually, I'm only a half time professor at ETH. My other half I'm working for Microsoft and leading this lab here.
[00:56:25.320 --> 00:56:31.320]   The, and what I worked on is essentially this device, the HoloLens 2.
[00:56:31.320 --> 00:56:40.320]   In the meanwhile, we work much more on cloud services. So I have a relatively small team here, about 25 people.
[00:56:40.320 --> 00:56:59.320]   The whole lab is about 30 people. We mostly work on a cloud service to map environments and to be able to, you know, if you think of the digital transformation, the goal is that eventually there will be a digital copy, a digital twin that collects all of the digital information about a particular environment,
[00:56:59.320 --> 00:57:14.320]   a factory or something like this. And what we're in particular focused on is making sure that the digital twin can be one-to-one connected to the real world in the sense that if you walk around with a device like HoloLens or with your mobile phone,
[00:57:14.320 --> 00:57:27.320]   you can kind of have a one-to-one overlay between the real world and the digital twin so that you can both consult the digital twin in the field, in the factory, for example, intuitively by just pointing at something,
[00:57:27.320 --> 00:57:31.320]   or if you wear HoloLens, it's even simpler, you just look at something.
[00:57:31.320 --> 00:57:37.320]   And you see all the layers of information are relevant to whatever your task is or your job is.
[00:57:37.320 --> 00:57:49.320]   But also that if you actually do something, so you now do maintenance or you do something, that information can be also, you know, update, can update in a natural way, can simply update the digital twin also.
[00:57:49.320 --> 00:57:56.320]   So you've got to do a maintenance procedure, that documentation, maintenance procedure, and now I'll get copied over to that machine in the digital twin, et cetera, et cetera.
[00:57:56.320 --> 00:58:06.320]   So we're working on a cloud service that supports that. It's essentially a mapping, a 3D mapping of the environment based on just capturing images as you walk around.
[00:58:06.320 --> 00:58:23.320]   So if you look at Zurich is actually quite exceptional in the sense that in terms of how much computer vision opportunities or, you know, R&D activities going on in Zurich, in the broader Zurich space,
[00:58:23.320 --> 00:58:38.320]   you know, if I look in particular at Mixed Reality, so if you look here, you have quite, you know, Largely's Quest Team, Apple is doing things here in Mixed Reality,
[00:58:38.320 --> 00:58:43.320]   Google is doing things here in Mixed Reality, Magic Leap is doing things, PTC is doing things, et cetera.
[00:58:43.320 --> 00:58:57.320]   So essentially every major player in the field actually has an R&D computer vision team supporting their Mixed Reality applications or products in Zurich.
[00:58:57.320 --> 00:59:09.320]   That's on par essentially with the Bay Area and the Pacific Northwest and, you know, and then Zurich and that's pretty much it worldwide, I think, as the top places for these type of activities, which is, you know, quite interesting.
[00:59:09.320 --> 00:59:14.320]   And so if you're interested in the space, there are opportunities here.
[00:59:14.320 --> 00:59:23.320]   Okay, so now let me just dive and this will be actually, you know, in a number of examples of things that exist in the space.
[00:59:23.320 --> 00:59:36.320]   It's actually biased towards slightly older examples, as we did at the beginning of the lecture, the beginning of your journey in visual computing, I think it's good to also see a little bit of what did people do maybe 10 years ago
[00:59:36.320 --> 00:59:50.320]   in some of those nascent, back then nascent areas, where some of those things you will see now are like, well, of course, and, you know, now you have, like, you know, almost fully self-driving cars, not yet fully, but et cetera.
[00:59:50.320 --> 01:00:02.320]   Here I'll show some of the things more at the beginning of that, et cetera, et cetera, also because there the algorithms are still a little bit more kind of exposed or it's more clear what actually the direct link is to some of the things we'll cover here.
[01:00:02.320 --> 01:00:09.320]   Okay, so here's some examples of first is, you know, all of these kind of 3D and interactive maps and stuff like that.
[01:00:09.320 --> 01:00:17.320]   So you can both have algorithms. This was more the time where there was still some interactive modeling involved in, you can see it's relatively clean and so on.
[01:00:17.320 --> 01:00:31.320]   So, but still you have a lot of image processing and graphics and so on to, even if you do this interactively, nowadays, you know, there's a lot of algorithms and things that do this automatically.
[01:00:31.320 --> 01:00:48.320]   Here's work from one of my students. He works, he worked then at Google and now at WeMo, so still Alphabet on self-driving cars, but essentially this was work, you know, done about more than 10 years ago.
[01:00:48.320 --> 01:00:59.320]   Our goal was to essentially, from camera, similar to Street View, so cameras mounted on vehicles that record the environment.
[01:00:59.320 --> 01:01:04.320]   Our goal was to be able to do the best we could in terms of reconstruction in real time.
[01:01:04.320 --> 01:01:12.320]   So if we record an hour data, we wanted to be able to process it in one hour and build 3D models of environments.
[01:01:12.320 --> 01:01:20.320]   And for doing that, we leveraged graphics processors, so GPUs already back then we did general purpose computing or computer vision computing on graphics processor,
[01:01:20.320 --> 01:01:32.320]   which now is the big thing why NVIDIA stock has gone through the roof is because everybody now needs GPUs, not for doing graphics, you know, which you'll see how GPUs do that in the second half of this lecture,
[01:01:32.320 --> 01:01:39.320]   but actually to train deep neural nets or like things like convolutional neural nets and so on that we also look a little bit at in this lecture.
[01:01:39.320 --> 01:01:47.320]   But back then we were using our GPUs to do this type of more classical geometric processing reconstruction.
[01:01:47.320 --> 01:02:03.320]   Here's also a bit of other older work from my lab, but was kind of one of the first or the first that really combined both the geometric reconstruction of the space with also a semantic interpretation of the scene.
[01:02:03.320 --> 01:02:14.320]   So people have done both separately before, but this was really seeing if we do both, we solve both problems together, we ended up representing it.
[01:02:14.320 --> 01:02:21.320]   So essentially when you what you do is you look at an image and you have neighboring images and you compare those.
[01:02:21.320 --> 01:02:28.320]   And so you say you try to find and we'll look at how to do that in this lecture for a particular point in one image.
[01:02:28.320 --> 01:02:31.320]   You know, you look in the neighboring images like where is that point.
[01:02:31.320 --> 01:02:38.320]   I talked a little bit earlier about in video from one frame to the next, you would try to find back the points how things are moving.
[01:02:38.320 --> 01:02:48.320]   You can also do that if you just change the viewpoint a bit. So I have this viewpoint and I have this viewpoint slightly different and I compare both images and what we'll do is correlation.
[01:02:48.320 --> 01:02:50.320]   This is something you'll see in the third week.
[01:02:50.320 --> 01:02:56.320]   I would actually be absent a third week, but one of my postdocs will replace me for that.
[01:02:56.320 --> 01:02:58.320]   You do a correlation.
[01:02:58.320 --> 01:03:05.320]   So you take thing you represent as a vector and you see if the two vectors actually align or don't align.
[01:03:05.320 --> 01:03:11.320]   And you find things that correspond that way that are likely to correspond.
[01:03:11.320 --> 01:03:20.320]   You do that. And then if I find this point here is this point over here and then that point geometrically given the camera corresponds to this rain space.
[01:03:20.320 --> 01:03:25.320]   Wherever those two rays intersect, that must be where the original 3d point that I see in both images.
[01:03:25.320 --> 01:03:26.320]   And it's the same point.
[01:03:26.320 --> 01:03:30.320]   Then I know that 3d point must have been over there in space.
[01:03:30.320 --> 01:03:35.320]   That's the process that's done here, which is represented here.
[01:03:35.320 --> 01:03:37.320]   So we have a reference image, a bunch of images around it.
[01:03:37.320 --> 01:03:44.320]   We determine correspondence between all those images with this correlation process in the simplest way.
[01:03:44.320 --> 01:03:51.320]   For every point in that reference image, we have now through triangulation determined how far it is.
[01:03:51.320 --> 01:03:55.320]   In that image what you see is it's a representation for the points where we're successful.
[01:03:55.320 --> 01:03:59.320]   The color indicates and codes in a sense how far the point was.
[01:03:59.320 --> 01:04:04.320]   So this is essentially a color representation of the depth.
[01:04:04.320 --> 01:04:08.320]   We do that for all the images all around.
[01:04:08.320 --> 01:04:15.320]   And we've also computed and we want this talk about that and be able to talk about it in this lecture.
[01:04:15.320 --> 01:04:21.320]   But this will be covered in computer vision and then in 3d vision in the masters if you're interested.
[01:04:21.320 --> 01:04:27.320]   We find where all those cameras are geometrically with respect to each other around the building.
[01:04:27.320 --> 01:04:31.320]   So now we have, well, from here this is roughly the things I see from here.
[01:04:31.320 --> 01:04:37.320]   From here there's these things and so I have all these measurements from all around, but they all like separate points.
[01:04:37.320 --> 01:04:45.320]   The process we do then, and this is the result of that, is to say, okay, now let me try to do a segmentation problem.
[01:04:45.320 --> 01:04:52.320]   I will try to find the surface that separates the points that are outside from the points that are inside.
[01:04:52.320 --> 01:04:59.320]   And of course whenever I see a point that's an indication that what's in front is outside and then behind it must be inside.
[01:04:59.320 --> 01:05:11.320]   And as a result of that kind of optimization process that separates inside from outside based on all the evidence that I saw from all the different images surrounding it.
[01:05:11.320 --> 01:05:18.320]   And then we do some regularization which says that essentially we want that surface to be as close as possible to the data.
[01:05:18.320 --> 01:05:27.320]   So if I found a point here and in front it must be empty and behind it must be occupied, I would like to be as close as possible to every measurement I have.
[01:05:27.320 --> 01:05:36.320]   But at the same time, and we'll see this actually in general, at the same time I would like to have a somewhat simple solution.
[01:05:36.320 --> 01:05:41.320]   Typically if I compute this independently per point, I will have something very noisy.
[01:05:41.320 --> 01:05:46.320]   Point here, point there, there will be noise on my measurements and so I will have points going like this.
[01:05:46.320 --> 01:05:53.320]   And if I want an exact solution, my surface will have to go zigzag like this through all those points in an outside point.
[01:05:53.320 --> 01:05:55.320]   So essentially that's not what I want.
[01:05:55.320 --> 01:05:58.320]   What I want is like, okay, I know all those points are roughly here.
[01:05:58.320 --> 01:06:02.320]   I want a smooth surface that gets close to all those points.
[01:06:02.320 --> 01:06:04.320]   This we'll call regularization.
[01:06:04.320 --> 01:06:11.320]   This is actually a general principle for any problem that you'll encounter throughout, not only in this lecture.
[01:06:11.320 --> 01:06:15.320]   It's used a lot in computer vision, but also in many other problems.
[01:06:15.320 --> 01:06:24.320]   It's when you are trying to fit a model to data, but that data is noisy, you don't want to blindly fit the model to data.
[01:06:24.320 --> 01:06:32.320]   You want to fit it to data as much as possible, but also at the same time try to keep that solution somewhat simple.
[01:06:32.320 --> 01:06:37.320]   Because that simple solution is more likely to be the correct solution than not.
[01:06:37.320 --> 01:06:43.320]   Let's say you have a bunch of points that almost look like a line.
[01:06:43.320 --> 01:06:48.320]   You could of course also, if you have 10 points, you could fit a 10 for the polynomial exactly through those 10 points.
[01:06:48.320 --> 01:06:53.320]   And that's going to be an exact zero error fitting solution to that.
[01:06:53.320 --> 01:06:59.320]   So an exact perfect solution to the problem you ask to solve, the curve that goes through those 10 points.
[01:06:59.320 --> 01:07:08.320]   However, you probably all realize or you all know already that if it's close enough, if a straight line going through those points is close enough,
[01:07:08.320 --> 01:07:10.320]   that's probably a much better solution.
[01:07:10.320 --> 01:07:12.320]   In particular, it's a much better solution.
[01:07:12.320 --> 01:07:18.320]   If now for another point you get a new point coming in and you want to predict where that point will show up,
[01:07:18.320 --> 01:07:22.320]   your straight line fitting through the data is probably a much better fit,
[01:07:22.320 --> 01:07:30.320]   much better predictor than your 10th degree polynomial going crazy to somehow go through exactly through all those 10 points that you get initially.
[01:07:30.320 --> 01:07:38.320]   The 11th point will be much closer probably, very, very likely to the straight line than to this 10 for the polynomial.
[01:07:38.320 --> 01:07:43.320]   Same principle, whenever you have to solve essentially an inverse problem,
[01:07:43.320 --> 01:07:49.320]   you're given some data and you're trying to build up the model that underlies the data, that's an inverse problem.
[01:07:49.320 --> 01:07:52.320]   Computer vision is full of inverse problems, right?
[01:07:52.320 --> 01:08:01.320]   Because you get images which are the result of a projection from a 3D model, for example, you get an image, you get a result,
[01:08:01.320 --> 01:08:08.320]   or you get an image and you try to kind of figure out where did that image come from?
[01:08:08.320 --> 01:08:14.320]   What is the underlying model that represents that image was an image projection from?
[01:08:14.320 --> 01:08:17.320]   You're essentially trying to invert that process.
[01:08:17.320 --> 01:08:18.320]   It's typically ill-posed.
[01:08:18.320 --> 01:08:22.320]   For example, you go from a 2D projection to actually a 3D representation.
[01:08:22.320 --> 01:08:26.320]   So information got lost in that projection process, so you don't have all the information.
[01:08:26.320 --> 01:08:34.320]   Now you collect information, enough information to reconstruct, but there's noise, so everything is not very precise, so it's an inverse problem.
[01:08:34.320 --> 01:08:45.320]   Typically, it's really important to combine, to be able to combine the data and your initial, your prior assumptions on how the model should look like.
[01:08:45.320 --> 01:08:51.320]   In particular, typically, you would like, you would prefer a simpler model.
[01:08:51.320 --> 01:09:04.320]   So you apply, for example, in the process on the top there, we just applied the general thing that we preferred smooth solutions in general.
[01:09:04.320 --> 01:09:16.320]   At the bottom, we did exactly the same thing, except that now we also, in addition to getting the depth information extracted from images,
[01:09:16.320 --> 01:09:20.320]   we also looked at the image, and in this case, this was pre-all these deep neural nets.
[01:09:20.320 --> 01:09:28.320]   This was done with a much simpler classifier, and it would essentially classify the scene in, you know, not in two foreground background,
[01:09:28.320 --> 01:09:42.320]   as we said, as we'll see in the next week or so, but in a few more categories, we tried to segment the image in sky, building, vegetation, ground, and stuff.
[01:09:42.320 --> 01:09:49.320]   So we had five categories, so stuff is like everything that's not those four categories.
[01:09:49.320 --> 01:09:58.320]   And now we combine that, and now we do a separate reconstruction process, and instead of just separating it in two classes, inside and outside,
[01:09:58.320 --> 01:10:09.320]   we now segment it in five classes, being ground, so everything below the ground surface is ground, vegetation, so it's volumes, right?
[01:10:09.320 --> 01:10:16.320]   It's three-dimensional volumetric representation, so it's a cube, and you say which voxels, which points in that are vegetation,
[01:10:16.320 --> 01:10:22.320]   which ones are the inside of the building, which ones are below the ground, et cetera.
[01:10:22.320 --> 01:10:31.320]   But we use exactly the same geometric information, but we now have different priors for different types of surfaces.
[01:10:31.320 --> 01:10:42.320]   Vegetation still has the same priors of being smooth in general, but no particular orientation preferences.
[01:10:42.320 --> 01:10:47.320]   But the ground, we actually said the ground, that's actually a surface that tends to have a normal pointing up.
[01:10:47.320 --> 01:10:56.320]   It's mostly a horizontal surface. It can deviate from it if there's evidence for it, but we prefer, in absence of more evidence, we prefer to have it.
[01:10:56.320 --> 01:11:02.320]   It's very cheap to make a large horizontal surface, and it's kind of expensive to make the ground vertical.
[01:11:02.320 --> 01:11:08.320]   That's what mathematically we put in this process, and it's different from there.
[01:11:08.320 --> 01:11:15.320]   Here we just paid a price in our optimization process. We paid a price for every little bit of surface we instantiated.
[01:11:15.320 --> 01:11:25.320]   The ground, you can see here, it's not very well measured, so in the absence of good measurement, and we have to pay a price for surface in the optimization,
[01:11:25.320 --> 01:11:29.320]   we said let's just ignore these surfaces that we don't really know where they are.
[01:11:29.320 --> 01:11:35.320]   Here we say, oh, ground, I prefer to keep extending the ground horizontally. I don't care, that's cheap,
[01:11:35.320 --> 01:11:42.320]   but we have to wrap it up and have it upside down, like you have these little patches there, remember, they're volumetric, so they have a bottom side also.
[01:11:42.320 --> 01:11:47.320]   That's actually very expensive to have ground that actually has a normal pointing down, that doesn't exist.
[01:11:47.320 --> 01:11:52.320]   So that's very unlikely. So suddenly it extends the ground out through the whole surface.
[01:11:52.320 --> 01:12:01.320]   Buildings, well, buildings we like for sats to be mostly vertical, so it's very cheap to have them vertical, but kind of expensive to have them horizontal, et cetera, et cetera.
[01:12:01.320 --> 01:12:11.320]   So the same geometric information, but a little bit of this semantic information to help, and then based on the semantics do something different in terms of our assumptions to be able to do things differently,
[01:12:11.320 --> 01:12:16.320]   suddenly you get qualitatively a much, much better reconstruction.
[01:12:16.320 --> 01:12:25.320]   Anyway, so just to bring in also some of the concepts underlying this, nowadays with deep neural networks you can somehow do all of these at once in one big learning problem,
[01:12:25.320 --> 01:12:30.320]   and much less of than the insights here I revealed.
[01:12:30.320 --> 01:12:36.320]   [INAUDIBLE]
[01:12:36.320 --> 01:12:37.320]   Yes.
[01:12:37.320 --> 01:12:40.320]   [INAUDIBLE]
[01:12:40.320 --> 01:12:49.320]   So the flat roof was actually not very expensive or so. So this would still be fine. We actually also played around with follow-up work that we did with Conrad Schindler.
[01:12:49.320 --> 01:12:56.320]   We actually had a separate building class, so this was actually building seen from the ground mostly that we processed.
[01:12:56.320 --> 01:13:10.320]   Conrad, he looked at aerial images, so he's more in remote sensing and satellite imagery and stuff like that, and so in that case, most of what you see of the building is actually the roof.
[01:13:10.320 --> 01:13:17.320]   And so there they instantiated, they learned a separate class that corresponded to roof, for example, because there they had evidence.
[01:13:17.320 --> 01:13:24.320]   Here the roof is actually not observed from if you walk from the ground, so this is just the default filling of the roof because you actually don't observe it.
[01:13:24.320 --> 01:13:34.320]   You actually see that the roof is missing there because we didn't measure it. It was all images like this from the ground, and you can see that you don't actually see the roof in that one.
[01:13:34.320 --> 01:13:36.320]   That's a good question. Yes?
[01:13:36.320 --> 01:13:53.320]   How accurate is such a system being for any not specific building and type of vegetation if we need to constantly make a different model or different assumptions like the roof will be triangular, the street will be horizontal and so on and so forth?
[01:13:53.320 --> 01:14:05.320]   So the street doesn't have to be horizontal, so the street horizontal is very cheap, like this is just a little bit more expensive and so on, but once you get to this, it starts becoming significantly more expensive, but it's all a trade-off.
[01:14:05.320 --> 01:14:27.320]   If you have strong data evidence, you can see this is not very good data. There's holes, there's stuff. If there's good data, the prior barely matters. It's just that if you are missing data, and so on, then the prior starts dominating and playing a big role, the nice thing about this system was if you had a complete wall missing, it would kind of fill it in by default vertical.
[01:14:27.320 --> 01:14:34.320]   But yes, if it's the wrong assumption, if you're actually looking at more pyramidal construction or so, then it's just going to fill it in the wrong way.
[01:14:34.320 --> 01:14:55.320]   And in data-driven, this is the whole problem of bias, a data set biases and things like this. If you have a startup here and you, let's say, would only train on white people, Caucasian people, and then of course you would try to sell it in whatever in Africa and then it would work terribly, like it wouldn't work at all.
[01:14:55.320 --> 01:15:07.320]   So it's the same problem, right? All machine learning will be dependent on what data you train on. If that's not the same distribution as where you apply it, it's not going to work.
[01:15:07.320 --> 01:15:16.320]   And yeah, so.
[01:15:16.320 --> 01:15:34.320]   Here's another example. I think the video codec is too old to play here. It just has the audio. But this was essentially some relatively simple kind of cameras watching this simple world, like more easy to.
[01:15:34.320 --> 01:15:37.320]   You know, and essentially kind of doing that.
[01:15:37.320 --> 01:15:39.320]   Willow garage will shark team. We just program.
[01:15:39.320 --> 01:15:54.320]   This is another example. Let that play. Willow garage. We like to challenge our raw software by doing short hackathon sprints. These sprints help spark new ideas, test our raw software, and most importantly, our fun.
[01:15:54.320 --> 01:15:56.320]   So by the way, our most recent sprint was a game.
[01:15:56.320 --> 01:15:57.320]   Just as some history.
[01:15:57.320 --> 01:16:08.320]   If any of you are in robotics or are familiar with robotics, Ross, the robotic operating system was actually developed initially at the garage at this period.
[01:16:08.320 --> 01:16:10.320]   You know, a few years before this.
[01:16:10.320 --> 01:16:11.320]   I will go right.
[01:16:11.320 --> 01:16:21.320]   I will go right.
[01:16:21.320 --> 01:16:46.320]   I think the crawler service. So the one that they need. So they had this Google had Google had technology to index the.
[01:16:46.320 --> 01:16:55.320]   You know, to compute search to do search over the web, to be able to actually try that they needed to kind of crowd the whole web and collect the data.
[01:16:55.320 --> 01:17:07.320]   The founder of Willow garage essentially provided that service to Google and got a little bit of stock in exchange right when they started Google.
[01:17:07.320 --> 01:17:19.320]   And so he's a billionaire and decided that he wanted to do robotics and launch the whole willow garage and, you know, resulted in this interesting robot that he made available to the research community.
[01:17:19.320 --> 01:17:28.320]   But also lasting legacy is Ross, the robotic operating system, which is used by everyone.
[01:17:28.320 --> 01:17:40.320]   Everyone in robotics. If you do robotics projects in your, you know, later or in your masters or whatever, you'll be using Ross. By now it's mostly Ross. It's gradually becoming Ross to the next version of it.
[01:17:40.320 --> 01:17:50.320]   He's on the one that very, very early, you know, first kind of prototype or very early kind of mobile I system.
[01:17:50.320 --> 01:17:55.320]   Who has heard of mobile I.
[01:17:55.320 --> 01:18:00.320]   Oh, wow. No one. I mean, one person like.
[01:18:00.320 --> 01:18:09.320]   Okay, so, so mobile I is, I think still the most successful computer vision startup.
[01:18:09.320 --> 01:18:12.320]   In terms of of acquisition.
[01:18:12.320 --> 01:18:16.320]   It was acquired by Intel.
[01:18:16.320 --> 01:18:21.320]   I don't know. Maybe like maybe 10 years ago or like 5, 10 years ago.
[01:18:21.320 --> 01:18:25.320]   For 16 billion. So not bad for a startup.
[01:18:25.320 --> 01:18:33.320]   They're essentially built. They, you know, very likely if you have a car, your parents have a car is very likely their technology is building.
[01:18:33.320 --> 01:18:36.320]   They're not a self driving company, although.
[01:18:36.320 --> 01:18:48.320]   As Intel needed cash, Intel actually resold or like put the company partially back on the, did an IPO so that they could get some money back to.
[01:18:48.320 --> 01:18:52.320]   You know, to fund their, you know, their operations.
[01:18:52.320 --> 01:18:56.320]   So Intel has been struggling a bit.
[01:18:56.320 --> 01:18:59.320]   So the.
[01:18:59.320 --> 01:19:02.320]   So, so essentially.
[01:19:02.320 --> 01:19:08.320]   Mobile I is so they talk about self driving, but mostly they're focused on it.
[01:19:08.320 --> 01:19:13.320]   It is stands for advanced driver assistance systems.
[01:19:13.320 --> 01:19:20.320]   And so it's really about these kind of cameras that are built in. So if, if your car.
[01:19:20.320 --> 01:19:28.320]   Or your parents car, whatever, like the cars that you kind of use sometimes have a camera somehow in the windshield in the front, like a camera that looks at the street and so on.
[01:19:28.320 --> 01:19:31.320]   It's probably a mobile I system. Okay, so they sell.
[01:19:31.320 --> 01:19:37.320]   Not the cameras. They actually sell the chips that process the cameras.
[01:19:37.320 --> 01:19:40.320]   Back in 1996.
[01:19:40.320 --> 01:19:42.320]   In a European project.
[01:19:42.320 --> 01:19:47.320]   I visited Jerusalem and I'm not sure I was the CEO of of mobile.
[01:19:47.320 --> 01:19:55.320]   I had this little chip, this little box in the open and he said, this is a chip, you know, that's going to do great stuff for for cars and stuff.
[01:19:55.320 --> 01:20:00.320]   And it was, it had filters and things like this. Some of the stuff we'll see back then.
[01:20:00.320 --> 01:20:05.320]   It had filters and other things that would help detect in hardware very efficiently the road.
[01:20:05.320 --> 01:20:11.320]   Like in the camera kind of see where the road lines are and stuff like that that would help you keep, you know, have lane warnings.
[01:20:11.320 --> 01:20:23.320]   It would also detect if a car was in front of you and make a signal or if a pedestrian was in front of you, it would all do all those things in hardware with very little power so that it could actually run in real time low latency on the car.
[01:20:23.320 --> 01:20:27.320]   This was back in 96 when this was not a given.
[01:20:27.320 --> 01:20:31.320]   So, so this, this was one of the first system.
[01:20:31.320 --> 01:20:38.320]   And I don't know that you could put in your car and it would kind of tell you, you know, how far you were from colliding with the car or stuff like that.
[01:20:38.320 --> 01:20:46.320]   He's actually one of their videos from long ago and are less likely to be identified by drivers.
[01:20:46.320 --> 01:20:57.320]   The mobile eye system identifies pedestrians and cyclists during daylight hours and can determine if the danger of a collision exists.
[01:20:57.320 --> 01:21:10.320]   In the event of a possible collision, the system issues an alert providing you with up to two seconds to break and prevent an accident.
[01:21:10.320 --> 01:21:12.320]   Okay, you get it, right?
[01:21:12.320 --> 01:21:14.320]   Anyway, so this is not building in most cars.
[01:21:14.320 --> 01:21:19.320]   Actually, I think there's there's rules in many countries in place that force you to have systems like this in place and so on.
[01:21:19.320 --> 01:21:21.320]   But this is where this all started, right?
[01:21:21.320 --> 01:21:26.320]   And so this is someone, you know, this was before starting this company.
[01:21:26.320 --> 01:21:30.320]   I'm not, I was a professor at the university.
[01:21:30.320 --> 01:21:32.320]   He still is, I think, actually.
[01:21:32.320 --> 01:21:36.320]   But this was, but it's also CEO of mobile.
[01:21:36.320 --> 01:21:37.320]   This is another system.
[01:21:37.320 --> 01:21:42.320]   This is some work that actually that that FPGA was actually that board.
[01:21:42.320 --> 01:21:50.320]   As far as I know, was actually our, at least the first prototype, which was developed in Zurich by supercomputing systems, which is kind of an integrated that does.
[01:21:50.320 --> 01:21:57.320]   Transfer kind of code to FPGA implementations or embedded implementations.
[01:21:57.320 --> 01:21:59.320]   What they did, this was.
[01:21:59.320 --> 01:22:01.320]   Daimler.
[01:22:01.320 --> 01:22:06.320]   They had a stereo camera system that would essentially, you know, same thing.
[01:22:06.320 --> 01:22:11.320]   We have two eyes and we perceive depth in front of us, most of us at least.
[01:22:11.320 --> 01:22:16.320]   You know, again, an encoding of the depth based on on color.
[01:22:16.320 --> 01:22:26.320]   From essentially comparing to nearby images that look mostly the same and the small differences actually reflect the depth, the depth of the objects.
[01:22:26.320 --> 01:22:30.320]   They essentially build a very fast hardware implementation.
[01:22:30.320 --> 01:22:40.320]   You know, board that they would build in, I think at the time in some of the high end as classes had this building, you know, 10 or 10 or more years ago.
[01:22:40.320 --> 01:22:44.320]   From this, they went to this kind of what they call stick sales, which was okay to roll.
[01:22:44.320 --> 01:22:52.320]   I don't care about, but I care about representing like with these vertical sticks instead of pixel, it was stick sales.
[01:22:52.320 --> 01:22:58.320]   These vertical sticks were kind of representing kind of clusters of those were representing cars and other objects and so on.
[01:22:58.320 --> 01:23:10.320]   Essentially, they were fitting kind of vertical surfaces to the world, ignoring the road and then every vertical surface was represented compactly by this few sticks and so on and so on.
[01:23:10.320 --> 01:23:21.320]   And then they did optical flow, something we'll also talk about in the sixth week of the semester when we talk about video compression, but you see also here to follow where things are moving and so on.
[01:23:21.320 --> 01:23:25.320]   Optical flow is kind of the algorithm you kind of you would use.
[01:23:25.320 --> 01:23:38.320]   So optical flow and depth and then put that together to essentially track, you know, not just from pixel to pixel and frame to frame, but actually then have a filter that tracks the motion of the object as a whole of the car.
[01:23:38.320 --> 01:23:42.320]   That's in front of you and see if it's on a colliding path with you or not, right?
[01:23:42.320 --> 01:23:48.320]   And then they decide to sound alarm or to hit emergency brake or so on.
[01:23:48.320 --> 01:23:51.320]   Here's an example of kind of their 6D vision system.
[01:23:51.320 --> 01:23:56.320]   This was because it was 3D, but in addition, it also has a vector indicating the motion.
[01:23:56.320 --> 01:23:57.320]   That's another 3D vector.
[01:23:57.320 --> 01:23:59.320]   So they called it 6D.
[01:23:59.320 --> 01:24:07.320]   So here's a project that oops.
[01:24:07.320 --> 01:24:16.320]   This was about relatively simple self driving.
[01:24:16.320 --> 01:24:18.320]   So self driving in the parking lot.
[01:24:18.320 --> 01:24:23.320]   So you drop off your car and then the car goes park itself or the charge itself.
[01:24:23.320 --> 01:24:27.320]   So the charging spot once it's charged, let's go to the car go there.
[01:24:27.320 --> 01:24:35.320]   Once you come back, for example, at the airport, the car comes pick you up at the, you know, and you step in your car and drive.
[01:24:35.320 --> 01:24:38.320]   So we charge is a collaborative project funded by the European Commission.
[01:24:38.320 --> 01:24:44.320]   Paul Ferger was then at the postdoc in ASL.
[01:24:44.320 --> 01:24:49.320]   The robotics lab in the Royal NC Guard.
[01:24:49.320 --> 01:24:51.320]   Then went to Apple, worked on a self driving project.
[01:24:51.320 --> 01:24:55.320]   Now he's one of the leaders at Med-Age.
[01:24:55.320 --> 01:24:59.320]   Using a smartphone app, the parking process is started.
[01:24:59.320 --> 01:25:01.320]   First of all, the vehicle can...
[01:25:01.320 --> 01:25:03.320]   Okay, so you get the idea.
[01:25:03.320 --> 01:25:06.320]   This is some of the stuff we are doing under hood.
[01:25:06.320 --> 01:25:11.320]   Here you see the car is moving and all these rays corresponds to features and things we see.
[01:25:11.320 --> 01:25:12.320]   This was surround.
[01:25:12.320 --> 01:25:15.320]   You see it's surround images.
[01:25:15.320 --> 01:25:18.320]   Full 180 views kind of from all four sides of the car.
[01:25:18.320 --> 01:25:21.320]   So we had a surround view of the car.
[01:25:21.320 --> 01:25:25.320]   Those rays corresponds to things we signed the environment and could localize our self with.
[01:25:25.320 --> 01:25:27.320]   This is a top view of the parking garage.
[01:25:27.320 --> 01:25:35.320]   This is where the car is and each of those rays corresponds to one point we recognize in one of those views.
[01:25:35.320 --> 01:25:44.320]   This was then some real time geometric obstacle kind of detection from those fisheye cameras.
[01:25:44.320 --> 01:25:46.320]   Determining free space.
[01:25:46.320 --> 01:25:49.320]   Finding free parking spots and stuff like that.
[01:25:49.320 --> 01:25:53.320]   The special thing was we didn't use a stereo system for these two cameras,
[01:25:53.320 --> 01:25:58.320]   but we used the moving camera essentially, which also works.
[01:25:58.320 --> 01:26:01.320]   Some work we did longer ago.
[01:26:01.320 --> 01:26:05.320]   For robots, this was azimot.
[01:26:05.320 --> 01:26:12.320]   This was a humanoid robot built already 15 years ago or 20 years ago almost.
[01:26:12.320 --> 01:26:14.320]   This was around 2010.
[01:26:14.320 --> 01:26:17.320]   Again, you see optical flow, tracking features.
[01:26:17.320 --> 01:26:23.320]   We'll see the basics of this in this lecture, again in the sixth lecture.
[01:26:23.320 --> 01:26:25.320]   This then determines and builds map.
[01:26:25.320 --> 01:26:31.320]   In some way, what we do here is also very related to some of the things we do at this point
[01:26:31.320 --> 01:26:34.320]   that I explained earlier that we do at Microsoft.
[01:26:34.320 --> 01:26:38.320]   And also actually that one of the other teams here in Mixuality are doing
[01:26:38.320 --> 01:26:43.320]   replace this robot with a headset with cameras and the person walks around.
[01:26:43.320 --> 01:26:47.320]   You also need to map the environment and do all this in real time in the background.
[01:26:47.320 --> 01:26:54.320]   Just as you walk around, all of this stuff is happening under the hood in the device, essentially.
[01:26:54.320 --> 01:26:57.320]   Then here's some drone stuff.
[01:26:57.320 --> 01:27:04.320]   PIXHawk was a project in the lab and together with many others,
[01:27:04.320 --> 01:27:07.320]   or students from all the different departments,
[01:27:07.320 --> 01:27:13.320]   our goal was to enable onboard computer vision autonomous drones,
[01:27:13.320 --> 01:27:16.320]   but very quickly we realized there was missing infrastructure.
[01:27:16.320 --> 01:27:22.320]   And so we built, or in particular, Lorenz Meyer,
[01:27:22.320 --> 01:27:27.320]   got students from electrical engineering, from mechanical engineering
[01:27:27.320 --> 01:27:31.320]   and started building everything that was needed to enable these computer vision explorations,
[01:27:31.320 --> 01:27:36.320]   but essentially built all of the drone software,
[01:27:36.320 --> 01:27:42.320]   the electronics that would control and be the core of the drone,
[01:27:42.320 --> 01:27:47.320]   which became PIXHawk and the PX4, and then this is now what,
[01:27:47.320 --> 01:27:49.320]   this is a whole open source ecosystem.
[01:27:49.320 --> 01:27:53.320]   It's actually the default open source ecosystem throughout the world.
[01:27:53.320 --> 01:27:56.320]   Oterian is a little bit like Red Hat is doing for Linux,
[01:27:56.320 --> 01:28:00.320]   building a commercial business of services and support and so on,
[01:28:00.320 --> 01:28:07.320]   on top of an open source ecosystem, Oterian is doing that for drone software,
[01:28:07.320 --> 01:28:13.320]   for building on top of PIXHawk and so on, that is an open source ecosystem.
[01:28:13.320 --> 01:28:16.320]   But provides services to companies that don't necessarily have the expertise
[01:28:16.320 --> 01:28:20.320]   to build their own solutions on top of it and need certain modules or certain components,
[01:28:20.320 --> 01:28:24.320]   and then they build it for those customers of theirs.
[01:28:24.320 --> 01:28:31.320]   This was the first fully autonomously flying drone
[01:28:31.320 --> 01:28:38.320]   that was flying purely camera-based in close proximity to objects.
[01:28:38.320 --> 01:28:41.320]   So not something that was flying high above with the camera looking down,
[01:28:41.320 --> 01:28:45.320]   but actually something that could avoid obstacles and map out nearby obstacles
[01:28:45.320 --> 01:28:52.320]   and both could fly indoors and outdoors and kind of explore a space and map out a space.
[01:28:52.320 --> 01:28:58.320]   So this was essentially, so some of the boards we built were building,
[01:28:58.320 --> 01:29:03.320]   the students essentially built the first kind of small board flying PC
[01:29:03.320 --> 01:29:06.320]   that could fly on top of a drone.
[01:29:06.320 --> 01:29:09.320]   And that board was both used here for those experiments,
[01:29:09.320 --> 01:29:15.320]   but was also, the batch was made and was sent to CMU and Stanford and MIT,
[01:29:15.320 --> 01:29:20.320]   and so they had somehow made the connections and all of those labs also got some boards to,
[01:29:20.320 --> 01:29:25.320]   and that enabled a lot of research at a time where people had a separate PC doing computing
[01:29:25.320 --> 01:29:30.320]   and then a Wi-Fi connection to the drone, which was very flaky and often the drone would crash
[01:29:30.320 --> 01:29:32.320]   because of the data not getting through.
[01:29:32.320 --> 01:29:36.320]   If the control was actually based on what happened on the PC,
[01:29:36.320 --> 01:29:39.320]   the Wi-Fi connection went down, the drone would kind of crash,
[01:29:39.320 --> 01:29:45.320]   and so having the compute on the drone enabled a lot of research at a time.
[01:29:45.320 --> 01:29:49.320]   As an example, okay, I skipped this one.
[01:29:49.320 --> 01:29:54.320]   This was some indoor navigation, you know, image retrieval.
[01:29:54.320 --> 01:29:56.320]   Okay, let me, I think we are out of time.
[01:29:56.320 --> 01:30:00.320]   So we participated in Project Tango, which was the predecessor of ARCore.
[01:30:00.320 --> 01:30:03.320]   Google was actually planning to build their own devices,
[01:30:03.320 --> 01:30:08.320]   trying to build special phones with depth cameras with all kinds of special sensors
[01:30:08.320 --> 01:30:13.320]   to enable AR experiences on phone type form factors or tablet type form factors.
[01:30:13.320 --> 01:30:16.320]   And then suddenly Apple came out with ARKit,
[01:30:16.320 --> 01:30:21.320]   and Google was like the people there were in shock.
[01:30:21.320 --> 01:30:24.320]   But then what they did was they pivoted their, this effort,
[01:30:24.320 --> 01:30:28.320]   they threw away the special tablets which, you know, took too long to build
[01:30:28.320 --> 01:30:33.320]   and were only building a few thousands and so on.
[01:30:33.320 --> 01:30:36.320]   They threw all of that effort away and tried to use what they wrote,
[01:30:36.320 --> 01:30:40.320]   pivot that and build that in Android phones, and that is what then became,
[01:30:40.320 --> 01:30:43.320]   in a few months they were able to launch ARCore, you know,
[01:30:43.320 --> 01:30:45.320]   a few models at a time and then generalize it.
[01:30:45.320 --> 01:30:48.320]   There are challenges of course that people that build phones,
[01:30:48.320 --> 01:30:52.320]   the OEMs that build phones, they actually don't build them for supporting tracking
[01:30:52.320 --> 01:30:54.320]   while Apple is very smart.
[01:30:54.320 --> 01:30:58.320]   If they decide to build ARKit, they are already building in all the right sensors
[01:30:58.320 --> 01:31:02.320]   and all the right synchronization between your cameras and your IAMUs
[01:31:02.320 --> 01:31:05.320]   and all of those things are done all properly and everything is factory calibrated
[01:31:05.320 --> 01:31:07.320]   and everything is going to work perfectly.
[01:31:07.320 --> 01:31:10.320]   And poor guys at Google are to, you know, struggle big time
[01:31:10.320 --> 01:31:16.320]   to try to match the quality of what Apple was doing
[01:31:16.320 --> 01:31:20.320]   with essentially OEMs that had just slapped together components,
[01:31:20.320 --> 01:31:23.320]   not thinking about doing AR with it and so on and so on.
[01:31:23.320 --> 01:31:27.320]   A little bit better in the meanwhile, but, you know, there is still a gap between the two.
[01:31:27.320 --> 01:31:31.320]   For example, but at least they had done the Tango project,
[01:31:31.320 --> 01:31:36.320]   enable them to very quick follow behind.
[01:31:36.320 --> 01:31:41.320]   Okay, and so this I won't talk about this time, but it will probably come back at some point.
[01:31:41.320 --> 01:31:44.320]   And there are many more examples in the slides that you will find
[01:31:44.320 --> 01:31:46.320]   if there are some things that are particularly of interest to you,
[01:31:46.320 --> 01:31:49.320]   don't hesitate to reach out or things like that.
[01:31:49.320 --> 01:31:51.320]   I leave it at that for today.
[01:31:51.320 --> 01:31:56.320]   [applause]

